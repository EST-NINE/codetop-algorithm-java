---
typora-copy-images-to: ./images
---



[TOC]

# 前言

> 多学一分钟，女友都不同，把障碍变成机会，把问题变成可能。

学习新知识的核心就在于 **重复 + 重复 + 重复**

本人也是从一无所知开始尝试刷算法，中间断断续续痛苦/纠结/无能狂怒。第1次的时候，整人是蒙圈的，看着别人的标准答案慢慢的摸索算法的含义，那真是一支笔一杯茶，一道力扣刷一天。当重复到第5次的时候，开始有些感觉了，看到题目的标题，就可以立刻回想到题目的大概的解题方向，但是很多细节还是脑袋一团浆糊，那就继续重复，当到了第8次的时候，突然就觉得就是这样的，很容易记住呀，不过如此呀。

刷题（本质就是背诵）我们的目的就是要去面试，所以题目尽可能的要选择命中率高的题库去刷，而不是力扣的题目从第一题开始，意义不大。当背诵了300道题目以后，去面试的时候，只要考算法题目，我其实很兴奋的（因为背的很熟悉），刷过的题目的命中率还挺高的。

大家不要把算法题想象的过于高大上，既然是题目，那就是有答案和解题套路的。背诵答案 + 总结解题套路，同类型的题目即使你题目都看的懵懵懂懂，都有可能蒙出来。

本文章题目都是来源于 https://codetop.cc/home  里面考察频度高的题目，都是面试后人工标记出来的（面试命中率高）。我写这个文章的目的，就是提供一份参考答案，包括代码每行的含义，以及通用的套路。因为一旦理解了，按照自己的方式去记忆会容易很多。
只需要用这个网站作为题目**是否做过**的标记即可（因为笔记功能要收费），自己的答案直接保存在力扣官方刷题网站上

![](./images/20241212172641.png)



# 解题套路

解题套路可以先简单看下，当遇到相关的题目，可以回来再细细品味。建议还是先直接刷题。

## 二分搜索算法

在有序数组`nuns`中搜索 `target` 并返回索引，如果没有搜索到返回`-1`。

![image-20241231181002616](./images/image-20241231181002616.png)

比如我们要搜索 `target = 4`此时`left = 0 right = 5` 计算得到的`mid = 2`

由图可知，`target > nums[2]`位于索引`mid=2`的右侧位置，说明`[1,2,3]`数据没有再搜索的必要（相当于切掉了一半的搜索数据量），只需要继续搜索 `[mid+1:right]`范围内的数据即可。也就是让 `left = mid+1`即 `left= 3 right = 5`，继续进行搜索的过程，直到找到数据或越界。

二分搜索算法的好处，在于每一次`for`循环搜索，可以剔除一半的数据量，让算法更快的趋近于目标值。

一般题目要求算法的时间复杂度`O(log2)`就要想到[二分搜索算法](https://leetcode.cn/problems/binary-search/)

```java
public int search(int[] nums, int target) {
    // 初始化左右指针，分别指向数组的首尾
    int left = 0, right = nums.length - 1;

    // 当左指针小于等于右指针时，继续查找
    while(left <= right) {
        // 计算中间索引，使用left + (right - left) / 2而不是(left + right) / 2
        // 是为了防止整数溢出
        int mid = left + (right - left) / 2;

        // 如果中间元素大于目标值，说明目标值在左半部分
        if(nums[mid] > target) {
            right = mid - 1; // 缩小右边界
        } 
        // 如果中间元素小于目标值，说明目标值在右半部分
        else if (nums[mid] < target) {
            left = mid + 1; // 扩大左边界
        } 
        // 如果中间元素等于目标值，直接返回索引
        else {
            return mid;
        }
    }

    // 如果循环结束还没有找到目标值，返回-1
    return -1;
}
```



## 二叉树遍历套路

```java
// 前序遍历 (Pre-order traversal)
func preOrder(root *TreeNode) {
    if root == nil {
        return
    }
    
    fmt.Println(root.Val)
    
    preOrder(root.Left)
    preOrder(root.Right)
}

// 中序遍历 (In-order traversal)
func inOrder(root *TreeNode) {
    if root == nil {
        return
    }
    
    inOrder(root.Left)
    fmt.Println(root.Val)
    inOrder(root.Right)
}

// 后序遍历 (Post-order traversal)
func postOrder(root *TreeNode) {
    if root == nil {
        return
    }
    
    postOrder(root.Left)
    postOrder(root.Right)
    fmt.Println(root.Val)
}
```



## 滑动窗口解题套路

- 定义 `left right := 0,0` 指向起始位置 `0`
- 让 `right`不断的右移，当遇到不符合题意的条件`condition`，停止移动 `right`
- 然后开始让`left`不断右移，直到条件`condition`得到满足，继续重复👆的步骤，右移`right`
- 当 `right`越界，全部结束

动态规划套路伪代码

```java
public class Main {
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4, 5, 6};
        
        //1. 定义 `left right := 0,0` 指向起始位置 `0`
        int left = 0, right = 0;
        
        // right 越界结束
        while (right < nums.length) {
            
            // 2.不断移动 right
            int val = nums[right];
            right++; 
            
            // do something.....
            
            // 3.当 condition 不符合题意的时候，移动 left，直到满足题意，跳出 condition
            while (condition) {
                int val = nums[left];
                left++;
            }
            
            //.......
        }
    }
}
```

滑动窗口解题套路主要流程是包括

- `left right`的定义 
-  `condition`条件的选取（这个要结合题意）
- 以及两个`for`循环



## 动态规划解题套路

动态规划难点就是在于递推关系的发现，这个只能从具体的题目中来感受。如果说理解+ 背诵题目的话，其实动态规划的题目又是最容易记忆和理解的

- 明确`dp`数组的定义
- 明确 `dp[i]`和 `dp[i-1]`之间递推关系的定义(这个是动态规划的难点，其实说白了，就是要根据题意，找`dp[i]`和 `dp[i-1]`的关系 )，形式上看起来和高中学过的函数推到关系是一摸一样的，比如 `f(x) = f(x-1) + f(x-2)`

在实现代码的时候包括三个方面：

- 创建`dp`数组
- 初始化`dp`数组（需要特殊处理的值）
- 遍历 `nums`数组，实现一般性的递推关系

伪代码

```java
public class Main {
    public static void main(String[] args) {
        int[] nums = {1, 2, 3, 4};
        
        //1.定义 dp 数组
        int[] dp = new int[nums.length];
        
        //2. 初始化 dp 数组（根据题目要求也可能不需要这一步骤）
        for (int k = 0; k < dp.length; k++) {
            dp[k] = 1;
        }
        
        //3. 遍历 `nums`数组，实现一般性的递推关系
        for (int i = 1; i < nums.length; i++) {  // 从 i=1 开始，避免访问 dp[-1]
            dp[i] = dp[i - 1] + 1; // 比如：这里的递推关系为：前一个的 dp[i-1]的基础上，加1
        }
        
        //......
    }
}
```

有一道动态规划最简单的入门题目[509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number)可以来体会下上面说的套路

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

> F(0) = 0
>
> F(1) = 1
>
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

思路：

- `dp`定义： 在 `i`位置的数字和 `dp[i]`
- `dp`递推关系：每一项数字都是前面两项数字的和，所以有 `dp[i] = dp[i-1] + dp[i-2]`

其实，题目已经直接给出了 递推关系 `F(n) = F(n-1)+F(n-2)`，但是大部分的题目是不会给出，需要我们结合题目自己是思考这个递推关系。

```java
class Solution {
    public int fib(int n) {
        if(n <= 1) return n;
        int[] dp = new int[n+1];
        dp[0] = 0;
        dp[1] = 1;
        for(int index = 2; index <= n; index++) {
            dp[index] = dp[index - 1] + dp[index - 2];
        }
        return dp[n];
    }
}
```



## 回溯算法代码套路

回溯算法：每一层选择一个元素，剩下的元素留给下一层选择，一层一层的进行选择，直到将所有的情况遍历完成



打个比方：

有 A B C 三个苹果，有小明和小王 2个同学，各选择一个苹果。

- 如果小明先选择 A 苹果，那么小王只能选择B 或者 C 苹果；
- 如果小明选择 B 苹果，那么小王只能选择 A 或者 C 苹果；
- 如果小明选择 C 苹果，那么小王只能选择 A 或者 B 苹果。

可以看到，小明在选中一个苹果后，小王只能在剩下的苹果中选择一个留给自己（因为另一个已经被小明占用了）



回溯算法，就是在穷尽所有的情况，在 `backtrack`的 `for`循环中选中一个元素，剩下的的元素（通过 `start`来圈定）就留给 下一个 `backtrack`函数进行选择。

`start`不是必须的，有些题目可能需要在全部里面选择（比如，小明先选择 A 苹果，那么小王可以 选择A 或者 B 或者 C 苹果），有些需要在 `start`圈定的范围内选择（小明先选择 A 苹果，那么小王只能选择B 或者 C 苹果）

通用代码格式如下：

```java
/**
 * 回溯函数
 * @param nums 数组
 * @param start 遍历数组的起始位置（这个要根据题意，有时不需要）
 * @param trace 记录回溯的结果
 */
public static void backtrack(int[] nums, int start, List<Integer> trace) {
    // 结束条件
    if (condition) { // 这里的 condition 需要根据具体问题定义
        return;
    }

    for (int i = start; i < nums.length; i++) {
        // 当前选择
        trace.add(nums[i]);

        // 继续下一轮的回溯
        backtrack(nums, i + 1, trace);

        // 撤销当前选择
        trace.remove(trace.size() - 1);
    }
}
```

`start`用来限定每次 `backtrace`函数，能选择的元素范围

`trace = append(trace,nums[i])`在当前层选中元素`nums[i]`，剩下的元素留给下层的回溯`backtrack`选择

![image-20241217163642574](./images/image-20241217163642574.png)



# CodeTop参考答案



## [3.无重复字符的最长字串 （滑动窗口）](https://leetcode.cn/problems/longest-substring-without-repeating-characters/description/)

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度

```
示例1
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

思路：

- **滑动窗口核心思想**：维护一个`[left, right]`的窗口，保证窗口内字符不重复。当遇到重复字符时，移动`left`缩小窗口，直到窗口内无重复。
- **高效去重判断**：使用`boolean[128]`数组记录字符是否在当前窗口中出现过（ASCII字符全覆盖），时间复杂度O(1)。
- **动态更新结果**：每次右移`right`后，计算当前窗口长度`right - left + 1`，并更新最大值`ans`。

```java
class Solution {
    public int lengthOfLongestSubstring(String S) {
        boolean[] has = new boolean[128];
        int left = 0;
        int ans = 0;
        char[] s = S.toCharArray();
        for(int right = 0; right < s.length; right++) {
            while(has[s[right]]) {
                has[s[left]] = false;
                left++;
            }
            has[s[right]] = true;
            ans = Math.max(ans, right - left + 1);
        }
        return ans;
    }
}
```



## [146. LRU缓存](https://leetcode.cn/problems/lru-cache/)

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

思路：

- **LRU核心机制**：通过双向链表维护访问顺序（最近访问的节点在头部，最久未访问的在尾部），结合`HashMap`实现O(1)时间复杂度的`get`和`put`操作。
- **缓存淘汰策略**：当容量满时，直接删除链表尾部的节点（最久未使用），并同步更新`HashMap`。
- **访问更新逻辑**：每次`get`或`put`时
  - 若节点存在则将其移动到链表头部（标记为最近使用）
  - 否则创建新节点并插入头部，超容量时再淘汰尾部节点。


```java
class LRUCache {
    private static class Node {
        int key, value;
        Node prev, next;

        Node(int k, int v) {
            key = k;
            value = v;
        }
    } 

    private final int capacity;
    private final Node dummy = new Node(0, 0);
    private final Map<Integer, Node> keyToNode = new HashMap<>();

    public LRUCache(int capacity) {
        this.capacity = capacity;
        dummy.prev = dummy;
        dummy.next = dummy;
    }

    private void remove(Node node) {
        node.next.prev = node.prev;
        node.prev.next = node.next;
    }

    private void pushFront(Node node) {
        node.prev = dummy;
        node.next = dummy.next;
        node.prev.next = node;
        node.next.prev = node;
    }

    private Node getNode(int key) {
        if(!keyToNode.containsKey(key)) {
            return null;
        }
        Node node = keyToNode.get(key);
        remove(node);
        pushFront(node);
        return node;
    }
    
    public int get(int key) {
        Node node = getNode(key);
        return node != null ? node.value : -1;
    }
    
    public void put(int key, int value) {
        Node node = getNode(key);
        if(node != null) {
            node.value = value;
            return;
        }

        node = new Node(key, value);
        keyToNode.put(key, node);
        pushFront(node);
        if(keyToNode.size() > capacity) {
            Node backNode = dummy.prev;
            keyToNode.remove(backNode.key);
            remove(backNode);
        }
    }
}
```



## [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![image-20241214163002911](./images/image-20241214163002911.png)

思路：

- **迭代反转链表**：使用双指针`cur`和`pre`，逐个反转节点的`next`指针方向，直到遍历完整个链表。
- **关键步骤**：每次迭代中，先用`temp`保存`cur.next`，再反转`cur.next`指向`pre`，最后移动`pre`和`cur`指针。
- **终止条件**：当`cur`为`null`时，`pre`即为反转后的新头节点。

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode cur = head, pre = null;
        while(cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur =temp;
        }
        return pre;
    }
}
```

![image-20241214165538983](./images/image-20241214165538983.png)



## [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

给定整数数组 `nums` 和整数 `k`，请返回数组中第  `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```
示例 1:

输入: [3,2,1,5,6,4], k = 2
输出: 5

```

思路：

- **堆排序思想**：利用最大堆（大顶堆）的性质，每次取出堆顶元素（当前最大值），逐步缩小堆的范围，最终得到第k大的元素。
- **构建最大堆**：从最后一个非叶子节点开始，自底向上调整堆结构，确保每个父节点都大于其子节点。
- **逐步提取元素**：依次将堆顶元素与末尾元素交换，缩小堆的范围后重新调整堆，重复k次后堆顶即为第k大的元素。

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        int heapSize = nums.length;
        build(nums, heapSize);
        for(int i = nums.length - 1; i >= nums.length - k + 1; i--) {
            swap(nums, 0, i );
            heapSize--;
            maxHeap(nums, 0, heapSize);
        }
        return nums[0];
    }

    private void build(int[] nums, int heapSize) {
        for(int i = heapSize / 2 - 1; i >= 0; i--) {
            maxHeap(nums, i, heapSize);
        }
    }

    private void maxHeap(int[] nums, int i, int heapSize) {
        int left = i * 2 + 1, right = i * 2 + 2, largest = i;
        if(left < heapSize && nums[left] > nums[largest]) {
            largest = left;
        }
        if(right < heapSize && nums[right] > nums[largest]) {
            largest = right;
        }
        if(i != largest) {
            swap(nums, largest, i);
            maxHeap(nums, largest, heapSize);
        }
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

下图表示演示了， 数组 `2 1 3` 求第 1 大元素的过程

![image-20241214183809449](./images/image-20241214183809449.png)



## [25. K个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group)

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

思路：

- 按照 长度k截取一段链表，然后将这段链表进行反转。【反转前的链表的头节点，变成了反转后的链表的尾部节点】
- **分组反转链表**：先统计链表长度，然后按每k个节点为一组进行反转，不足k个的组保持原序。
- **迭代反转过程**：对每组节点使用头插法反转，通过临时变量保存后续节点，确保分组间正确连接。
- **虚拟头节点辅助**：使用dummy节点简化边界条件处理，p0指针跟踪已处理部分的末尾，便于连接下一组反转后的头节点。

![image-20241215164514723](./images/image-20241215164514723.png)

```java
class Solution {
    public ListNode reverseKGroup(ListNode head, int k) {
        int cnt = 0;
        for(ListNode cur = head; cur != null; cur = cur.next) cnt++;

        ListNode dummy = new ListNode(0, head);
        ListNode p0 = dummy;
        ListNode pre = null;
        ListNode cur = head;

        for(; cnt >= k; cnt -= k) {
            for(int i = 0; i < k; i++) {
                ListNode temp = cur.next;
                cur.next = pre;
                pre = cur;
                cur = temp;
            }

            ListNode next = p0.next;
            p0.next.next = cur;
            p0.next = pre;
            p0 = next;
        }
        return dummy.next;
    }
}
```



## [15. 三数之和](https://leetcode.cn/problems/3sum)

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

思路：

- **排序+双指针法**：先对数组排序，固定一个数后，用双指针在剩余部分寻找两数之和等于目标值（当前数的相反数）。
- **剪枝优化**：跳过重复元素避免重复解；当最小三数和已大于0或最大三数和小于0时提前终止循环。
- **去重处理**：找到有效解后，跳过所有与当前解中相同值的元素，确保结果唯一性。

![image-20241215171006692](./images/image-20241215171006692.png)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        Arrays.sort(nums);
        int n = nums.length;
        List<List<Integer>> ans = new ArrayList<>();
        for (int i = 0; i < n - 2; i++) {
            int x = nums[i];
            if(i > 0 && x == nums[i-1]) continue;
            if(x + nums[i+1] + nums[i+2] > 0) break;
            if(x + nums[n-1] + nums[n-2] < 0) continue;
            int j = i + 1;
            int k = n - 1;
            while(j < k) {
                int sum = x + nums[j] + nums[k];
                if(sum < 0) {
                    j++;
                } else if(sum > 0){
                    k--;
                } else {
                    ans.add(List.of(x, nums[j], nums[k]));
                    for(j++; j < k && nums[j] == nums[j-1]; j++);
                    for(k--; j < k && nums[k] == nums[k+1]; k--);
                }
            }
        }
        return ans;
    }
}
```



## [53. 最大子数组和](https://leetcode.cn/problems/maximum-subarray/)

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**：是数组中的一个连续部分。

思路：

- **动态规划优化**：使用`f`记录以当前元素结尾的最大子数组和，状态转移方程为`f = max(f, 0) + x`，表示要么延续之前的，要么重新开始。

- **贪心思想**：每次计算`f`时，如果之前的和为负则舍弃（置为0），只保留当前元素或延续。
- **全局最大值**：在遍历过程中维护`ans`记录全局最大值，最终返回`ans`作为结果。

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int ans = Integer.MIN_VALUE;
        int f = 0;
        for(int x : nums) {
            f = Math.max(f, 0) + x;
            ans = Math.max(ans, f);
        }
        return ans;
    }
}
```



## [912. 排序数组](https://leetcode.cn/problems/sort-an-array)

给你一个整数数组 `nums`，请你将该数组升序排列。你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。

思路：

这里提供必考的**3种排序算法（快速，堆，冒泡）**

> 快速排序

**快速排序是先将一个元素排好序，然后再将剩下的元素排好序**。

```java
class Solution {
    public int[] sortArray(int[] nums) {
        quickSort(nums, 0, nums.length - 1);
        return nums;
    }
    
    private void quickSort(int[] nums, int left, int right) {
        if (left >= right) return;
        
        int pivotIndex = partition(nums, left, right);
        quickSort(nums, left, pivotIndex - 1);
        quickSort(nums, pivotIndex + 1, right);
    }
    
    private int partition(int[] nums, int left, int right) {
        // 选择最右边的元素作为基准值
        int pivot = nums[right];
        int i = left;
        
        for (int j = left; j < right; j++) {
            if (nums[j] < pivot) {
                swap(nums, i, j);
                i++;
            }
        }
        
        // 将基准值放到正确的位置
        swap(nums, i, right);
        return i;
    }
    
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```

![image-20241216102101741](./images/image-20241216102101741.png)

> 堆排序

利用的下沉操作sink，将数组最大元素移动到数组首部，然后和尾部元素交换（尾部元素就不用再管了，因为已经有序了）此时尾部就是最大的值；然后对剩下的数组元素进行下沉操作；保证次大的元素，成为新的首部元素；继续和尾部交换（注意这里的尾部不是最后一个，是倒数第二个了）

![image-20241216112926897](./images/image-20241216112926897.png)

```java
class Solution {
    public int[] sortArray(int[] nums) {
        int n = nums.length;

        // 构建最大堆
        for (int i = n / 2 - 1; i >= 0; i--) {
            heapify(nums, n, i);
        }

        // 排序
        for (int i = n - 1; i > 0; i--) {
            // 将当前堆顶元素（最大值）与最后一个元素交换
            swap(nums, 0, i);
            // 对剩余的堆进行堆化
            heapify(nums, i, 0);
        }

        return nums;
    }

    // 堆化函数：确保以i为根的子树满足最大堆性质
    private void heapify(int[] nums, int n, int i) {
        int largest = i; // 初始化最大值为根节点
        int left = 2 * i + 1; // 左子节点
        int right = 2 * i + 2; // 右子节点

        // 如果左子节点大于根节点
        if (left < n && nums[left] > nums[largest]) {
            largest = left;
        }

        // 如果右子节点大于当前最大值
        if (right < n && nums[right] > nums[largest]) {
            largest = right;
        }

        // 如果最大值不是根节点
        if (largest != i) {
            swap(nums, i, largest);
            // 递归地对受影响的子树进行堆化
            heapify(nums, n, largest);
        }
    }

    // 交换数组中两个元素的位置
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}

```

![image-20241216111613587](./images/image-20241216111613587.png)

> 冒泡排序

重复地遍历数组，每次比较相邻的两个元素，如果顺序错误就交换它们，这样每一轮遍历都能把当前未排序部分的最大元素"冒泡"到正确位置。简单直观但效率较低（O(n²)时间复杂度），适合小规模数据排序，是稳定的排序算法（相等元素不会改变相对位置）。

```java
public int[] sortArray(int[] nums) {
    int n = nums.length;
    for (int i = 0; i < n - 1; i++) {
        boolean swapped = false;  // 优化：增加交换标志位
        for (int j = 0; j < n - i - 1; j++) {
            if (nums[j] > nums[j + 1]) {
                // 交换相邻元素
                int temp = nums[j];
                nums[j] = nums[j + 1];
                nums[j + 1] = temp;
                swapped = true;
            }
        }
        // 如果某一轮没有发生交换，说明已经有序，提前退出
        if (!swapped) break;
    }
    return nums;
}
```





## [21.合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/)

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

![image-20241216125835417](./images/image-20241216125835417.png)

思路：

- **分治递归**：比较两链表头节点，取较小者作为当前节点，并递归合并其后续节点与另一链表。
- **终止条件**：任一链表为空时直接返回另一链表。
- **自顶向下构建**：每次递归处理当前最小节点，逐步拼接成完整有序链表。

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if(list1 == null) return list2;
        if(list2 == null) return list1;
        if(list1.val < list2.val) {
            list1.next = mergeTwoLists(list1.next, list2);
            return list1;
        } else {
            list2.next = mergeTwoLists(list1, list2.next);
            return list2;
        }
    }
}
```



## [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

思路：

**寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串**

```java
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    更新答案
```

找回文串的关键技巧是传入两个指针 `l` 和 `r` 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。

```java
for 0 <= i < len(s):
    // 找到以 s[i] 为中心的回文串
    palindrome(s, i, i)
    // 找到以 s[i] 和 s[i+1] 为中心的回文串
    palindrome(s, i, i + 1)
    更新答案
```

- **中心扩展法**：以每个字符（奇数长度）或每对相邻字符（偶数长度）为中心，向两边扩展寻找最长回文子串。
- **动态记录边界**：维护`start`和`end`记录当前最长回文的起止位置，每次扩展后更新这两个边界。
- **双中心处理**：分别处理奇数长度（`center(i,i)`）和偶数长度（`center(i,i+1)`）的回文情况，取较大值进行更新。

```java
class Solution {
    public String longestPalindrome(String s) {
        int start = 0, end = 0;
        for (int i = 0; i < s.length(); i++) {
            int len1 = center(s, i, i);
            int len2 = center(s, i, i + 1);
            int len = Math.max(len1, len2);
            if(len > end - start) {
                start = i - (len - 1) /2;
                end = i + len / 2;
            }
        }
        return s.substring(start, end+1);
    }

    private int center(String s, int left, int right) {
        while(left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {
            left--;
            right++;
        }
        return right - left - 1;
    }
}
```



## [102. 二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![image-20241216131328055](./images/image-20241216131328055.png)

思路：

- **BFS层次遍历**：使用队列按层访问二叉树节点，每次处理完一层后将该层节点值存入结果列表。
- **队列控制层数**：通过记录当前队列大小`len`来确定当前层的节点数量，确保逐层处理。
- **子节点入队**：访问当前节点时，将其左右子节点（若存在）加入队列，为下一层遍历做准备。

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        if(root == null) return List.of();
        List<List<Integer>> ans = new ArrayList<>();
        Deque<TreeNode> q = new ArrayDeque<>();
        q.add(root);
        while(!q.isEmpty()) {
            int len = q.size();
            List<Integer> path = new ArrayList<>();
            while(len-- > 0) {
                TreeNode node = q.poll();
                path.add(node.val);
                if(node.left != null) q.add(node.left);
                if(node.right != null) q.add(node.right);
            }
            ans.add(path);
        }
        return ans;
    }
}
```



## [1.两数之和](https://leetcode.cn/problems/two-sum/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。

思路：

- **哈希表辅助查找**：使用哈希表存储已遍历元素的值和索引，实现O(1)时间复杂度的目标值查找。
- **一次遍历求解**：遍历数组时，检查当前元素所需补数（target - 当前值）是否存在于哈希表中，存在则直接返回结果。
- **空间换时间**：牺牲O(n)空间复杂度，将时间复杂度从暴力法的O(n²)优化到O(n)。

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            if(map.containsKey(target - nums[i])) {
                return new int[]{map.get(target - nums[i]), i};
            }
            map.put(nums[i], i);
        }
        return new int[2];
    }
}
```



## [33.搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/)

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

思路：

- 题目要求时间复杂度`O(log n)` 那就要想到二分法
- **二分查找变种**：针对旋转排序数组，在每次二分时判断哪一半是有序的，再根据目标值是否落在有序区间决定搜索方向。
- **区间判断逻辑**：通过比较中间值与左边界值确定左半区是否有序，再检查目标值是否在左半有序区间内。
- **边界调整策略**：根据目标值位置动态调整左右指针，逐步缩小搜索范围直至找到目标或确定不存在。

![image-20241216151627555](./images/image-20241216151627555.png)

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) return mid;
            if(nums[mid] >= nums[left]) {
                if(target >= nums[left] && target < nums[mid]) {
                    right = mid - 1;
                } else {
                    left = mid + 1;
                }
            } else {
                if(target > nums[mid] && target <= nums[right]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```



## [200.岛屿数量](https://leetcode.cn/problems/number-of-islands)

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

思路：

- 用 DFS 算法解决岛屿题目是最常见的，每次遇到一个岛屿中的陆地，就用 DFS 算法吧这个岛屿「淹掉」。
- **深度优先搜索（DFS）**：遍历网格时，遇到陆地（'1'）就启动DFS，将相连的所有陆地标记为已访问（如'2'），避免重复计数。
- **岛屿计数逻辑**：每次启动DFS都意味着发现了一个新的岛屿，因此计数器`ans`递增。
- **边界与有效性检查**：DFS过程中检查坐标是否越界以及当前格子是否为未访问的陆地，确保搜索的正确性和安全性。

```java
class Solution {
    public int numIslands(char[][] grid) {
        int ans = 0;
        for (int i = 0; i < grid.length; i++) {
            for (int j = 0; j < grid[0].length; j++) {
                if(grid[i][j] == '1') {
                    dfs(grid, i, j);
                    ans++;
                }
            }
        }
        return ans;
    }

    private void dfs(char[][] grid, int i, int j) {
        if(i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] != '1') return;

        grid[i][j] = '2';
        dfs(grid, i + 1, j);
        dfs(grid, i - 1, j);
        dfs(grid, i, j + 1);
        dfs(grid, i, j - 1);
    }
}
```





## [46.全排列](https://leetcode.cn/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```
示例1:
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

思路：

- 可以参考下👆回溯算法解题模板
- **回溯算法**：通过交换元素位置生成所有可能的排列，利用递归回溯探索所有排列组合。
- **路径维护**：使用`path`列表动态维护当前排列状态，在递归过程中不断交换元素位置生成新排列。
- **终止条件**：当`first`等于数组长度时，表示当前`path`已构成一个完整排列，将其加入结果集`ans`。

```java
class Solution {

    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> permute(int[] nums) {
        for(int x : nums) path.add(x);
        dfs(nums.length, 0);
        return ans;
    }

    private void dfs(int n, int first) {
        if(first == n) ans.add(new ArrayList<>(path));
        for(int i = first; i < n; i++) {
            Collections.swap(path, first, i);
            dfs(n, first + 1);
            Collections.swap(path, first, i);
        }
    }
}
```





## [88.合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

思路：

- 很像前文中讲过的 [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)，这里让你合并两个有序数组。

- 对于单链表来说，我们直接用双指针从头开始合并即可，但对于数组来说会出问题。因为题目让我直接把结果存到 `nums1` 中，而 `nums1` 的开头有元素，如果我们无脑复制单链表的逻辑，会覆盖掉 `nums1` 的原始元素，导致错误。但 `nums1` 后面是空的呀，所以这道题需要我们稍微变通一下：**将双指针初始化在数组的尾部，然后从后向前进行合并**，这样即便覆盖了 `nums1` 中的元素，这些元素也必然早就被用过了，不会影响答案的正确性。

  

- **逆向双指针合并**：从两个数组的末尾开始比较，将较大的元素依次放入nums1的末尾，避免覆盖未处理的元素。

- **原地修改**：直接在nums1数组上进行操作，无需额外空间，利用nums1末尾的空闲位置存储合并结果。

- **终止条件**：当nums2的所有元素都被处理完毕（p2 < 0）时，合并完成，此时nums1的前m+n个元素即为最终结果。

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int p1 = m - 1;
        int p2 = n - 1;
        int p = m + n - 1;
        while(p2 >= 0) {
            if(p1 >= 0 && nums1[p1] > nums2[p2]) {
                nums1[p--] = nums1[p1--];
            } else {
                nums1[p--] = nums2[p2--];
            }
        }
    }
}
```





## [20.有效的括号](https://leetcode.cn/problems/valid-parentheses/)

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

思路：

- 栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。

- 假设字符串中只有圆括号 **（）**，如果想让括号字符串有效，那么必须做到：

  **每个右括号 `)` 的左边必须有一个左括号 `(` 和它匹配**。

  比如说字符串 `()))((` 中，中间的两个右括号**左边**就没有左括号匹配，所以这个括号组合是无效的。

- 利用栈，保证完成匹配的括号，不会存在在栈中，最后栈中剩下的就是没有完成匹配的；


```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> deque = new LinkedList<>();
        for(int i = 0; i < s.length(); i++) {
            char ch = s.charAt(i);
            if(ch == '(') {
                deque.push(')');
            } else if(ch == '{') {
                deque.push('}');
            } else if(ch == '[') {
                deque.push(']');
            } else if(deque.isEmpty() || deque.peek() != ch) {
                return false;
            } else {
                deque.pop();
            }
        }
        return deque.isEmpty();
    }
}
```



## [121.买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

思路：

买卖股票类的题目有一套**通用的解题方案**：

- `dp`数组定义：

> `dp[i][k][0 or 1]` 
>
> `0 <= i <= n - 1, 1 <= k <= K`      
>
>   n 为天数，大 K 为完成交易数的上限，0 和 1 代表是否持有股票

所以，`dp[i][k][0 or 1]` 的含义就是：在从 `0`到 `i`天，完成了`k`笔交易，不持有`0` or 持有 `1`股票，能获取的最大利润

- `dp`的递推关系定义：

```java

dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
//dp[i][k][0] 表示 从 0 到 第i天，完成k笔交易，不持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][0] 								表示 从 0 到i-1天（也就是前一天），也没有持有股票
// dp[i-1][k][1] + prices[i]  	表示 从 0 到i-1天（也就是前一天），持有了股票，但是今天选择卖出，那么今天不就不持有股票了


dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
// dp[i][k][1]  表示从 0 到第i天，完成k笔交易，持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][1] 							 	表示从 0 到 i-1天（也就是前一天），也持有股票
// dp[i-1][k-1][0] - prices[i] 	表示从 0 到 i-1天（也就是前一天），未持有了股票，但是今天选择买入，那么不就持有股票了。因为是今天买入股票，完成了一笔交易，今天的交易次数是k的前提下，那么前一天的交易次数就是 k-1


最终答案：因为要求最大利润，那只有不持有股票的利润最大 dp[n-1][k][0] （从 0到 n-1，完成了k笔交易后，不持有股票）
```

本题答案：

注意理解这句话的含义：【你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票】，意思就是只进行一次交易，能获取的最大利润是多少。（不需要考虑之前的历史交易行为，因为只有一次交易，那也就是没有其他的历史交易行为）

- 对于上面的`dp`递推模板，可以省略 `k`，因为只有一次交易
- `dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])`对于这个递推关系，我们需要去掉`dp[i-1][k-1][0]`，将递推关系变为：`dp[i][k][1] = max(dp[i-1][k][1],  - prices[i])`，因为带上`dp[i-1][k-1][0]`就表示要考虑之前的历史交易行为。如果想不明白为什么，先理解下`dp`的定义：表示从 0 到 i-1天（也就是前一天），未持有了股票（为啥没有持有股票？可能是因为本来就没有持有过，也可能是之前持有了，到了第`i-1`天卖掉了，等价于没有持有了），如果是第二种卖掉了，导致的没有持有，说明之前有过历史的交易行为。那就不能算是题目限定的，只能有一次交易行为了。

```java
// 这里比较简单，我就直接记录 从 cost 和 profit 了
class Solution {
    public int maxProfit(int[] prices) {
        int cost = Integer.MAX_VALUE, profit = 0;
        for (int price : prices) {
            cost = Math.min(cost, price);
            profit = Math.max(profit, price - cost);
        }
        return profit;
    }
}
```





## [103.二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

思路：

- **BFS遍历**：使用队列按层遍历二叉树，每次处理一层的所有节点。
- **方向交替**：通过检查当前层数的奇偶性决定是否反转当前层的节点值列表（奇数层反转，偶数层保持原序）。

```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        if(root == null) return List.of();
        List<List<Integer>> ans = new ArrayList<>();
        Deque<TreeNode> q = new ArrayDeque<>();
        q.add(root);
        while (!q.isEmpty()) {
            int len = q.size();
            List<Integer> path = new ArrayList<>(len);
            while (len-- > 0) {
                TreeNode node = q.poll();
                path.add(node.val);
                if(node.left != null) q.add(node.left);
                if(node.right != null) q.add(node.right);
            }
            if(ans.size() % 2 == 1) Collections.reverse(path);
            ans.add(path);
        }
        return ans;
    }
}
```





## [235.二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

思路：

- 给出递归函数的定义：给该函数输入三个参数 `root`，`p`，`q`，它会返回一个节点：
- 情况 1，如果 `p` 和 `q` 都在以 `root` 为根的树中，那么 `left` 和 `right` 一定分别是 `p` 和 `q`。
- 情况 2，如果 `p` 和 `q` 都不在以 `root` 为根的树中，直接返回 `null`。
- 情况 3，如果 `p` 和 `q` 只有一个存在于 `root` 为根的树中，函数返回该节点。

![image-20241217191330565](./images/image-20241217191330565.png)

```java
class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null || root == p || root == q) return root;

        TreeNode left = lowestCommonAncestor(root.left, p, q);
        TreeNode right = lowestCommonAncestor(root.right, p, q);
        if(left == null) return right;
        if(right == null) return left;
        return root;
    }
}
```




## [141.环形链表](https://leetcode.cn/problems/linked-list-cycle/)

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

![image-20241217184157384](./images/image-20241217184157384.png)

思路：

- **快慢指针法**：使用两个指针（`slow`和`fast`），`slow`每次移动一步，`fast`每次移动两步。
- **环检测**：如果链表存在环，`fast`最终会追上`slow`（即`slow == fast`），返回`true`；否则`fast`会先到达链表末尾，返回`false`。

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) return true;
        }
        return false;
    }
}
```




## [92.反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

![image-20241218153607707](./images/image-20241218153607707.png)

思路：

- 递归解法：

  迭代解法很简单，用一个 for 循环即可，但这道题经常用来考察递归思维，让你用纯递归的形式来解决。

  要想真正理解递归操作链表的代码思路，关键点还是要明确递归函数的定义，推导出递归翻转前 `N` 个节点的算法，最后改写出递归翻转区间内的节点的解法代码

  

  ```java
  class Solution {
      private ListNode nextNode = null;
  
      public ListNode reverseBetween(ListNode head, int left, int right) {
          if (left == 1) {
              return reverseN(head, right);
          }
          head.next = reverseBetween(head.next, left - 1, right - 1);
          return head;
      }
  
      private ListNode reverseN(ListNode head, int n) {
          if (n == 1) {
              nextNode = head.next; // 保存反转部分之后的链表
              return head;
          }
          ListNode last = reverseN(head.next, n - 1);
          head.next.next = head;
          head.next = nextNode; // 连接剩余部分
          return last;
      }
  }
  ```

  ![image-20241218170704572](./images/image-20241218170704572.png)

- 迭代解法：

  > dummy 定义虚拟节点
  >
  > 遍历整个链表，cur指向正在访问的节点，i 记录指向的节点是第几个。如果cur指向的节点不是要反转的节点，不断的追加到p.Next同时p也不断的移动
  >
  > 如果cur指向的节点是要反转的节点，不断的追加到p.Next同时p 不移动
  >
  > leftNode 用来记录第一个反转的节点（因为反转后，第一个节点，变成反转后的最后一个节点），如上中的节点2，变成反转后最后一个节点

![image-20241218164408974](./images/image-20241218164408974.png)

```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode(0, head);
        ListNode p0 = dummy;
        for (int i = 0; i < left - 1; i++) p0 = p0.next;

        ListNode cur = p0.next, pre = null;
        for (int i = 0; i < right - left + 1; i++) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }

        p0.next.next = cur;
        p0.next = pre;
        return dummy.next;
    }
}

```





## [54.螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

![image-20241218172519569](./images/image-20241218172519569.png)

思路：

- **边界控制**：使用四个指针（`top`, `bottom`, `left`, `right`）动态缩小遍历范围，每次完成一行或一列后调整对应边界。
- **方向顺序**：按“右→下→左→上”的固定螺旋顺序遍历，每次完成一个方向后检查边界是否越界，若越界则终止循环。

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> ans = new ArrayList<>();
        int top = 0, bottom = matrix.length - 1, left = 0, right = matrix[0].length - 1;
        while(true) {
            for(int i = left; i <= right; i++) ans.add(matrix[top][i]);
            if(++top > bottom) break;

            for(int i = top; i <= bottom; i++) ans.add(matrix[i][right]);
            if(--right < left) break;

            for(int i = right; i >= left; i--) ans.add(matrix[bottom][i]);
            if(--bottom < top) break;

            for(int i = bottom; i >= top; i--) ans.add(matrix[i][left]);
            if(++left > right) break;
        }
        return ans;
    }
}
```



## [300.最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence)

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列

思路：

- **动态维护递增子序列**：使用数组 `dp` 动态记录当前找到的最长递增子序列的末尾元素，`len` 表示当前子序列的长度。

- **二分查找优化插入位置**：对于每个新元素 `nums[i]`，通过二分查找在 `dp` 中找到第一个不小于它的位置 `idx`，替换该位置的值以保持 `dp` 的递增性。
- **动态扩展子序列长度**：如果 `idx` 等于当前长度 `len`，说明找到了更长的子序列，直接扩展 `len`。

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int[] dp = new int[nums.length];
        int len = 0;
        for(int i = 0; i < nums.length; i++) {
            int idx = findTarget(dp, len, nums[i]);
            dp[idx] = nums[i];

            if(idx == len) len++;
        }
        return len;
    }

    private int findTarget(int[] dp, int len, int target) {
        int left = 0, right = len - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(dp[mid] >= target) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        return left;
    }
}
```





## [23.合并K个升序链表](https://leetcode.cn/problems/merge-k-sorted-lists/)

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

思路：

- **分治合并策略**：将 `k` 个链表两两合并，逐步减少链表数量，直到只剩一个链表。
- **递归合并两个链表**：`merge2List` 方法递归地比较两个链表的节点值，按升序合并。
- **迭代优化合并过程**：通过循环和索引 `idx` 控制合并轮次，避免重复创建新数组，提升效率。

```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        if(lists.length < 1) return null;
        int len = lists.length;
        while(len > 1) {
            int idx = 0;
            for (int i = 0; i < len; i+=2) {
                if(i == len - 1) {
                    lists[idx++] = lists[i];
                    break;
                }

                lists[idx++] = merge2List(lists[i], lists[i + 1]);
            }
            len = idx;
        }
        return lists[0];
    }

    private ListNode merge2List(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        if(l1.val < l2.val) {
            l1.next = merge2List(l1.next, l2);
            return l1;
        } else {
            l2.next = merge2List(l1, l2.next);
            return l2;
        }
    }
}
```



## [143.重排链表](https://leetcode.cn/problems/reorder-list/)

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

思路：

- **快慢指针找中点**：使用快慢指针定位链表中点，将链表分为前后两部分。
- **反转后半部分链表**：将后半部分链表反转，便于后续交叉合并。
- **交叉合并链表**：交替连接前半部分和反转后的后半部分节点，完成重排。

```java
class Solution {
    public void reorderList(ListNode head1) {
        ListNode mid = findMid(head1);
        ListNode head2 = reverse(mid);
        while(head2.next != null) {
            ListNode temp1 = head1.next;
            ListNode temp2 = head2.next;
            head1.next = head2;
            head2.next = temp1;
            head1 = temp1;
            head2 = temp2;
        }
    }

    private ListNode findMid(ListNode head) {
        ListNode slow = head, fast = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    private ListNode reverse(ListNode head) {
        ListNode cur = head, pre = null;
        while(cur != null) {
            ListNode temp = cur.next;
            cur.next = pre;
            pre = cur;
            cur = temp;
        }
        return pre;
    }
}
```





## [415.字符串相加](https://leetcode.cn/problems/add-strings/)

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。

思路：

- **从低位到高位逐位相加**：从字符串末尾开始遍历，模拟手工加法过程。
- **处理进位**：计算当前位的和及进位值，将当前位结果存入StringBuilder。
- **反转结果字符串**：由于是从低位开始计算，最后需要反转字符串得到正确结果。

```java
class Solution {
    public String addStrings(String num1, String num2) {
        StringBuilder ans= new StringBuilder();
        int i = num1.length() - 1, j = num2.length() - 1;
        int carry = 0;
        while(i >= 0 || j >= 0) {
            int n1 = i >= 0 ? num1.charAt(i--) - '0' : 0;
            int n2 = j >= 0 ? num2.charAt(j--) - '0' : 0;
            int val = n1 + n2 + carry;
            carry = val / 10;
            ans.append(val % 10);
        }
        if(carry == 1) ans.append(1);
        return ans.reverse().toString();
    }
}
```



## [160.相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回`null`。

图示两个链表在节点 `c1` 开始相交**：**

![image-20241218174907646](./images/image-20241218174907646.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 

思路：

- **解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`。**
- 如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。
- 如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

![image-20241218180856369](./images/image-20241218180856369.png)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode pa = headA, pb = headB;
        while(pa != pb) {
            pa = pa != null ? pa.next : headB;
            pb = pb != null ? pb.next : headA;
        }
        return pa;
    }
}
```




## [56.合并区间](https://leetcode.cn/problems/merge-intervals/)

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start, end]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

思路：

- **按起始点排序**：首先对所有区间按照起始点进行升序排序，确保后续合并操作有序进行。
- **遍历合并区间**：初始化结果列表，遍历每个区间，若当前区间与结果列表最后一个区间重叠，则合并；否则直接加入结果列表。
- **返回结果数组**：将结果列表转换为二维数组并返回。

![image-20241219163052347](./images/image-20241219163052347.png)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, (p, q) -> p[0] - q[0]);
        List<int[]> ans = new ArrayList<>();
        for(int[] p : intervals) {
            int m = ans.size();
            if(m > 0 && ans.get(m-1)[1] >= p[0]) {
                ans.get(m-1)[1] = Math.max(ans.get(m-1)[1], p[1]);
            } else {
                ans.add(p);
            }
        }
        return ans.toArray(new int[ans.size()][]);
    }
}
```



## [42.接雨水](https://leetcode.cn/problems/trapping-rain-water/)

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

思路：

- **双指针法**：使用左右指针分别从数组两端向中间遍历，动态维护左右最大值。
- **比较左右最大值**：每次移动较小最大值对应的指针，计算当前位置可接雨水量（当前最大值 - 当前高度）。
- 对于任意一个位置 `i`，能够装的水为：

```java
water[i] = 		// 左右两边的最高值的最小值 -  height[i]
							min(
  						// 0到i的最高值
  						max(height[0..i]) , 
  						// i 到 end的最高值
  						max(height[i..end])  )   - height[i]
```

![image-20241219165002229](./images/image-20241219165002229.png)

```java
class Solution {
    public int trap(int[] height) {
        int ans = 0;
        int preMax = 0;
        int sufMax = 0;
        int i = 0, j = height.length - 1;
        while(i <= j) {
            preMax = Math.max(preMax, height[i]);
            sufMax = Math.max(sufMax, height[j]);
            if(preMax < sufMax) {
                ans += preMax - height[i++];
            } else {
                ans += sufMax - height[j--];
            }
        }
        return ans;
    }
}
```





## [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

思路：

- 解决两个字符串的动态规划问题，一般都是用两个指针 `i, j` 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模。
- **动态规划表初始化**：创建`(n+1)×(m+1)`的DP表，初始化第一行和第一列为编辑距离（全部插入或删除操作）。
- **状态转移计算**：
  - 字符相等时直接继承左上角值（无需操作）
  - 字符不等时取左/上/左上三个方向的最小值+1（对应插入/删除/替换操作）
- **返回最终结果**：DP表右下角的值即为两个字符串的最小编辑距离。



对于每对字符 `s1[i]` 和 `s2[j]`，可以有四种操作：

```
if s1[i] == s2[j]:
    啥都别做（skip）
    i, j 同时向前移动
else:
    三选一：
        插入（insert）
        删除（delete）
        替换（replace）
```

- `dp`数组定义： `i`和`j`表示字符串长度，`dp[i][j]`表示最小操作数

- 递推关系： `i`和`j`表示字符串长度， `i-1` 和 `j-1`才表示最后一个字符的索引

  ```java
  if word1[i-1] == word2[j-1] {
  	dp[i][j] = dp[i-1][j-1] //不需要操作
  } else {
    dp[i-1][j] // i删除 j不变
    dp[i][j-1] // i不变，在i后面新增一个元素和j相同(也可以理解为 i不变，删除j)
    dp[i-1][j-1] // i和j同时replace为同一个元素
    
    dp[i][j] = min( dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1 )
  }
  ```

代码实现：

```java
class Solution {
    public int minDistance(String word1, String word2) {
        int n = word1.length(), m = word2.length();
        int[][] dp = new int[n+1][m+1];
        for(int i = 0; i <= n; i++) dp[i][0] = i;
        for(int j = 0; j <= m; j++) dp[0][j] = j;

        for(int i = 1; i <= n; i++) {
            for(int j = 1; j <= m; j++) {
                if(word1.charAt(i-1) == word2.charAt(j-1)) {
                    dp[i][j] = dp[i-1][j-1];
                } else {
                    dp[i][j] = Math.min(Math.min(dp[i-1][j], dp[i][j-1]), dp[i-1][j-1]) + 1;
                }
            }
        }
        return dp[n][m];
    }
}
```



## [124. 二叉树中的最大路经和](https://leetcode.cn/problems/binary-tree-maximum-path-sum)

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

思路：

- **后序遍历计算子树贡献**：通过深度优先搜索（DFS）后序遍历二叉树，计算每个节点的左右子树的最大路径和。
- **更新全局最大值**：在遍历过程中，计算当前节点作为路径转折点时的路径和（左+右+当前节点值），并更新全局最大值`ans`。
- **返回单边最大贡献值**：每个节点返回其左右子树中较大的贡献值加上当前节点值（若为负则取0），供父节点计算使用。

![image-20241219183656494](./images/image-20241219183656494.png)

-   但是题目要求的是：【经过root】的最大路径和，注意和上面的区别，一个是从 root出发，题目要求的是经过 root 。

![image-20241219184958506](./images/image-20241219184958506.png)

```java
class Solution {
    private int ans = Integer.MIN_VALUE;

    public int maxPathSum(TreeNode root) {
        dfs(root);
        return ans;
    }

    private int dfs(TreeNode root) {
        if(root == null) return 0;

        int leftMax = dfs(root.left);
        int rightMax = dfs(root.right);
        ans = Math.max(ans, leftMax + rightMax + root.val);
        return Math.max(0, Math.max(leftMax, rightMax) + root.val);
    }
}
```






## [142.环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



![image-20241219165654244](./images/image-20241219165654244.png)

思路：

我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

因为 `fast` 一次跳跃距离为`2` ，`slow` 一次跳跃距离为 `1`

![image-20241219171135336](./images/image-20241219171135336.png)

假设【相遇点】距环【相交点】的距离为 `m`，那么结合下图的 `slow` 指针，环的【相交点】距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从【相遇点】继续前进 `k - m` 步，也恰好到达环【相交点】：

![image-20241219172001832](./images/image-20241219172001832.png)

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode slow = head, fast = head;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;
            if(slow == fast) {
                while (head != fast) {
                    head = head.next;
                    fast = fast.next;
                }
                return head;
            }
        }
        return null;
    }
}
```





## [93.复原IP地址](https://leetcode.cn/problems/restore-ip-addresses/)

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

思路：

- **回溯法生成IP段**：通过深度优先搜索（DFS）递归生成所有可能的IP地址段组合。
- **剪枝优化**：
  - 当剩余字符不足或超过剩余段数时终止搜索
  - 跳过以0开头且长度大于1的无效段（如"012"）
  - 过滤数值超过255的无效段
- **结果拼接**：当生成4个有效段且用完所有字符时，将路径拼接为IP地址加入结果列表。

![image-20241220182843938](./images/image-20241220182843938.png)

```java
class Solution {

    List<String> ans = new ArrayList<>();
    List<String> path = new ArrayList<>();

    public List<String> restoreIpAddresses(String s) {
        dfs(s, 0, 4);
        return ans;
    }

    private void dfs(String s, int i, int k) {
       if(k == 0) {
           if(i == s.length()) ans.add(String.join(".", path));
           return;
       }

       for(int j = i; j < s.length() && j < i + 3; j++) {
           if(s.charAt(i) == '0' && j > i) return;
           int val = Integer.parseInt(s.substring(i, j + 1));
           if(val <= 255) {
               path.add(s.substring(i, j + 1));
               dfs(s, j + 1, k - 1);
               path.remove(path.size() - 1);
           }
       }
    }
}

```



## [19.删除链表的倒数第N个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

![image-20241220190322910](./images/image-20241220190322910.png)

思路：

要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的引用。

- 第一步，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

![image-20241220185846249](./images/image-20241220185846249.png)

- 第二步，用一个指针 `p2` 指向链表头节点 `head`：

![image-20241220190032419](./images/image-20241220190032419.png)

- 第三步，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时走了 `n - k` 步，`p2` 也走了 `n - k` 步，也就是链表的倒数第 `k` 个节点：

![image-20241220190217013](./images/image-20241220190217013.png)

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

解法中在链表头部接一个虚拟节点 `dummy` 是为了避免删除倒数第一个元素时出现空指针异常，在头部加入 `dummy` 节点并不影响尾部倒数第 `k` 个元素是什么。

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0, head);
        ListNode fast = dummy, slow = dummy;
        for(int i = 0; i < n; i++) fast = fast.next;
        while(fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }
        slow.next = slow.next.next;
        return dummy.next;
    }
}
```



## [1143.最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

思路：

- 动态规划：和 [72. 编辑距离](https://leetcode.cn/problems/edit-distance) 同为经典的双字符串动态规划问题。

- `dp[i][j]`定义：表示`text1`中`[0,i-1]`长度为`i`字符串 和`text2`中`[0,j-1`]长度为`j`字符串，公共子序列的最长长度

- 递推关系：

  ![image-20241221003833062](./images/image-20241221003833062.png)

  ![image-20241221004032052](./images/image-20241221004032052.png)

```java
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
        int n = text1.length(), m = text2.length();
        int[][] dp = new int[n + 1][m + 1];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if(text1.charAt(i) == text2.charAt(j)) {
                    dp[i+1][j+1] = dp[i][j] + 1;
                } else {
                    dp[i+1][j+1] = Math.max(dp[i+1][j], dp[i][j+1]);
                }
            }
        }
        return dp[n][m];
    }
}
```



## [82.删除排序链表中的重复元素II](https://leetcode.cn/problems/remove-duplicates-from-sorted-list-ii/)

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

思路：

- **虚拟头节点简化操作**：使用虚拟头节点`dummy`避免处理头节点可能被删除的特殊情况。
- **快慢指针遍历链表**：`cur`指针用于遍历链表，检查当前节点与下个节点的值是否相等。
- **删除重复节点**：当发现重复值时，跳过所有值相同的节点，直接连接到下一个不同值的节点。

![image-20241221015122537](./images/image-20241221015122537.png)

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode(0, head);
        ListNode cur = dummy;
        while(cur.next != null && cur.next.next != null) {
            if(cur.next.val == cur.next.next.val) {
                int deleteVal = cur.next.val;
                while(cur.next != null && cur.next.val == deleteVal) {
                    cur.next = cur.next.next;
                }
            } else {
                cur = cur.next;
            }
        }
        return dummy.next;
    }
}
```





## [4. 寻找两个正序数组的中位数](https://leetcode.cn/problems/median-of-two-sorted-arrays/)

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

思路：

- **分治法求第K小元素**：通过递归将两个有序数组合并问题转化为求第K小元素的问题。
- **二分查找优化**：
  - 每次比较两个数组的第k/2个元素，排除不可能包含第K小元素的部分
  - 递归处理剩余部分，减少搜索范围
- **处理奇偶长度**：根据合并后数组长度的奇偶性，分别计算中位数（奇数取中间值，偶数取中间两数平均值）

```java
class Solution {
    public double findMedianSortedArrays(int[] nums1, int[] nums2) {
        int n = nums1.length, m = nums2.length;
        int sum = n + m;
        if(sum % 2 == 1) {
            return (double) findKArrays(sum / 2 + 1, nums1, 0, n-1, nums2, 0, m-1);
        } else {
            return (double) (findKArrays(sum / 2 + 1, nums1, 0, n-1, nums2, 0, m-1) +
                    findKArrays(sum / 2, nums1, 0, n-1, nums2, 0, m-1)) / 2;
        }
    }

    private int findKArrays(int k, int[] num1, int start1, int end1, int[] num2, int start2, int end2) {
        if(start1 > end1) return num2[start2 + k - 1];
        if(start2 > end2) return num1[start1 + k - 1];
        if(k == 1) return Math.min(num1[start1], num2[start2]);

        int i1 = Math.min(start1 + k / 2 - 1, end1);
        int i2 = Math.min(start2 + k / 2 - 1, end2);

        if(num1[i1] < num2[i2]) {
            return findKArrays(k - (i1 - start1 + 1), num1, i1 + 1, end1, num2, start2, end2);
        } else {
            return findKArrays(k - (i2 - start2 + 1), num1, start1, end1, num2, i2 + 1, end2);
        }
    }
}
```



## [199.二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

思路：

- 上面出现了多次的层序遍历的题目，这个题目只是要得到每层的最右边的节点值
- **深度优先搜索（DFS）**：采用后序遍历方式（先右后左）访问二叉树节点。
- **记录最右节点**：当当前深度等于结果列表大小时，说明该节点是当前深度的最右可见节点，将其加入结果列表。
- **优先访问右子树**：通过先递归右子树再递归左子树的顺序，确保每次记录的都是当前深度的最右侧节点。

![image-20241221171950059](./images/image-20241221171950059.png)

```java
class Solution {
    List<Integer> ans = new ArrayList<>();

    public List<Integer> rightSideView(TreeNode root) {
        dfs(root, 0);
        return ans;
    }

    private void dfs(TreeNode root, int depth) {
        if(root == null) return;

        if(depth == ans.size()) ans.add(root.val);
        dfs(root.right, depth + 1);
        dfs(root.left, depth + 1);
    }
}

```




## [94. 二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

思路：

中序遍历结果的特点是 `root.val` 在中间，左右子树在两侧：

```java
class Solution {
    List<Integer> ans = new ArrayList<>();

    public List<Integer> inorderTraversal(TreeNode root) {
        dfs(root);
        return ans;
    }

    private void dfs(TreeNode root) {
        if(root == null) return;

        dfs(root.left);
        ans.add(root.val);
        dfs(root.right);
    }
}
```

![image-20241221145705065](./images/image-20241221145705065.png)





## [74.二分查找](https://leetcode.cn/problems/binary-search/)

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

思路：

- **二分查找算法**：在有序数组中通过不断缩小搜索范围来查找目标值。
- **中间值比较**：
  - 若中间值大于目标值，则在左半部分继续查找
  - 若中间值小于目标值，则在右半部分继续查找
  - 若相等则直接返回当前索引
- **边界处理**：当搜索范围缩小到左边界超过右边界时，说明目标值不存在，返回-1。

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0, right = nums.length - 1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] > target) {
                right = mid - 1;
            } else if (nums[mid] < target){
                left = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```



## [232.用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks/)

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`

![image-20241221173538453](./images/image-20241221173538453.png)

思路：

- **双栈模拟队列**：使用两个栈（inStack和outStack）来模拟队列的先进先出特性。
- **数据迁移机制**：
  - 入队时直接压入inStack
  - 出队或查看队首元素时，若outStack为空，则将inStack所有元素依次弹出并压入outStack
- **高效操作**：
  - 入队操作时间复杂度为O(1)
  - 出队和查看队首操作均摊时间复杂度为O(1)

```java
class MyQueue {

    Stack<Integer> inStack, outStack;

    public MyQueue() {
        inStack = new Stack<>();
        outStack = new Stack<>();
    }

    private void dumpStackIn() {
        if(!outStack.isEmpty()) return;
        while(!inStack.isEmpty()) {
            outStack.push(inStack.pop());
        }
    }
    
    public void push(int x) {
        inStack.push(x);
    }
    
    public int pop() {
        dumpStackIn();
        return outStack.pop();
    }
    
    public int peek() {
        dumpStackIn();
        return outStack.peek();
    }
    
    public boolean empty() {
        return inStack.isEmpty() && outStack.isEmpty();
    }
}
```



## [165. 比较版本号](https://leetcode.cn/problems/compare-version-numbers/description/)

给你两个 **版本号字符串** `version1` 和 `version2` ，请你比较它们。版本号由被点 `'.'` 分开的修订号组成。**修订号的值** 是它 **转换为整数** 并忽略前导零。

比较版本号时，请按 **从左到右的顺序** 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 `0`。

返回规则如下：

- 如果 `version1 < version2` 返回 `-1`，
- 如果 `version1 > version2` 返回 `1`，
- 除此之外返回 `0`。

思路：

这是一个比较实用的题目，工作中也可能出现

![image-20241224170806035](./images/image-20241224170806035.png)

- **版本号分割**：使用`.`作为分隔符将两个版本号字符串分割成数字数组。
- **逐位比较**：
  - 从左到右依次比较每个数字段的整数值
  - 处理不同长度的版本号（自动补0比较）
- **返回比较结果**：
  - 遇到不相等数值立即返回比较结果（1或-1）
  - 全部相等则返回0

```java
class Solution {
    public int compareVersion(String version1, String version2) {
        String[] s1 = version1.split("\\."), s2 = version2.split("\\.");
        int n = s1.length, m = s2.length;
        int i = 0, j = 0;
        while(i < n || j < m) {
            int a = 0, b = 0;
            if(i < n) a = Integer.parseInt(s1[i++]);
            if(j < m) b = Integer.parseInt(s2[j++]);
            if(a != b) return a > b ? 1 : -1;
        }
        return 0;
    }
}
```



## [148. 排序链表](https://leetcode.cn/problems/sort-list/)

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

思路：

- **分治递归**：将链表不断二分拆解为更小的子链表，直到子链表长度为1或0（天然有序）。
- **快慢指针找中点**：通过快慢指针定位中间节点，断开链表为左右两部分，保证分治的正确性。
- **归并合并**：递归合并两个已排序的子链表，通过比较节点值按顺序拼接成最终结果。

![image-20241221180631903](./images/image-20241221180631903.png)

```java
class Solution {
    public ListNode sortList(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode mid = findMid(head);
        ListNode head1 = sortList(head);
        ListNode head2 = sortList(mid);
        return mergeList(head1, head2);
    }

    private ListNode findMid(ListNode head) {
        ListNode pre = null;
        ListNode slow = head, fast = head;
        while(fast != null && fast.next != null) {
            pre = slow;
            slow = slow.next;
            fast = fast.next.next;
        }
        pre.next = null;
        return slow;
    }

    private ListNode mergeList(ListNode l1, ListNode l2) {
        if(l1 == null) return l2;
        if(l2 == null) return l1;
        if(l1.val < l2.val) {
            l1.next = mergeList(l1.next, l2);
            return l1;
        } else {
            l2.next = mergeList(l1, l2.next);
            return l2;
        }
    }
}

```



## [31.下一个排列](https://leetcode.cn/problems/next-permutation/)

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

思路：

以 `1,2,3,4,5,6` 为例，其排列依次为：

```java
123456
123465
123546
...
654321
```

可以看到有这样的关系：`123456 < 123465 < 123546 < ... < 654321`。

- 我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465

- 我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：

  - 在尽可能**靠右的低位**进行交换，需要**从后向前**查找

  - 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
  - 将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 1235 64；然后需要将 5 之后的数重置为升序，得到 1235 46。显然 1235 46 比 1235 64 更小，123546 就是 123465 的下一个排列



这个就是推到下一个排列的基本规则

1. **从后向前寻找下降点**：找到第一个满足 `nums[i] < nums[i+1]` 的位置 `i`，确定需要调整的起始位置。
- **交换相邻更大元素**：在 `i` 之后的升序部分中，找到第一个大于 `nums[i]` 的元素 `nums[j]` 并交换，使序列尽可能小地增大。
- **反转后续升序部分**：将 `i+1` 到末尾的升序部分反转，使其变为降序，得到最小的下一个排列。

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        // 找到第一个要下降的元素
        while(i >= 0 && nums[i] >= nums[i+1]) i--;

        if(i >= 0) {
            int j = nums.length - 1;
            // 找到第一个比 nums[i] 小的元素，没有就一直循环找
            while(j >= 0 && nums[j] <= nums[i]) j--;
            swap(nums, i, j);
        }

        int left = i + 1, right = nums.length - 1;
        while(left < right) swap(nums, left++, right--);
    }

    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```



## [22.括号生成](https://leetcode.cn/problems/generate-parentheses)

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

思路：

- 利用回溯算法，在每个位置选择【左括号】或者【右括号】，组成括号组合
- 为了减少不必要的穷举，我们要知道合法括号串有以下性质

  - **一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解**。
  - **对于一个「合法」的括号字符串组合 `p`，必然对于任何 `0 <= i < len(p)` 都有：子串 `p[0..i]` 中左括号的数量都大于或等于右括号的数量**。

因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。



- **回溯法生成所有可能组合**：通过深度优先搜索（DFS）递归构建所有可能的括号组合。
- **剪枝优化**：当右括号数量超过左括号时直接返回，避免无效分支（`right > left` 时终止）。
- **逐步构建并回溯**：使用 `StringBuilder` 动态添加/删除括号字符，确保每次递归后恢复状态。

```java
class Solution {

    List<String> ans = new ArrayList<>();
    StringBuilder sb = new StringBuilder();

    public List<String> generateParenthesis(int n) {
        dfs(0, 0, n);
        return ans;
    }

    private void dfs(int left, int right, int n) {
        if(left == n && right == n) {
            ans.add(sb.toString());
            return;
        }

        if(right > left) return;
        if(left < n) {
            sb.append("(");
            dfs(left + 1, right, n);
            sb.deleteCharAt(sb.length() - 1);
        }
        if(right < n) {
            sb.append(")");
            dfs(left, right + 1, n);
            sb.deleteCharAt(sb.length() - 1);
        }
    }
}
```


## [69. x的平方根](https://leetcode.cn/problems/sqrtx/)

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

思路：

- 这里其实是一道数学题。比如 求数字 `4` 的平方根，转换成求两个数的乘积，就是 `2*2=4`。
- **二分查找确定平方根范围**：在 `1` 到 `x` 的范围内使用二分查找，寻找满足 `mid² ≤ x` 的最大整数 `mid`。
- **避免溢出技巧**：使用 `x / mid` 替代 `mid * mid` 进行比较，防止整数溢出。
- **更新搜索边界**：若 `mid² ≤ x`，则尝试更大的值（`left = mid + 1`）；否则尝试更小的值（`right = mid - 1`），最终返回满足条件的最大 `mid`。

```java
class Solution {
    public int mySqrt(int x) {
        int left = 1, right = x;
        int ans = 0;
        while(left <= right) {
            int mid = (left + right) >>> 1;
            if(x / mid >= mid) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }
}
```



## [239. 滑动窗口最大值](https://leetcode.cn/problems/sliding-window-maximum/)

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

思路：

使用【队列】充当不断滑动的窗口，每次滑动记录【队列】的最大值：

![image-20241224181832923](./images/image-20241224181832923.png)

如何在 `O(1)` 时间计算最大值，只需要一个特殊的数据结构「单调队列」，`push` 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉，直到遇到更大的元素才停止删除。

![image-20241224182245137](./images/image-20241224182245137.png)

使用单调队列数据结构就能完成本题，队列头部元素就是最大值。

```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        int[] ans = new int[n - k + 1];
        Deque<Integer> q = new ArrayDeque<>();
        for (int i = 0; i < n; i++) {
            while(!q.isEmpty() && nums[i] >= nums[q.getLast()]) {
                q.removeLast();
            }
            q.addLast(i);
            if(i - q.getFirst() >= k) {
                q.removeFirst();
            }
            if(i - k + 1 >= 0) {
                ans[i - k + 1] = nums[q.getFirst()];
            }
        }
        return ans;
    }
}
```



## [2. 两数相加](https://leetcode.cn/problems/add-two-numbers/)

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

![image-20241224163034165](./images/image-20241224163034165.png)

思路：

- **模拟手工加法**：从最低位开始逐位相加，处理进位（carry），直到两个链表都遍历完且没有进位剩余。

- **链表动态构建**：使用哑节点（dummy）简化结果链表的构建过程，直接在遍历过程中创建新节点。
- **统一处理不等长链表**：通过 `l1 != null || l2 != null || carry != 0` 条件，确保处理完所有位数和可能的最高位进位。

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode dummy = new ListNode();
        ListNode cur = dummy;
        int carry = 0;
        while(l1 != null || l2 != null || carry != 0) {
            if(l1 != null) {
                carry += l1.val;
                l1 = l1.next;
            }
            if(l2 != null) {
                carry += l2.val;
                l2 = l2.next;
            }

            cur = cur.next = new ListNode(carry % 10);
            carry /= 10;
        }
        return dummy.next;
    }
}
```





## [8. 字符串转换整数](https://leetcode.cn/problems/string-to-integer-atoi/)

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数。

函数 `myAtoi(string s)` 的算法如下：

1. **空格：**读入字符串并丢弃无用的前导空格（`" "`）
2. **符号：**检查下一个字符（假设还未到字符末尾）为 `'-'` 还是 `'+'`。如果两者都不存在，则假定结果为正。
3. **转换：**通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。
4. **舍入：**如果整数数超过 32 位有符号整数范围 `[−231, 231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被舍入为 `−231` ，大于 `231 − 1` 的整数应该被舍入为 `231 − 1` 。

返回整数作为最终结果。

思路：

- **预处理阶段**：
  - 跳过前导空格字符
  - 处理可选的正负号（默认为正）
- **数字转换阶段**：
  - 逐个字符检查是否为数字
  - 将有效数字转换为整数并累加
  - 实时检查溢出情况（超过Integer范围时立即返回边界值）

- **返回结果**：
  - 根据符号位返回最终结果
  - 自动处理溢出情况（返回Integer.MAX_VALUE或Integer.MIN_VALUE）

```java
class Solution {
    public int myAtoi(String s) {
        int len = s.length(), index = 0, sign = 1, ans = 0;

        // 空格
        while(index < len && s.charAt(index) == ' ') index++;

        // 符号位
        if(index < len) {
            if(s.charAt(index) == '+') {
                sign = 1;
                index++;
            } else if(s.charAt(index) == '-'){
                sign = -1;
                index++;
            }
        }

        while(index < len && s.charAt(index) >= '0' && s.charAt(index) <= '9') {
            int digit = s.charAt(index) - '0';

            if(ans > Integer.MAX_VALUE / 10 ||
                    (ans == Integer.MAX_VALUE / 10 && digit > Integer.MAX_VALUE % 10) ) {
                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;
            }

            ans = ans * 10 + digit;
            index++;
        }

        return sign * ans;
    }
}
```



## [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

思路：

-  动态规划题型
- `dp[i]`含义：到达 `i`阶，可以有 `dp[i]`种不同的方法
- 递推关系：到达 `i-1`阶，有 `dp[i-1]`种方法，到达 `i-2`阶，有 `dp[i-2]`种方法，到达 `i`阶【可以从 `i-1`阶，爬 `1`个台阶直接到达】 或者 【可以从 `i-2`阶，爬 `2`个台阶直接到达】，有 `dp[i] = dp[i-1] + dp[i-2]`种方法

```java
class Solution {
    public int climbStairs(int n) {
        int[] dp = new int[n+1];
        dp[0] = dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i-2] + dp[i-1];
        }
        return dp[n];
    }
}
```



## [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

思路：

- 最值问题：就要想到 动态规划

  `dp[i]`表示以` s[i]` 结尾的字符串的长度

  如果 `s[i] == '(' `，不是一个有效字符串，`dp[i]`长度为`0`

  如果 `s[i] == ')'`，如果能找到 左括号，说明当前的右括号作为字符串的结尾，能找到左括号和自己一起组成一个有效的字符串，否则，右括号，作为结尾，不是一个有效的字符串

- 涉及到括号的问题：就需要想到 **栈**

  当遇到左括号，直接入栈 左括号的索引值

  如果遇到右括号，看下栈中是否为空，不为空，说明可以找到左括号和右括号一起组成有效字符串，否则，不能组成有效字符串（右括号需要入栈）



- **栈辅助计算**：使用栈来记录括号的索引位置，初始压入-1作为基准。
- **动态更新有效长度**：
  - 遇到 '(' 时压入当前索引
  - 遇到 ')' 时弹出栈顶，若栈为空则压入当前索引作为新基准，否则计算当前有效长度（当前索引 - 新栈顶）
- **维护最大值**：每次计算有效长度后更新全局最大值。

```java
class Solution {
    public int longestValidParentheses(String s) {
        if(s.length() < 2) return 0;
        Deque<Integer> q = new ArrayDeque<>();
        q.push(-1);
        int ans = 0;
        for (int i = 0; i < s.length(); i++) {
            if(s.charAt(i) == '(') {
                q.push(i);
            } else {
                q.pop();
                if(q.isEmpty()) {
                    q.push(i);
                } else {
                    ans = Math.max(ans, i - q.peek());
                }
            }
        }
        return ans;
    }
}
```





## [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

思路：

- 动态规划题型

- 定义`dp`数组：`dp[i]`表示凑成金额`i` 所需要的**最少的硬币个数**为 `dp[i]`

- 递推关系：

  为了凑成金额 `i`，可以供我们选择的硬币有`coins[0....]`不同面额的硬币；

  如果选择某个硬币 `coins[j]`，那么剩余金额变为`i - coins[j]` ；

  继续选择某个硬币 `coins[x]`，那么剩余的金额变为 `i -coins[j] - coins[x]`

  ![image-20241225155105399](./images/image-20241225155105399.png)

  最终的递推关系为：`dp[i] = min(dp[i], dp[i-coins[0...] + 1])`

  `dp[i-coins[0...] + 1 ` 含义： `coins[0...]` 每次选择，所有的硬币可供选择，如果选择某个硬币`coins[j]`后，凑成剩余金额`i-coins[j]`需要 `dp[i-coins[j]]`最少硬币个数  +1 表示选中了硬币`coins[j]`

  `min`表示，金额 `i`可以选的硬币有很多种`coins[0...]`，我们只需 硬币最小的结果

  *还有个前提，选中的硬币的面额，不能大于要凑的金额`i`*



- **动态规划解法**：使用一维数组`dp`记录凑成金额`j`所需的最少硬币数。
- **初始化设置**：
  - `dp[0] = 0`（金额为0不需要硬币）
  - 其他位置初始化为`Integer.MAX_VALUE`（表示不可达）
- **状态转移**：
  - 遍历每个硬币面值
  - 对于每个金额`j`，若`j - coins[i]`可达，则更新`dp[j]`为`min(dp[j], dp[j - coins[i]] + 1)`
- **结果判断**：若`dp[amount]`仍为`MAX_VALUE`则返回-1，否则返回`dp[amount]`

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount + 1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 0; i < coins.length; i++) {
            for(int j = coins[i]; j <= amount; j++) {
                if(dp[j - coins[i]] != Integer.MAX_VALUE) dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);
            }
        }
        return dp[amount] == Integer.MAX_VALUE ? -1 : dp[amount];
    }
}
```



## [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring/)

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

思路：

这题就是典型的滑动窗口类题目，一般来说难度略高。

题目要求 返回 `s` 中涵盖 `t` 所有字符的最小子串。

- 需要知道 `t`中有哪些字符

- 在 `s`中找到包含`t`中所有字符的字符串（注意是包含，不是相等），

  比如  `s = abc t = ac`，字符串 `s`是包含 `t`的所有字符的；

  比如 `s = abc   t = aa`，字符串 `s`是不包含 `t`中的所有字符的，因为`t`中有两个 `a`, `s`中只有一个 `a`



- **滑动窗口算法**：使用双指针（i和j）维护一个动态窗口，寻找包含目标字符串t所有字符的最小窗口。
- **频率统计**：
  - 使用两个数组hs和ht分别记录当前窗口和目标字符串t的字符频率
  - 通过比较hs和ht来判断窗口是否包含t的所有字符
- **窗口调整策略**：
  - 扩展右边界i，将新字符加入窗口
  - 当窗口满足条件时，收缩左边界j以寻找更小的窗口
  - 实时更新最小窗口结果

```java
class Solution {
    public String minWindow(String s, String t) {
        // 初始化两个频率数组，用于记录字符出现次数
        int[] hs = new int[128];  // 当前窗口字符频率
        int[] ht = new int[128];  // 目标字符串t的字符频率
        String ans = null;        // 存储最终结果

        // 统计t中各字符的出现频率
        for(int i = 0; i < t.length(); i++) {
            ht[t.charAt(i)]++;
        }

        // 滑动窗口过程
        for(int i = 0, j = 0, cnt = 0; i < s.length(); i++) {
            // 扩展右边界，将s[i]加入窗口
            hs[s.charAt(i)]++;

            // 如果当前字符在t中，且窗口中的该字符数量不超过t中的数量，则计数增加
            if(hs[s.charAt(i)] <= ht[s.charAt(i)]) {
                cnt++;
            }

            // 当窗口包含t所有字符时，尝试收缩左边界
            while(hs[s.charAt(j)] > ht[s.charAt(j)] && cnt == t.length()) {
                hs[s.charAt(j)]--;  // 减少左边界字符计数
                j++;                // 移动左边界
            }

            // 如果当前窗口包含t所有字符，检查是否是最小窗口
            if(cnt == t.length()) {
                if(ans == null || ans.length() > i - j + 1) {
                    ans = s.substring(j, i + 1);  // 更新最小窗口
                }
            }
        }

        return ans == null ? "" : ans;  // 返回结果，如果没有则返回空字符串
    }
}
```



## [43. 字符串相乘](https://leetcode.cn/problems/multiply-strings/)

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

思路：

- 定义两个指针`i j`，分别指向 `num1` 和 `num2`的尾部，从个位开始计算乘积
- 计算的结果累加，保存到 `res`的索引 `i+j+1`位置处

![image-20241226174016960](./images/image-20241226174016960.png)

- 最后，将`res`中的结果，从尾部到首部（也就是从个位）依次进位，得到最终的结果

![image-20241226174438216](./images/image-20241226174438216.png)



- **模拟竖式乘法**：将两个大数字符串的每一位相乘，并将结果累加到对应位置。
- **处理进位**：从低位到高位依次处理进位，确保每一位都在0-9范围内。
- **构建结果字符串**：跳过前导零，将数字数组转换为最终的字符串结果，处理全零的特殊情况。

```java
class Solution {
    public String multiply(String num1, String num2) {
        // 1. 初始化结果数组
        int m = num1.length(), n = num2.length();
        int[] result = new int[m + n];

        // 2. 计算每一位的乘积并累加到对应位置
        for (int i = m - 1; i >= 0; i--) {
            for (int j = n - 1; j >= 0; j--) {
                result[i + j + 1] += (num1.charAt(i) - '0') * (num2.charAt(j) - '0');
            }
        }

        // 3. 处理进位
        for (int i = result.length - 1; i >= 0; i--) {
            if (result[i] >= 10) {
                result[i - 1] += result[i] / 10;
                result[i] %= 10;
            }
        }

        // 4. 将结果数组转换为字符串
        StringBuilder res = new StringBuilder();
        boolean zero = true;
        for (int v : result) {
            if (v == 0 && zero) continue;
            zero = false;
            res.append((char) ('0' + v));
        }
        return res.length() == 0 ? "0" : res.toString();
    }
}
```




## [41. 缺失的第一个正数](https://leetcode.cn/problems/first-missing-positive/)

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

思路：

这题如果第一次做，会感觉很绕。其实本质目的就是让数值：比如 `1`放到索引 `0`， `2` 放到索引`1`，数值`3`放到索引`2` 。 这样就形成了，随着索引`i`的递增，元素值也是顺序递增的（并且之间是 `+1` 的关系）

题目要求【缺失的最小正整数】：将数组中的元素，按照 1，2，3，4，5，6.... 这个顺序排列。（同时观察到1,2,3,4,5和数组索引的关系 0,1,2,3,4，是相差`1`的关系）

- 数组的长度为`n`，如果数组中的元素都是按照1，2，3，4，5，6.... 这个顺序排列，也就是【`1～n`】，那么最小的正整数就是`n+1`

- 如果数组中的元素出现跳空（也就是缺失某一个）那么索引位置 `i`对应的元素值 `nums[i]`，之间不满足 `i+1 == nums[i]`

![image-20241225010731408](./images/image-20241225010731408.png)



- **原地哈希思想**：利用数组本身作为哈希表，将数字放到其值对应的索引位置上（如数字3放在索引2处）
- **两轮遍历**：
  1. 第一轮遍历：通过交换操作将每个有效数字（1到n范围内）放到正确位置
  2. 第二轮遍历：检查每个位置i上的数字是否为i+1，第一个不符合的位置即为缺失的最小正整数
- **边界处理**：如果所有位置都正确，则缺失的最小正整数为n+1

```java
class Solution {
    public int firstMissingPositive(int[] nums) {
        int n = nums.length;

        // 第一次遍历：将每个数字放到它应该在的位置上
        for(int i = 0; i < n; i++) {
            // 当数字在1到n范围内，并且不在正确位置时，进行交换
            while(nums[i] > 0 && nums[i] <= n && nums[nums[i] - 1] != nums[i]) {
                // 交换nums[i]和nums[nums[i]-1]
                int temp = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i] = temp;
            }
        }

        // 第二次遍历：查找第一个位置不正确的数字
        for(int i = 0; i < n; i++) {
            if(nums[i] != i + 1) {
                return i + 1;  // 找到缺失的最小正整数
            }
        }

        // 如果所有位置都正确，返回n+1
        return n + 1;
    }
}
```





## [LCR 140. 训练计划 II - 力扣（LeetCode）|| 链表中倒数第 K 个节点](https://leetcode.cn/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)

给定一个头节点为 `head` 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 `cnt` 个训练项目编号。

思路：

- **快慢指针初始化**：同时从链表头部开始，快指针先移动`cnt`步
- **快慢指针同步移动**：当快指针未到达末尾时，快慢指针同步移动
- **返回结果节点**：当快指针到达末尾时，慢指针指向的节点即为倒数第`cnt+1`个节点（即训练计划起始节点）

```java
class Solution {
    public ListNode trainingPlan(ListNode head, int cnt) {
        ListNode slow = head, fast = head;
        for(int i = 0; i < cnt; i++) {
            if(fast == null) return null;
            fast = fast.next;
        }
        while(fast != null) {
            fast = fast.next;
            slow = slow.next;
        }
        return slow;
    }
}
```





## [105. 从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

思路：

**构造二叉树，第一件事一定是找根节点，然后想办法构造左右子树**。

二叉树的前序和中序遍历结果的特点如下：

![image-20241225182611962](./images/image-20241225182611962.png)



- **哈希表优化查找**：预先构建中序遍历值的索引映射，实现O(1)时间复杂度的根节点位置查找
- **递归构建二叉树**：
  - 前序遍历的第一个元素是当前子树的根节点
  - 根据根节点在中序遍历中的位置划分左右子树
  - 递归构建左子树和右子树
- **边界条件处理**：当preStart等于preEnd时返回null，表示当前子树为空

```java
class Solution {
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        Map<Integer, Integer> inorderMap = new HashMap<>();
        for (int i = 0; i < inorder.length; i++) {
            inorderMap.put(inorder[i], i);
        }
        return build(preorder, 0, preorder.length, inorder, 0, inorder.length, inorderMap);
    }

    private TreeNode build(int[] preorder, int preStart, int preEnd,
                           int[] inorder, int inStart, int inEnd,
                           Map<Integer, Integer> inorderMap) {
        if (preStart == preEnd) return null;

        int rootVal = preorder[preStart];
        int rootIndex = inorderMap.get(rootVal);
        int leftSize = rootIndex - inStart;

        TreeNode root = new TreeNode(rootVal);
        root.left = build(preorder, preStart + 1, preStart + 1 + leftSize,
                inorder, inStart, rootIndex, inorderMap);
        root.right = build(preorder, preStart + 1 + leftSize, preEnd,
                inorder, rootIndex + 1, inEnd, inorderMap);

        return root;
    }
}
```





## [78. 子集](https://leetcode.cn/problems/subsets/)

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

思路：

回溯算法：类似于遍历这棵树

- **回溯法生成子集**：通过深度优先搜索（DFS）递归生成所有可能的子集组合。
- **路径记录与回溯**：
  - 每次递归调用前将当前路径加入结果集
  - 遍历可选元素，依次添加到当前路径
  - 递归处理后续元素后移除最后添加的元素（回溯）
- **自然包含空集**：初始调用时直接加入空路径，自动包含空集结果。

![image-20241225185323251](./images/image-20241225185323251.png)

```java
class Solution {
    List<List<Integer>> ans = new ArrayList<>();
    List<Integer> path = new ArrayList<>();

    public List<List<Integer>> subsets(int[] nums) {
        dfs(nums, 0);
        return ans;
    }

    private void dfs(int[] nums, int i) {
        ans.add(new ArrayList<>(path));
        for(int j = i; j < nums.length; j++) {
            path.add(nums[j]);
            dfs(nums, j + 1);
            path.remove(path.size() - 1);
        }
    }
}
```



## [151. 反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

思路：

- **三步处理法**：
  1. 清理多余空格（首尾及中间连续空格）
  2. 整体翻转字符串
  3. 逐个翻转每个单词
- **核心方法**：
  - `cleanSpaces()`：去除多余空格并返回新字符数组
  - `reverse()`：辅助方法，用于翻转指定区间的字符
  - `reverseWords()`：识别单词边界并翻转每个单词

- **高效处理**：通过原地修改字符数组减少空间复杂度

```java
public class Solution {
    public String reverseWords(String s) {
        // 1. 清理空格
        char[] chars = cleanSpaces(s.toCharArray());

        // 2. 翻转整个字符串
        reverse(chars, 0, chars.length - 1);

        // 3. 翻转每个单词
        reverseWords(chars);

        return new String(chars);
    }

    private char[] cleanSpaces(char[] chars) {
        int n = chars.length;
        char[] result = new char[n];
        int index = 0;
        boolean space = true; // 标记前一个字符是否是空格

        for (int i = 0; i < n; i++) {
            if (chars[i] != ' ') {
                result[index++] = chars[i];
                space = false;
            } else if (!space) {
                result[index++] = ' ';
                space = true;
            }
        }

        // 处理末尾可能的空格
        if (index > 0 && result[index - 1] == ' ') {
            index--;
        }

        return Arrays.copyOf(result, index);
    }

    private void reverseWords(char[] chars) {
        int n = chars.length;
        int i = 0, j = 0;

        while (i < n) {
            while (j < n && chars[j] != ' ') {
                j++;
            }
            reverse(chars, i, j - 1);
            i = j + 1;
            j = i;
        }
    }

    private void reverse(char[] chars, int i, int j) {
        while (i < j) {
            char temp = chars[i];
            chars[i] = chars[j];
            chars[j] = temp;
            i++;
            j--;
        }
    }
}
```



## 155. 最小栈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

思路：

我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 `getMin` 方法，只能老老实实把所有元素弹出来然后找最小值。**想提高时间效率，那肯定要通过空间换时间的思路**。

所以这道题的关键就是，**每个元素入栈时，还要记下来当前栈中的最小值**。比方说，可以用一个额外的栈 `minstack` 来记录栈中每个元素入栈时的**栈中的最小元素**是多少，这样每次获取元素时就能快速得到剩余栈中的最小元素了。

```java
type MinStack struct {
    stack []int // 存储所有元素
    minstack []int // 存储最小元素（也就是比栈顶元素还要小的元素，才能保存到 minstack中）
}


func Constructor() MinStack {
    return MinStack {
        stack:make([]int,0),
        minstack:make([]int,0),
    }
}


func (this *MinStack) Push(val int)  {
  	// 入栈
    this.stack = append(this.stack,val)

    if len(this.minstack) == 0 {
        this.minstack = append(this.minstack,val)
    } else {
      	// val 比 minstack 栈顶元素更小，才能保存（记录栈中每个元素入栈时的栈中的最小元素）
        if this.minstack[len(this.minstack)-1] >= val {
            this.minstack = append(this.minstack,val)
        }
    }
}


func (this *MinStack) Pop()  {
		// 如果弹出的元素和最小栈的栈顶元素一样，最小栈也需要弹出
    if this.Top() == this.minstack[len(this.minstack)-1] {
         this.minstack = this.minstack[:len(this.minstack)-1]
    }
		// 弹出栈顶元素
    this.stack = this.stack[:len(this.stack)-1]
}

// 栈顶元素
func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

// 最小元素
func (this *MinStack) GetMin() int {
    return this.minstack[len(this.minstack)-1]
}

```



## 129. 求根节点到叶子节点数字之和

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

![image-20241227162052025](./images/image-20241227162052025.png)

思路：

这题就是标准的二叉树遍历题型，遍历的同时需要累积每个节点的值

```java

func sumNumbers(root *TreeNode) int {
    return traverse(root,0)
}

// root 从根节点到叶节点生成的 所有路径数字之和 
// cur 累积到root 节点，对应的数字
func traverse(root *TreeNode,cur int) int {
    
    if root == nil {
        return 0
    }
    // 遍历到当前节点，对应的路径数字
    cur = 10 * cur + root.Val
   
    if root.Left == nil && root.Right == nil { // 说明当前是叶子节点
        return cur // 返回路径数字
    }
  	// 从 root.Left到叶子节点 路径数字之和 + 从 root.Right 到叶子节点 路径数字之和
    return traverse(root.Left,cur) + traverse(root.Right,cur)
}
```



## 101. 对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

![image-20241227165730354](./images/image-20241227165730354.png)

思路：

- 观察下上面的示例，【对称】就是左右两颗树是镜像。对称的检查过程，就是二叉树的遍历过程。
- 先检查左右两个根节点`root.Left root.Right`是否相同；
- 如果相同，再检查【左节点的左树 和 右节点的右树】 以及【左节点的右树 和 右节点的左树】是否对称

```java
func isSymmetric(root *TreeNode) bool {
  	// 空树，一定对称
   if root == nil {
       return true
   }
	 // 检查左右树是否对称
   return check(root.Left,root.Right)
}

// check 校验左右树对称
func check(left,right *TreeNode) bool {
    // 都是nil
    if left == nil && right == nil {
        return true
    }
    // 有一个是nil
    if left == nil || right == nil {
        return false
    }
  	// 左右节点不相同
    if left.Val != right.Val {
        return false
    }
    // 在【左右树根节点】相同的情况下，继续检查下层的树结构，是否对称
    return check(left.Left,right.Right) && check(left.Right,right.Left)
}
```



## 144. 二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

```java
// 迭代方式前序遍历二叉树 （ 这个解法和上面的【中序遍历】对比看下，可以看到完全一样的写法，只是 【记录数值】的位置不同而已
func preorderTraversal1(root *TreeNode) []int {

    result := []int{}
    if root == nil {
        return result
    }

    sk := []*TreeNode{}
    for len(sk) != 0 || root != nil {
      	// 先处理左节点
        for root != nil {
            result = append(result,root.Val) // 记录数值
            sk = append(sk,root) // 入栈
            root = root.Left
        }
        // 再处理右节点
        root = sk[len(sk)-1]
        sk = sk[:len(sk)-1] // 出栈
        root = root.Right
    }
    return result
}


// 最简单的递归方式遍历二叉树
var res []int
func preorderTraversal(root *TreeNode) []int {

    res = []int{}
    preorder(root)

    return res
}

func preorder(root *TreeNode){
    if root == nil {
        return
    }

    res = append(res,root.Val)
    preorder(root.Left)
    preorder(root.Right)
}
```



## 104. 二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

思路：

注意`maxDepth`函数的定义：以 `root`为根节点的二叉树的最大深度

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// 以 `root`为根节点的二叉树的最大深度
func maxDepth(root *TreeNode) int {
  	// 如果节点为nil,深度为0
    if root == nil {
        return 0
    }
  	// 以 root.Left 为根节点的二叉树的最大深度 
  	// 以 root.Right 为根节点的二叉树的最大深度 
    // 取最大值 + 1 作为 以 `root`为根节点的二叉树的最大深度（ +1 表示当前的root这个节点的计数）
    return max(maxDepth(root.Left),maxDepth(root.Right)) + 1
}

func max( a,b int) int{
    if a > b {
        return a
    }
    return b
}
```



## 39. 组合总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

思路：

利用回溯算法解题：

- 需要指定 `start`限定可选元素的范围（因为是求组合问题），如果是求排列，不用指定形参 `start`（可以看下上面的回溯算法解题套路模板）
- 元素可以重复使用多次

这道题的关键在于 `candidates` 中的**元素可以复用多次**，体现在代码中是下面这段：

```java
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
  
  for i := start; i < len(candidates); i++ {
		// 选择
    
    // 下一层的选择【注意这里：i】
		backtrace(candidates, i , trace, target, sum)
    
    // 撤销
	}
}
```

如果题目要求 `candidates`中的元素【不能】重复多次，体现在代码中是下面这段：

```java
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
  
  for i := start; i < len(candidates); i++ {
		// 选择
    
    // 下一层的选择【注意这里：i+1】
		backtrace(candidates, i+1 , trace, target, sum)
    
    // 撤销
	}
}
```

注意体会先这两种区别。

实际代码如下：

```java
var result [][]int

func combinationSum(candidates []int, target int) [][]int {
	//回溯算法

	result = [][]int{}
	trace := []int{}
	backtrace(candidates, 0, trace, target, 0)

	return result
}

// 因为求组合问题，需要 start来限定元素的选择范围，如果是求排列，就不需要 start参数
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
	
  // 终止条件
	if sum >= target {  // 因为都是正整数（剪枝）
		if sum == target { // 找到一个结果
			temp := make([]int, len(trace))
			copy(temp, trace)
			result = append(result, temp)
		}
		return
	}

	// 执行到这里，说明 sum < target，继续找下一个元素加入到 trace 中
	for i := start; i < len(candidates); i++ {
    // 选择
		trace = append(trace, candidates[i])
		sum += candidates[i]

    // 下一层（元素可以重复选择）的选择范围为 [i:len(nums)-1]
    // 如果不能重复选择，这里应该填写 i+1
		backtrace(candidates, i , trace, target, sum)

    // 撤销
		trace = trace[:len(trace)-1]
		sum -= candidates[i]
	}
}
```



## 101. 平衡二叉树

给定一个二叉树，判断它是否是 平衡二叉树 

思路：

**平衡二叉树** 是指该树所有节点的左右子树的高度相差不超过 1

其实这题是**求树的最大深度**的一个扩展，多了一步求左右子树的高度差

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var isbalance bool = true
func isBalanced(root *TreeNode) bool {
    isbalance = true
    if root == nil {
        return true
    }
    maxDepth(root)
    return isbalance
}

// 求树的最大深度
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
		// 左右树的最大深度
    leftVal := maxDepth(root.Left)
    rightVal := maxDepth(root.Right)
  	// 如果高度差，绝对值相差 1，说明不平衡
  if abs(leftVal,rightVal) > 1 {
        isbalance = false
    }
    return 1 + max(leftVal,rightVal)
}

func abs(a,b int) int {
    if a > b {
        return a-b
    }
    return b-a
}
func max(a,b int)int{
    if a>b {
        return a
    }
    return b
}
```

## 48. 旋转图像

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

![image-20241228174153448](./images/image-20241228174153448.png)

思路：

这题其实就是**瞪眼法**找到数字之间的交换规则。

先把二维矩阵沿对角线反转，然后反转矩阵的每一行，结果就是顺时针反转整个矩阵。

```java
func rotate(matrix [][]int)  {
    ///！！！巧思题：顺时针旋转,从左上角到右下角--对角线交换；如果是逆时针旋转，按照右上角到左下角-对角线交换
    ///1.顺时针旋转,按照从左上角到右下角--对角线交换，结果为
    /*
        1 4 7
        2 5 8
        3 6 9
    */
    n := len(matrix)
    for i := 0;i < n;i++ {
        for j := i+1;j < n;j++ {
            //对角线翻转
            matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]
        }
    }
    
    ///2.再观察，每一行首尾交换，即为结果
    for i := 0;i < n;i++ {
        left ,right := 0,n-1
        for left < right {
            matrix[i][left],matrix[i][right] = matrix[i][right],matrix[i][left]
            left++
            right--
        }
    }
}

```



## 543. 二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

思路：

所谓二叉树的直径，就是左右子树的最大深度之和，那么直接的想法是对每个节点计算左右子树的最大高度，得出每个节点的直径，从而得出最大的那个直径。

```java

var result int = 0
func diameterOfBinaryTree(root *TreeNode) int {
   
    result = 0
    maxDepth(root)
    return result
}

// 树的最大高度
func maxDepth(root *TreeNode) int{

    if root == nil {
        return 0
    }
    // root左子树最大高度
    leftDepth := maxDepth(root.Left)
    // root右子树最大高度
    rightDepth := maxDepth(root.Right)
    //经过root节点的最大直径（注意：这里不需要对leftDepth + rightDepth 再+1），计算的是边的数目
    result = max(result,leftDepth+rightDepth) 
  
  	// 左右子树高度的最大值 + 1
    return 1 + max(leftDepth,rightDepth) 
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```



## 470. 用 Rand7()实现Rand10()



给定方法 `rand7` 可生成 `[1,7]` 范围内的均匀随机整数，试写一个方法 `rand10` 生成 `[1,10]` 范围内的均匀随机整数。

你只能调用 `rand7()` 且不能调用其他方法。请不要使用系统的 `Math.random()` 方法。

每个测试用例将有一个内部参数 `n`，即你实现的函数 `rand10()` 在测试时将被调用的次数。请注意，这不是传递给 `rand10()` 的参数。

思路：

- `(rand7()-1)*7`  等价于 `(【1...7】- 1) * 7 ` 等价于 ` [0...6]*7 ` 也等价于 `【0，7，14，21，28，35，42】`  每个数字只出现的概率为`1/7`
- `(rand7()-1)*7 + rand7() ` 等价于`【0，7，14，21，28，35，42】+ rand7()` 等价于每个数值`(0 , 7 ,14...)`分别 `+ rand7()` 即为`[1...7][8...14][15...21].....[43..49] 每种值出现的概率都是相同的；1/49`
- 转化一下为：`[1...10] [11...20] [21..30] [31....40] [41...49]` 这里少了`50`这个数值，对`10`求余数，少了出现一次`0`的机会
- 比如求【余数1 】分别为 `1 11 21 31 41` 对10求余，可以得到`5`次`1`
- 求【余数0】分别为`10 20 30 40`对10求余，只能得到`4`次`1`

```java
func rand10() int {
   
    for {
        num := (rand7()-1)*7 + rand7() 
        if num <= 40 { // 这里要舍弃[41...49]这些数值
            return num % 10 + 1 // 因为求 [1..10]，所以需要 num%10 + 1
        }
    }
    return 0    
}
```



## 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

思路：

初学者做这题很容易有误区：`BST`（二叉搜索树） 不是左小右大么，那我只要检查 `root.val > root.left.val` 且 `root.val < root.right.val` 不就行了？

这样是不对的，因为 `BST` 左小右大的特性是指 `root.val` 要比【左子树的**所有节点**都更大】，要比【右子树的**所有节点**都小】，你只检查左右两个子节点当然是不够的。

正确解法是通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉搜索树算法的一个小技巧吧。

```java
func isValidBST(root *TreeNode) bool {
    return isValid(root,nil,nil) // 刚开始的root不是任何节点的左子树和右子树，所以不存在min和max节点
}

// 验证 root 树 与 最大节点值和最小节点值
//  min <   root树的节点值  < max
func isValid(root *TreeNode, min *TreeNode,max *TreeNode) bool {
		// 验证节点值
    if root == nil {
        return true
    }
		
  	// min最小值不为空，root的值，如果比最小值还小，说明root节点不满足 BST性质
    if min != nil && root.Val <= min.Val{
        return false
    }
		// max 最小值不为空，root的值，如果比最大值还大，说明root节点不满足 BST性质
    if max != nil && root.Val >= max.Val {
        return false
    }
    // 左子树的最大值就是root节点
  	// 右子树的最小值就是root节点
    return isValid(root.Left,min,root) && isValid(root.Right,root,max)
}
```



## 221. 最大正方形

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

思路：

动态规划：

- `dp[i][j] `表示 `matrix[i][j]`为正方形右下角的**边长**，上边，左边，左上的边长 `>1`，才能组成一个更大完整的正方形；

- 递推关系：

  如果`matrx[i][j] == 0`，说明无法组成只包含 `'1'` 的正方形，`dp[i][j] = 0`即边长为`0`

  如果 `matrx[i][j] == 1`，看下上边，左边，左上 边长 `> 1`，才能组成一个更大的正方形，所以 `dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1`

![image-20241230185928924](./images/image-20241230185928924.png)

```java
func maximalSquare(matrix [][]byte) int {
	m, n := len(matrix), len(matrix[0])
  // 定义 边长 dp 数组
	dp := make([][]int, m)
	for k, _ := range dp {
		dp[k] = make([]int, n)
	}
	// 最大边长
	length := 0

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			// base case
			if i == 0 || j == 0 { // 第一行 or 第一列
				dp[i][j] = int(matrix[i][j] - '0')
			} else {

				if matrix[i][j] == '1' { // 当等于1的时候，才能作为正方形的右下角，求取长度
					dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1
				}
			}
			// 题目要求最大正方形，这里记录最大边长 length
			if dp[i][j] > length {
				length = dp[i][j]
			}
		}
	}
	// 边长*边长 = 正方形面积
	return length * length
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```



## 34. 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

思路：

二分搜索的难点就在于如何搜索左侧边界和右侧边界，代码的边界的控制非常考验你的微操，这也是很多人知道二分搜索原理但是很难写对代码的原因。写对二分搜索的关键在于搞清楚搜索边界，到底应该往左侧收敛还是应该往右侧收敛？

![image-20241231174802185](./images/image-20241231174802185.png)

![image-20241231174831359](./images/image-20241231174831359.png)

```java
func searchRange(nums []int, target int) []int {

    return []int{left_bound(nums,target),right_bound(nums,target)}
}

// 求左边界
func left_bound(nums []int ,target int) int {

    left,right := 0,len(nums)-1
		// 闭区间[left,right]
    for left <= right {
				// 中间值
        mid := left + (right-left)/2

        if nums[mid] == target { // 相等的时候，收缩right；【因为我们要求的是左边界】
            right = mid -1
        } else if nums[mid] > target { // 说明 target值位于nums[mid]的左侧，收缩right
            right = mid -1
        } else if nums[mid] < target { // 说明 target 位于 nums[mid]的右侧，收缩left
            left = mid + 1
        }
    }
    
    // 当所有的值都比target小的时候，left会越界
    // 当所有的值都比target大的时候，left此时是不会移动，所以要看下left指向的值是否是target
    if left >= len(nums) || nums[left] != target { // 做边界检测
        return -1
    }
    return left
}

// 求右边界
func right_bound(nums []int ,target int) int {

    left,right := 0,len(nums)-1

    for left <= right {
				// 中间值
        mid := left + (right-left)/2

        if nums[mid] == target { // 求右边界，当相等的时候，收缩左边界
            left = mid + 1
        } else if nums[mid] > target { // 说明 target值位于nums[mid]的左侧，收缩right
            right = mid - 1
        } else if nums[mid] < target { // 说明 target 位于 nums[mid]的右侧，收缩left
            left = mid + 1
        }
    }
    
    // 当所有的数都大于target的时候，right就会一直-1，最后会越界
    // 当所有的数都小于target的时候，right保持不动；所以要看下right指向的值是否是target
    if right < 0 || nums[right] != target { // 做边界检测
        return -1
    }
    return right
}
```



## 394. 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

思路：

首先要理解题目的意思：比如`3[a]`解码的结果为`aaa`。 `3`表示 `a`重复的次数。这题如果第一次做，还是挺难，一般遇到字符串带括号的问题，就要想到**栈**。利用栈记录上次的解码结果

这里以 `a6[c]`为例子演示一下：

![image-20241231185903633](./images/image-20241231185903633.png)

- 从左到右遍历字符串， `curStr`和`curNum` 记录当前的字符串和数值
- 遇到`[ `入栈当前的`curStr`和`curNum`（目的是为了存储上次的结果）同时清空当前`curStr`和`curNum`（目的是为了复用`curStr`和`curNum`用于 `[待处理字符串]` 之间的编码字符串）
- 遇到`] `出栈 ，出栈的字符串（前一个字符串） + 出栈的`num`（表示重复的次数）值和当前的`curStr`组合 = 形成新的字符串，保存到 `curStr`中

```java
func decodeString(s string) string {
   
    curStr,strStack := "",[]string{} // curStr 当前字符串
    curNum,numStack := 0,[]int{} // curNum 当前的数值

    for _,v := range s {
        if v >= '0' && v <= '9' { // 当前的curNum
            curNum = curNum * 10 + int(v-'0')
        } else if v == '[' { // 入栈，记录下当前的curNum和curStr
            strStack = append(strStack,curStr)
            numStack = append(numStack,curNum)
						// 清空
            curStr = ""
            curNum = 0

        } else if v == ']' { //出栈，上次记录下来的curNum和curStr,目的是为了展开[]之间的字符串


            preStr := strStack[len(strStack)-1]
            preNum := numStack[len(numStack)-1] 

            // 例如：a2[c] , preStr = a   preNum = 2   curStr = c，结果为 a+cc = acc
            curStr = preStr + strings.Repeat(curStr,preNum) // 这里对curStr进行重复preNum次
						// 出栈
            strStack = strStack[:len(strStack)-1]
            numStack = numStack[:len(numStack)-1]

        }else { // 当前的curStr
            curStr += string(v)
        }
    }
		// curStr中记录这最终的解码结果
    return curStr
}
```



## 240. 搜索二维矩阵II

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

![image-20241231191629942](./images/image-20241231191629942.png)

思路：

这道题说 `matrix` 从上到下递增，从左到右递增，显然左上角是最小元素，右下角是最大元素。**我们如果想高效在 `matrix` 中搜索一个元素，肯定需要从某个角开始**，比如说从左上角开始，然后每次只能向右或向下移动，不要走回头路。

如果真从左上角开始的话，就会发现无论向右还是向下走，元素都会增加，那么到底向右还是向下？不确定

但实际上不用这么麻烦，我们不要从左上角开始，而是从右上角开始，规定只能向左或向下移动。

你注意，如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话我们就可以根据当前的元素值和 `target` 的相对大小来判断应该往哪移动，不断接近从而找到 `target` 的位置。

当然，如果你想从左下角开始，规定只能向右或向上移动也可以

```java
func searchMatrix(matrix [][]int, target int) bool {
    // 一般思路：直接遍历二维矩阵；但是并没有很好的利用，每一行和每一列的元素都是有序的这个条件；
    // 进阶思路：那么如果从【左上角】开始比较，当target大于左上角的数值的时候，有两个选择，【向右】或【向下】,不确定？？
    // 那么如果从【右上角】开始比较，当15 > target的时候，说明target比较小，那么只能向左查找，因为如果向下，元素值更大，不符合题意，也就是此时只会有一种选择

    m := len(matrix)
    n := len(matrix[0])
		// 右上角
    i := 0
    j := n-1

    for i < m && j >= 0 {
        if matrix[i][j] == target {
            return true
        } else if matrix[i][j] > target { // 向左移动,找更小值
            j--
        } else if matrix[i][j] < target { // 向下移动，找更大值
            i++
        }
    }

    return false
}
```



## 64.最小路径和

给定一个包含非负整数的 `m x n` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

思路：

一般来说，让你在二维矩阵中求最优化问题（最大值或者最小值），就要考虑动态规划。先定义 `dp`数组，然后寻找相邻`dp[i] dp[i-1]`之间的关系。

- `dp`数组定义：从`[0,0]`到 `[i,j]`的最小路径和为 `dp[i][j]`

- 递推关系：因为题目说：每次只能向下或者向右移动一步。

  那么到达 `[i,j]`位置有两种选择

  从`[i-1,j]`向下移动一步 

  从`[i,j-1]`向右移动一步

![image-20250101154359751](./images/image-20250101154359751.png)

`dp[i][j-1]`表示 从`[0,0]`到 `[i,j-1]`的最小路径和

`dp[i-1][j]`表示 从`[0,0]`到 `[i-1,j]`的最小路径和

取两个中的`min`最小值 `+ grid[i][j]` 即为从`[0,0]`到 `[i,j]`的最小路径和

```java
func minPathSum(grid [][]int) int {
  
    m := len(grid)
    n := len(grid[0])
		// 定义 dp 数组
    dp := make([][]int,m)
    for k := range dp {
        dp[k] = make([]int,n)
    }
   
    for i := 0;i < m;i++ {
        for j := 0;j < n;j++ {
            if i == 0 && j >= 1 { //base case 第一行：只能从左往右，所以第一行就是累加
                dp[i][j] = dp[i][j-1] + grid[i][j]
            } else if j == 0 && i >= 1 { // base case 第一列：只能从上往下，所以第一列就是累加
            1     dp[i][j] = dp[i-1][j] + grid[i][j]
            } else if i == 0 && j == 0 {//base case 左上角第一个元素
                dp[0][0] = grid[0][0]
            } else { // 从i=1 && j=1 开始符合递推公式
                dp[i][j] = min(dp[i-1][j],dp[i][j-1])+ grid[i][j]
            }
        }
    }
  	// 最后返回,从 [0,0] 到 [m-1,n-1] 的最小路径和
    return dp[m-1][n-1]
}

func min(a,b int)int{
    if a < b {
        return a
    }
    return b
}
```



## 113. 路径总和II

给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。

**叶子节点** 是指没有子节点的节点。

思路：

二叉树题型，就是递归遍历题型。只是在遍历的过程的中要对数据进行相关处理，处理的位置有讲究，要么前序位置，要么中序位置，要么后序位置。

```java
var result [][]int
func pathSum(root *TreeNode, targetSum int) [][]int {
		// 最终结果存储
    result = [][]int{}
  	// 记录路径
    trace := []int{}
  	// 二叉树遍历
    traverse(root,trace,targetSum,0)
    return result
}

// traverse函数定义： 遍历 root 树，找出目标路径和
func traverse( root *TreeNode, trace []int,targetSum int,sum int) {
    if root == nil {
        return
    }
		// 前序位置，记录路径和
    trace = append(trace,root.Val) 
    sum += root.Val

    if root.Left == nil && root.Right == nil {//表示root是叶子节点（不存在左右子树）
        if sum == targetSum { // 路径和sum 等于 targetSum，找到一个结果
            temp := make([]int,len(trace))
            copy(temp,trace)
            result = append(result,temp)
        }
        return
    }
		// 继续左树遍历
    traverse(root.Left,trace,targetSum,sum)
  	// 继续右树遍历
    traverse(root.Right,trace,targetSum,sum)
}
```



## 14. 最长公共前缀

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。

思路：

这个题没什么难度，你把字符串列表看成一个二维数组，然后用一个嵌套 `for` 循环计算这个二维数组前面有多少列的元素完全相同即可。

```java
func longestCommonPrefix(strs []string) string {
  	
  	m,n := len(strs),len(strs[0]) // m行 n列	( 拿第一个字符串作为对比标准（其他的字符串都和他比较）)
		
    for col := 0; col < n; col++ { // col列
        for row := 1;row < m;row++ { // row行
            if col >= len(strs[row]) || strs[row][col] != strs[0][col] { // col的索引位置，不能超过，每个字符串的长度
                //说明col位置，就是出现不同的位置，不能包括
                return string(strs[0][:col])
            }
        }
    }
		// 第一个字符串就是最长的公共前缀
    return strs[0]
}
```



## 128. 最长连续序列

给定一个未排序的整数数组 `nums` ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。请你设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

思路：

这道题最直接的想法就是排序，排序之后连续的序列就很容易找到了。不过排序的时间复杂度是 `O(NlogN)`，而题目要求我们时间复杂度为 `O(N)`，这就得另想办法了。

想找连续序列，首先要找到这个连续序列的开头元素，然后递增，看看之后有多少个元素还在 `nums` 中，即可得到最长连续序列的长度了。可以用空间换时间的思路，把数组元素放到哈希集合里面，然后去寻找连续序列的第一个元素，即可在 `O(N)` 时间找到答案。

这里有疑问，为什么要找连续序列**开头的元素**，然后记录长度？

比方说 `nums = [8,4,9,1,3,2]`，我们先找到 1，然后递增，找到了 2, 3, 4，这就是一个长度为 4 的序列。

如果，先找到2，然后递增，找到 3,4 ，这是一个长度为3的序列。肯定是没有上面的从1 开始的长度长的，也就是干了无效的长度计数。所以，要找开头的元素，再来计数，才有实际意义。

再比如，又找到 8，往上递增找到了 9，这是一个长度为 2 的序列。 8 就是连续序列开头的元素（因为没有比8更小的数字7），这是一个有意的结果。

```java
func longestConsecutive(nums []int) int {

    //1. 先遍历nums数组放入到map中
    m := make(map[int]struct{})
    for i :=0;i < len(nums);i++ {
        m[nums[i]] = struct{}{}
    }

    result := 0
    //2.遍历map，判断元素是否【数字连续】的开头元素，不是则跳过。是的话，就对元素+1，看连续序列的下一个元素在map中是否存在，记录序列长度；

    for k,_ := range m {
      
      	// 通过 k-1的方式，判断有没有前置元素（也就是k是不是【开头元素】）
      	// 比如[100,4,200,1,3,2],假如k=3,k-1=2,有前置的元素2，说明k=3不是数字连续的开头元素，跳过
        if _,ok := m[k-1];!ok { //!ok 说明是第一个
          
            //说明k是数字连续的第一个元素
            maxLen := 1
            
            for {
                k++ //判断连续的下一个元素是否存在
                if _,ok := m[k];!ok {// 不存在
                    break
                }else { //存在
                    maxLen++
                }
            }
						// 记录最大长度
            result = max(result,maxLen)
        }
    }
		// 返回结果
    return result
}

func max(a,b int)int{
    if a > b{
        return a
    }
    return b
}
```



## 112. 路径总和

给你二叉树的根节点 `root` 和一个表示目标和的整数 `targetSum` 。判断该树中是否存在 **根节点到叶子节点** 的路径，这条路径上所有节点值相加等于目标和 `targetSum` 。如果存在，返回 `true` ；否则，返回 `false` 。

**叶子节点** 是指没有子节点的节点。

思路：

这题和上面的 **113. 路径总和II**类似的，只是本题只需要找到一个满足的路径即可（而且也不用记录下来路径值）

```java

func hasPathSum(root *TreeNode, targetSum int) bool {
    return PathSum(root,targetSum,0)
}

// PathSum函数定义： root树是否存在从根节点到叶子节点的路径和 等于 targetSum
func PathSum(root *TreeNode,targetSum int,sum int) bool {
  	// root 为nil，不存在
    if root == nil {
        return false
    }
  	// 前序位置，累加路径和
    sum += root.Val
    if root.Left == nil && root.Right == nil { // 说明 root 是叶子节点
        
        if sum == targetSum { // 找到路径和
            return true
        }
        return false
    }
		// 判断左子树 或者 右子树 是有有满足的路径和（注意：是或的关系，并不需要同时满足）
    return PathSum(root.Left,targetSum,sum) || PathSum(root.Right,targetSum,sum)
}


```



## 662. 二叉树最大宽度

给你一棵二叉树的根节点 `root` ，返回树的 **最大宽度** 。树的 **最大宽度** 是所有层中最大的 **宽度** 。

每一层的 **宽度** 被定义为该层最左和最右的非空节点（即，两个端点）之间的长度。将这个二叉树视作与满二叉树结构相同，两端点间会出现一些延伸到这一层的 `null` 节点，这些 `null` 节点也计入长度。

题目数据保证答案将会在 **32 位** 带符号整数范围内。

思路：

这题是层序遍历的一个应用。我们需要给节点编号，每一层的最左边节点和最右边节点编号的【差值】，即为该层的宽度。题目要求最大宽度，那用一个变量`result`记录下来最值即可。

```java

func widthOfBinaryTree(root *TreeNode) int {
    ///！！！层序遍历：每一层的最右边节点编号 - 最左边节点的编号 + 1 ，表示当前层的宽度
    if root == nil {
        return 0
    }
    type pair struct { //用来记录节点和节点编号
        node *TreeNode
        uid int
    }
  	
    q := []*pair{}
  	// 从根节点root开始，编号为 1
    q = append(q,&pair{root,1})
    result := 0
    leftId, rightId := 0,0 //每一层的最左和最右节点编号
    for len(q) != 0 {
        size := len(q)

        for i := 0;i < size;i++ {
            if i == 0 {
                leftId = q[i].uid //最左边节点
            }
            if i == size-1 { //最右边节点
                rightId = q[i].uid
            }

            //判断左节点是否存在
            if q[i].node.Left != nil {
                q = append(q,&pair{q[i].node.Left,2 * q[i].uid}) //编号为 2*uid
            }
            //判断右节点是否存在
            if q[i].node.Right != nil {
                q = append(q,&pair{q[i].node.Right,2 * q[i].uid + 1}) //编号为 2*uid+1
            }
        }
        ///去掉q头部的size个元素
        q = q[size:]
				// rightId-leftId+1 计算本层宽度， result记录所有层的最大值
        result = max(result,rightId-leftId+1)
    }
    return result
}

func max ( a, b int) int{
    if a > b {
        return a
    }
    return b
}
```



## 695. 岛屿的最大面积

给你一个大小为 `m x n` 的二进制矩阵 `grid` 。

**岛屿** 是由一些相邻的 `1` (代表土地) 构成的组合，这里的「相邻」要求两个 `1` 必须在 **水平或者竖直的四个方向上** 相邻。你可以假设 `grid` 的四个边缘都被 `0`（代表水）包围着。

岛屿的面积是岛上值为 `1` 的单元格的数目。

计算并返回 `grid` 中最大的岛屿面积。如果没有岛屿，则返回面积为 `0` 。

思路：

这题和 **200.岛屿数量**，类似的题目。计算岛屿面积，其实就是在计算相邻的`1`的个数。采用深度遍历`DFS`的方式淹没岛屿的同时，还应该想办法记录这个岛屿的面积。

这里通过形参 `val *int`记录面积

```java
func maxAreaOfIsland(grid [][]int) int {
	m, n := len(grid), len(grid[0])

	maxVal := 0
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if grid[i][j] == 1 { // 找到陆地
				val := 0 // 累计陆地的面积
				dfs(grid, i, j, &val) 
       	// 记录最大值
				maxVal = max(maxVal, val)
			}
		}
	}
	return maxVal
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}

func dfs(grid [][]int, i, j int, val *int) {
	m := len(grid)
	n := len(grid[0])

	if i < 0 || i >= m || j < 0 || j >= n { //越界
		return
	}
	
	if grid[i][j] == 0 { // 当前是水面
		return
	}
	// 执行到这里，说明是陆地
	(*val)++ //累计面积
	grid[i][j] = 0	// 淹没陆地（避免了重复计算）
	
 	// 向周围扩散（看下周围还有没有陆地）
	dfs(grid, i+1, j, val)
	dfs(grid, i-1, j, val)
	dfs(grid, i, j+1, val)
	dfs(grid, i, j-1, val)
}
```



## 234. 回文链表

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

思路：

![image-20250101190736163](./images/image-20250101190736163.png)

如果 `fast != nil`，说明节点个数为**奇数**，`slow`还需要再移动一步

![image-20250101190643412](./images/image-20250101190643412.png)

从 `slow` 开始反转后面的链表，现在就可以开始比较回文串了：

![image-20250101191127092](./images/image-20250101191127092.png)

```java

func isPalindrome(head *ListNode) bool {
    //1.先找到链表的中点
   
    fast,slow := head,head

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    if fast != nil { //说明节点数为奇数个
        slow = slow.Next
    }
		
  	// left 链表
    left := head
  	// right 链表
    right := reverse(slow)

    for right != nil {
        if right.Val != left.Val { // 值不相同，不是回文
            return false
        }
        right = right.Next
        left = left.Next
    }
    return true
}

//翻转链表（递归方式） reverse函数定义：反转root链表，并返回反转后的头节点
func reverse(root *ListNode) *ListNode {
    if root == nil || root.Next == nil {
        return root
    }
  
    head := reverse(root.Next) 
    root.Next.Next = root 
    root.Next = nil
    return head
}

//翻转链表（迭代方式）
func reverse1(root *ListNode) *ListNode {
    cur := root
    var pre *ListNode = nil
    for cur != nil {
        temp := cur.Next //记录下一个节点
        cur.Next = pre //指向pre
        pre = cur //当前cur变成了pre一个了
        cur = temp //继续下一个节点
    }
    return pre
}
```



## 122. 买卖股票的最佳时机II

给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。

在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。

返回 *你能获得的 **最大** 利润* 。

思路：

买卖股票类的题目有一套**通用的解题方案**：

- `dp`数组定义：

> `dp[i][k][0 or 1]` 
>
> `0 <= i <= n - 1, 1 <= k <= K`      
>
> n 为天数，大 K 为完成交易数的上限，0 和 1 代表是否持有股票

所以，`dp[i][k][0 or 1]` 的含义就是：在从 `0`到 `i`天，完成了`k`笔交易，不持有`0` or 持有 `1`股票，能获取的最大利润

- `dp`的递推关系定义：

```java
dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
//dp[i][k][0] 表示 从 0 到 第i天，完成k笔交易，不持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][0] 								表示 从 0 到i-1天（也就是前一天），也没有持有股票
// dp[i-1][k][1] + prices[i]  	表示 从 0 到i-1天（也就是前一天），持有了股票，但是今天选择卖出，那么今天不就不持有股票了


dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
// dp[i][k][1]  表示从 0 到第i天，完成k笔交易，持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][1] 							 	表示从 0 到 i-1天（也就是前一天），也持有股票
// dp[i-1][k-1][0] - prices[i] 	表示从 0 到 i-1天（也就是前一天），未持有了股票，但是今天选择买入，那么不就持有股票了。因为是今天买入股票，完成了一笔交易，今天的交易次数是k的前提下，那么前一天的交易次数就是 k-1


最终答案：因为要求最大利润，那只有不持有股票的利润最大 dp[n-1][k][0] （从 0到 n-1，完成了k笔交易后，不持有股票）
```

本题答案：

注意：本题是每一天都可以进行交易（可以完成无数次交易 ）。而 121题只能在某一天交易，另外一天卖出（也就是只能完成一次交易）

- 对于本题，去掉`k`这个限定，因为可以进行无数次（没有交易次数上限）

- 最终的地推关系为：

  ```java
  dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
  dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
  ```

最终题解为：

```java
func maxProfit(prices []int) int {

    n := len(prices)

    dp := make([][]int,n) // 构造dp数组
    for k,_ := range dp {
        dp[k] = make([]int,2)
    }

    for i := 0;i < len(prices);i++ {
				
        if i-1 < 0 { // base case
            dp[i][0] = 0
            dp[i][1] = -prices[i]
        } else { // 一般递推关系
            dp[i][0] = max(dp[i-1][0],dp[i-1][1] + prices[i])
            dp[i][1] = max(dp[i-1][1],dp[i-1][0] - prices[i])
        }
    }
		// 在第 n-1天不持有股票的最大利润
    return dp[n-1][0]
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```



## 152. 乘积最大子数组

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

思路：

这题和最大子数组和类似（只需要定义最大子数组和），但是本题需要定义最大子数组乘积和最小子数组乘积。

- `dpMax`数组定义：以`i`为结尾的最大乘积
- `dpMin`数组定义：以`i`为结尾的最小乘积

![image-20250102173410157](./images/image-20250102173410157.png)

![image-20250102173644075](./images/image-20250102173644075.png)

因为当前`nums`是`-3`,乘上一个正数 `2`，只会让结果更小。那如果乘上的是个负数呢？负负得正，那结果不就是变大了。那就要想到负数肯定不是一个最大值，那就是一个最小值。所以额外定义一个最小值的数组乘积

![image-20250102174753394](./images/image-20250102174753394.png)

```java
func maxProduct(nums []int) int {
  
		// 定义 dp 数组
    dpMax := make([]int,len(nums))
    dpMin := make([]int,len(nums))


    for i := 0;i < len(nums);i++ { //每个元素值（就是一个子数组），就是初始值
        dpMax[i] = nums[i]
        dpMin[i] = nums[i]
    }

    
    for i := 1;i < len(nums);i++ {
      	// 用 nums[i] * 前一个最大or最小子数组乘积
        maxVal := nums[i]*dpMax[i-1]
        minVal := nums[i]*dpMin[i-1]
      	// 取最大值作为 dpMax
        dpMax[i] = max(dpMax[i], maxVal,minVal )
      	// 取最小值作为 dpMin
        dpMin[i] = min(dpMin[i], maxVal,minVal)
    }
    
    res := math.MinInt
		// 再遍历一遍，dpMax数组，找出最值，返回
    for i := 0;i < len(dpMax);i++ {
        res = max1(res,dpMax[i])
    }
    return res
}

func max1(a,b int) int{
    if a > b{
        return a
    }
    return b
}

func max(a,b ,c int) int{
    if a < b{
        a = b
    }
    if a > c {
        return a
    }
    return c
}

func min(a,b,c int) int{
    if a > b{
        a = b
    }

    if a > c {
        return c
    }
    return a
}
```



## 179. 最大数

给定一组非负整数 `nums`，重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数。

**注意：**输出结果可能非常大，所以你需要返回一个字符串而不是整数。

思路：

```java
func largestNumber(nums []int) string {
    // 这题的思路就是排序：按照相邻的两个数字，希望组成最大的数值，比如 3和30；可以组成330和303，符合题目的结果为330；

    // 1.先将int转成字符串保存起来
    strSlice := make([]string,len(nums),len(nums))

    for k, v := range nums {
        strSlice[k] = strconv.Itoa(v)
    }

    // 2.然后对字符串数组排序
    sort.Slice(strSlice,func(i,j int)bool {
      
        // 比如3和30，那就拼接为：330和303 进行比较
        return strSlice[i] + strSlice[j] > strSlice[j] + strSlice[j]
    })

    // 3.corner case 如果数组中都是0，特殊情况的首字符，是0

    if strSlice[0][0] == '0' {
        return "0"
    }

    return strings.Join(strSlice,"")
}
```



## 169. 多数元素

给定一个大小为 `n` 的数组 `nums` ，返回其中的多数元素。多数元素是指在数组中出现次数 **大于** `⌊ n/2 ⌋` 的元素。

你可以假设数组是非空的，并且给定的数组总是存在多数元素。

思路：

这道题的标准解法肯定是用一个哈希表作为计数器记录每个元素出现的次数，然后寻找出现次数最多的那个元素，时间和空间复杂度都是 `O(N)`。

但是由于题目说了这个目标元素（众数）出现的次数**过半**，这就有意思了，其实我们不需要用哈希表来做计数器就能把这个众数找出来。

比方说一群带正电的粒子和一群带负电的粒子，把它们混合起来，得到的这群混合粒子的带电性质是什么？这取决于正电离子多还是负电离子多，如果正负粒子数量恰好相等，则呈电中性。

回到这道题，题目告诉你一定存在一个众数，它出现的次数过半，那么如果你把这个众数元素想象成正电粒子，其他的所有元素都想象成负电粒子，那么它们混合起来会怎样？

**在正负粒子混合的过程中，整体的带电性可能在正负间波动，但最终的结果一定是正电**。

```java
func majorityElement(nums []int) int {
	
	target := 0
	count := 0 // 这里的count可以想象【电子容器】的电性是中性的
	for i := 0; i < len(nums); i++ {
		if count == 0 {
			target = nums[i] // count = 0 表示中性的，将 nums[i] 作为第一个电子，放到容器中
			count++ // 容器电性+1
		} else if target == nums[i] { //发现了target电子相同，电性++
			count++
		} else { //否则电性--
			count--
		}
	}
	return target
}


```



## 62. 不同路径

一个机器人位于一个 `m x n` 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

思路：

本题和**64.最小路径和**这题有类似之处，都是只能向下、向右移动，一个是计算路径数，一个是计算最小路径。所以，我们只需要修改下 `dp`数组的定义即可。

![image-20250103175323235](./images/image-20250103175323235.png)

```java
func uniquePaths(m int, n int) int {
   
		// 定义 dp 数组
    dp := make([][]int,m)
    for i := 0;i < m;i++ {
        dp[i] = make([]int,n)
    }


    for i := 0;i < m;i++ {
        for j := 0;j < n;j++ {
            if i == 0 { // base case 第一行 因为只能向右移动
                dp[i][j] = 1
            } else if j == 0 { //base case  第一列 因为只能向下移动
                dp[i][j] = 1
            } else { // 递推关系
                dp[i][j] = dp[i-1][j] + dp[i][j-1]
            }
        }
    }
  	// 最终位置[m-1,n-1]
    return dp[m-1][n-1]
}
```



## 227. 基本计算器II

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。整数除法仅保留整数部分。你可以假设给定的表达式总是有效的。所有中间结果将在 `[-231, 231 - 1]` 的范围内。

**注意：**不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

思路：

第一次做，这题挺难想到，利用栈，模拟计算过程（一回生二回熟，多看几次就记住了）

- 利用两个栈实现，一个存储数值，一个存储符号
- 遇到数值直接入栈
- 遇到符号：需要判断（在栈不为空的情况下），当前符号优先级 <= 栈顶符号优先级（**也就是栈中的符号的优先级比较高**）
- 那么，出栈两个数值，和出栈一个符号，计算结果，把结果存入【栈中】
- 继续比较，是否符合（当前符号优先级 <= 栈顶（且栈不为空）），否则符号直接入栈；

```java
func calculate(s string) int {
    
		// 两个栈
    operands := make([]int,0) //操作数
    operators := make([]byte,0)//操作符
    var result int
  	// index 作为索引，用来遍历每一个字符
    index := 0
    for index < len(s) {
        if isDigit(s[index]) { //判断字符是否是数字
          	// 连续取出多个字符，作为一个完整的整数
            digit := 0
            for index < len(s) && isDigit(s[index]) {
                digit = 10*digit + int((s[index]-'0'))
                index++
            }
          	// 保存到栈中
            operands = append(operands,digit)
        } else if s[index] == ' ' { //空格，跳过
            index++
        } else {
          	// operators 栈不为空，并且栈顶的符号优先级高（先计算栈中的符号）
            for len(operators) != 0 && priority(operators[len(operators)-1],s[index] ) { //栈顶优先级 >= s[i]
                //出栈并运算 -- 运算完成后，继续看下一个操作符号
                if operators[len(operators)-1] == '+' {
                    result =  operands[len(operands)-2] + operands[len(operands)-1]
                }else if operators[len(operators)-1] == '-' {
                    result =  operands[len(operands)-2] - operands[len(operands)-1]
                }else if operators[len(operators)-1] == '*' {
                    result =  operands[len(operands)-2] * operands[len(operands)-1]
                }else if operators[len(operators)-1] == '/' {
                    result =  operands[len(operands)-2] / operands[len(operands)-1]
                }
               
               //出栈数值
               operands = operands[:len(operands)-2]
               operands = append(operands,result) //入栈result结果
               //出栈符号
               operators = operators[:len(operators)-1]
            }

            //直到操作符号为空，或者，不满足优先级关系，入栈操作符
            operators = append(operators,s[index])
            index++ //继续下一个字符
        }
    }
  
  	//如果还有运算符号，说明还需要做最后的运算
    for len(operators) != 0  { 
        //出栈并运算
        if operators[len(operators)-1] == '+' {
            result =  operands[len(operands)-2] + operands[len(operands)-1]
        }else if operators[len(operators)-1] == '-' {
            result =  operands[len(operands)-2] - operands[len(operands)-1]
        }else if operators[len(operators)-1] == '*' {
            result =  operands[len(operands)-2] * operands[len(operands)-1]
        }else if operators[len(operators)-1] == '/' {
            result =  operands[len(operands)-2] / operands[len(operands)-1]
        }
        
        //出栈数值
        operands = operands[:len(operands)-2]
        operands = append(operands,result) //入栈result结果
        //出栈符号
        operators = operators[:len(operators)-1]
    }
    // 最后operands栈中保存的就是结果
    return operands[0]
}

func priority( a, b byte) bool {
    if a == '*' || a == '/' {
        return true
    } else if b == '+' || b== '-' {
        return true
    }
    return false
}

func isDigit( c byte)bool{
    if c >= '0' && c <= '9' {
        return true
    }
    return false
}
```



## 718. 最长重复子数组

给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。

思路：

- `dp`数组定义：`dp[i][j] ` 表示必须以 `i`结尾的子数组和 必须以`j`结尾子数组的公共长度（注意："必须"的含义）

- 递推关系：

  如果`nums1[i] == nums2[j]`，表示两个子数组结尾的数值相同   `dp[i][j] = dp[i-1][j-1] + 1`

  如果 `nums1[i] != nums2[j]`，表示两个子数组结尾的数值不相同，也就是说必须以 `i`结尾的子数组和 必须以`j`结尾子数组的公共长度为`0`

![image-20250104172901913](./images/image-20250104172901913.png)

```java
func findLength(nums1 []int, nums2 []int) int {
    // dp 数组定义
    m,n := len(nums1),len(nums2)
    dp := make([][]int,m)
    for k,_ := range dp {
        dp[k] = make([]int,n)
    }

    result := 0
    for i := 0;i < m;i++ {
        for j := 0;j< n;j++ {
            if  i == 0  ||  j == 0 { // base case 当i子数组只有一个元素 or j子数组只有一个元素
                if nums1[i] == nums2[j] {
                    dp[i][j] = 1
                }
            } else if nums1[i] == nums2[j] { // 一般递推关系
                dp[i][j] = dp[i-1][j-1] + 1
            }
						// 题目要求最大长度，dp[i][j]只是记录的每一个的子数组的公共长度
            if dp[i][j] > result {
                result = dp[i][j]
            }
        }
    }
    return result
}
```



## 198. 打家劫舍

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警**。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **不触动警报装置的情况下** ，一夜之内能够偷窃到的最高金额。

思路：

![image-20250104182315955](./images/image-20250104182315955.png)

在每间房子前都有两种**选择**：抢或者不抢。

在`i`位置处，我们如果不偷窃，`dp[i] = dp[i-1]`

在`i`位置处，如果偷，`dp[i] = dp[i-2] + nums[i]`

所以，我们的最大金额为： `dp[i] = max(dp[i-1],dp[i-2]+nums[i])`

![image-20250104183052679](./images/image-20250104183052679.png)

```java
func rob(nums []int) int {
   
		// 定义 dp 数组
    dp := make([]int ,len(nums))
   
    for i := 0; i < len(nums);i++ {
        if i == 0 { // base case 只有一个房间
            dp[i] = nums[0]
        } else if i == 1 { // base 有两个房间
            dp[i] = max(nums[0],nums[1])
        } else { // 一般递推关系
            dp[i] = max(dp[i-1],nums[i]+ dp[i-2])
        }
    }
  	// 最后， dp[len(nums)-1] 表示从[0...len(nums)-1]能偷窃的最大金额（不理解的话，看下dp数组的定义）
    return dp[len(nums)-1]
}

func max(a,b int) int{
    if a > b {
        return a
    }
    return b
}
```



## 83. 删除排序链表中的重复元素

给定一个已排序的链表的头 `head` ， *删除所有重复的元素，使每个元素只出现一次* 。返回 *已排序的链表* 。

思路：

```java
func deleteDuplicates(head *ListNode) *ListNode {

    p := head
    
    for head != nil {
      	// 固定left
        left := head
				// 让 head 移动，保证 [left,head]之间的元素相同
        for head.Next != nil && left.Val == head.Next.Val {
            head = head.Next
        }

        // [left,head] 就是重复的元素，保留一个
        if left != head {
            left.Next = head.Next
        }
        head = head.Next // 同时 head 指向新的一轮链表的起始位置
    }
    return p
}
```

![image-20250105174444287](./images/image-20250105174444287.png)

![image-20250105174659137](./images/image-20250105174659137.png)



## 226. 翻转二叉树

给你一棵二叉树的根节点 `root` ，翻转这棵二叉树，并返回其根节点。

思路：

这题和**101. 对称二叉树**可以对比看下，都是前序位置进行处理。二叉树的处理，既要以`root`树的整体角度思考，也要从具体的一个`root`节点思考。

如何翻转二叉树？其实就是把二叉树上的每个节点的左右子节点都交换一下

```java
// invertTree函数定义：翻转root二叉树
func invertTree(root *TreeNode) *TreeNode {
    if root == nil {
        return root
    }

    //对root节点，左右子节点交换
    root.Left,root.Right = root.Right,root.Left
  	// 翻转root.Left左树
    invertTree(root.Left)
  	// 翻转root.Right右树
    invertTree(root.Right)
    return root
}

```



## 139. 单词拆分

给你一个字符串 `s` 和一个字符串列表 `wordDict` 作为字典。如果可以利用字典中出现的一个或多个单词拼接出 `s` 则返回 `true`。

**注意：**不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

思路：

动态规划

![image-20250105192822494](/Users/mac/algorithm-go/images/image-20250105192822494.png)

这里其实有两个字符串`apple 和 pen`供选择。

如果选择 `apple`那么 `dp[i]`的组成就取决于`dp[i-5]`

如果选择 `pen`那么 `dp[i]`的组成就取决于`dp[i-3]`

这两种情况只要有一个满足即可，所以`dp[i]`需要用 `||`来综合`dp[i-5] dp[i-3]`的结果。

很显然，这里只有 `apple`和`applepenapple`尾部匹配

下图演示了，取`apple`的情况下，能否组成的结果，保存到 `dp[i] `中

![image-20250105192858989](./images/image-20250105192858989.png)

![image-20250105193443993](./images/image-20250105193443993.png)

![image-20250105193506986](./images/image-20250105193506986.png)

`dp[i] = dp[i] || dp[i-len(word)] ` 这个如果不理解，可以看下这个范例：

比如字符串`dogs` 和字符串列表` [dog,gs,s]`

能和`dogs`尾部匹配的字符串，包括 `gs 和 s`两种情况

- 如果选择`gs`，那么`dp[i]`的结果就取决于`dp[i-2]`，` dp[i] = dp[i] || dp[i-2]` 将结果保存到 `dp[i]`中
- 如果选择`s`，那么`dp[i]`的结果就取决于`dp[i-1]`，` dp[i] = dp[i] || dp[i-1]` 将结果保存到 `dp[i]`中

所以`dp[i]`得最终结果就取决于`dp[i-2] 或者 dp[i-1]`。

```java
func wordBreak(s string, wordDict []string) bool {

    // 定义 dp[i] 表示 [0...i] 能否用字符串列表wordDict拼接出来
    dp := make([]bool,len(s))

    for i := 0; i < len(s);i++ {
			
        for _,word := range wordDict {
            // 字符串长度 >= word 并且 尾部的字符串和 word相等
            if i + 1 >= len(word) && s[i+1-len(word):i+1] == word {
             	 if i - len(word) >= 0 { //没有越界，需要考虑前面的结果dp[i-len(word)]
                     dp[i] = dp[i] || dp[i-len(word)] // 这里用 || 表示要综合考虑字符串尾部，和wordDict的多个字符串都匹配的时候的结果。
                } else {
                    dp[i] = true // 如果越界，说明正好匹配完成
                } 
            }
        }
    }
    return dp[len(s)-1]
}
```



## 209. 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 **子数组**`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

思路：

- 要先理解子数组的含义：**子数组** **是数组中连续的** **非空** **元素序列**  。比如上面的示例，`[2,3,1]`是子数组，`[2,1]`就不是子数组

- 这题的解法采用滑动窗口：

  利用`left,right`指针，框住一片连续区域；

  移动`right`保证窗口内的子数组之和大于等于`target`；

  移动`left`保证窗口内的子数组之和大于等于`target`的前提下，窗口的长度减小，寻找最小长度

```java
func minSubArrayLen(target int, nums []int) int {
    // 滑动窗口
    n := len(nums)
  	// left right 窗口的左右指针
    left,right := 0,0

    winSum := 0 // 记录窗口内的总和
    result := math.MaxInt // 设定为最大值（因为要求最小值）

    for right < n {
				// 移动右边界 right
        rightVal := nums[right]
        right++
				// 记录窗口内子数组和
        winSum += rightVal

        for winSum >= target { // 保证窗口的总和 >= target前提下，寻找最小数组长度
            result = min(result,right-left)
          	// 移动左边界 left
            leftVal := nums[left]
            left++
            winSum -= leftVal
        }
    }
    // 表示不存在
    if result == math.MaxInt {
        result = 0
    }
    return result
}

func min(a,b int) int{
    if a < b{
        return a
    }
    return b
}
```



## 560. 和为K的子数组

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

思路：

![image-20250106123020580](./images/image-20250106123020580.png)

由上图可以得知，这么一个公式` 前缀和 X = 前缀和Y + target（数值等于target子数组）`，也就是 `前缀和 Y = 前缀和X - target（数值等于target子数组）`。由此可知，我们只需要用当前的前缀和 `X - target` ，看下是否存在前缀和`Y` ，如果存在，说明就可以找到一个满足条件的子数组，和 `Y`一起，组成`X`的值。

这里的`Y`的值可能会重复多次

![image-20250106124647720](./images/image-20250106124647720.png)

在 `index= 3`的位置，前缀和`6`，可以由前面的一个前缀和`3 + [0,3]`组成，也可以是后面的一个前缀和`3 + [3]`组成，也就是这里的`前缀和Y=3`出现了两次（代表子数组也有两种方案）

最终实现代码如下：`map`用来记录前缀和 + 出现的次数

```java
func subarraySum(nums []int, k int) int {
    // 用map记录前缀和 + 出现次数

    m := make(map[int]int)

		// 默认的前缀和0，出现1次
    nSum := 0
    m[nSum]++

    result := 0

    for i := 0;i < len(nums);i++ {
				// 当前的前缀和x
        nSum += nums[i] 
				// 前缀和x - target = 前缀和Y，在 m中查找Y出现的次数
        result += m[nSum-k]

        // 累积前缀和x出现的次数
        m[nSum]++
    }

    return result
}
```



## 24. 两两交换链表中的节点

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

思路：

这题是 `25. K个一组翻转链表`的特例题型，即 两个一组翻转链表

- 明确递归函数的定义：**swapPairs函数定义：对链表进行两两节点翻转，并返回头节点**
- 在递归函数内部，先针对一小段链表（2个节点的链表）进行翻转，将翻转后的链表，拼接上通过递归函数`swapParis`翻转的链表的头节点

![image-20250106165322724](./images/image-20250106165322724.png)

```java
// swapPairs函数定义：翻转以head 为头节点的链表，并返回翻转后的头节点
func swapPairs(head *ListNode) *ListNode {
  	// 截取一小段链表
    a,b := head,head
    for i := 0;i < 2;i++ {
        if b == nil {
            return a
        }
        b = b.Next
    }
		// 对这段链表进行翻转
    last := reverse(a,b)
  	// 将翻转后的尾部节点a拼接上， swapPairs(b) 翻转后的头节点
    a.Next = swapPairs(b)
    return last
}


func reverse(a *ListNode, b *ListNode) *ListNode {
    
    var pre *ListNode = nil 
    for a != b {
        temp := a.Next

        a.Next = pre
        pre = a

        a = temp
    }
    return pre
}
```



## 283. 移动零

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

思路：

利用双指针，`slow`指向待存储元素的位置，`fast`负责遍历所有的元素（查看所有的元素）

当 `fast`指向的元素不为`0`的时候，保存到`slow`指向的存储位置

```java
func moveZeroes(nums []int)  {

    slow , fast := 0,0
    for fast < len(nums) {
        if nums[fast] != 0 {
            nums[slow],nums[fast] = nums[fast],nums[slow]
            slow++
        }
        fast++
    }
}
```

这题和 **[905. 按奇偶排列数组](https://leetcode.cn/problems/sort-array-by-parity/)**是一样的解题方案。

给你一个整数数组 `nums`，将 `nums` 中的的所有偶数元素移动到数组的前面，后跟所有奇数元素。返回满足此条件的 **任一数组** 作为答案。

思路：

双指针方案：`slow`指向待存储元素的位置，`fast`负责遍历所有的元素（查看所有的元素）。当 `fast`指向的元素为偶数的时候，保存到`slow`指向的存储位置。

```java
func sortArrayByParity(nums []int) []int {
    slow,fast := 0,0
    // 类似于，283. 移动零 交换 0 和 >0的数字，让0都放到尾部
    for fast < len(nums) {
        if nums[fast] % 2 == 0 { // 偶数
            nums[slow],nums[fast] = nums[fast],nums[slow]
            slow++
        }
        fast++
    }
    return nums
}

//这是另外一种方案（有点类似于快速排序中的一点点逻辑）：定义 left right 指针分别指向数组的两端
func sortArrayByParity(nums []int) []int { 

    left,right := 0,len(nums)-1
		// 保证从[0...left]范围都是偶数元素
  	// 保证从 [right...len(nums)-1]范围的都是奇数元素
    for left < right {
        
        for left < right && nums[left] % 2 == 0 { // left指向偶数，直到碰到奇数停止
            left++
        }

        for left < right && nums[right] % 2 != 0 { // right指向奇数，直到碰到偶数停止
            right--
        }

        if left >= right {
            break
        }
				// 交换 left right指向的元素
        nums[left],nums[right] = nums[right],nums[left]
    }

    return nums
}
```



## 224. 基本计算器

给你一个字符串表达式 `s` ，请你实现一个基本计算器来计算并返回它的值。

注意:不允许使用任何将字符串作为数学表达式计算的内置函数，比如 `eval()` 。

思路：

下图演示了`1-(2+3)`的计算过程。建议边看代码，边看图片，理解整个过程

![image-20250106190008656](./images/image-20250106190008656.png)

![image-20250106190029130](./images/image-20250106190029130.png)

```java
func calculate(s string) int {
    // 例如： 1 + (2 + 3 )

    n := len(s)
    index := 0
    
    sign := 1 // 默认的符号
    res := 0  // 默认结果

    // 记录括号外面，上次的结果 和 符号
    resStack := []int{}
    signStack := []int{}
		
  	// index 用来遍历每一个字符
    for index < n {
       
        if isDigit(s[index]) { // 数字
            num := 0
          	// 连续取出多个数字
            for index < n && isDigit(s[index]) {
                num = num * 10 + int(s[index] - '0')
                index++
            }
            // 符号*num，保存到res中
            res += sign * num
            
        } else if s[index] == '+' { // 记录符号 +
            sign = 1
            index++
        } else if s[index] == '-' { // 记录符号 -
            sign = -1
            index++
        } else if s[index] == '(' { // 保存括号外的 结果res 和 符号sign
            resStack = append(resStack,res)
            signStack = append(signStack,sign)

            // 重置
            res = 0 
            sign = 1
            index++
        } else if s[index] == ')' { // 遇到 ） 说明 括号内计算结束了
            // 弹出上次的结果
            preRes := resStack[len(resStack)-1]
            // 弹出上次的符号 
            preSign := signStack[len(signStack)-1] 
            // 例如： 1+（2+3）范例， preRes = 1  presign = 1   res = 5
            res = preRes + preSign * res
            // 清理
            resStack = resStack[:len(resStack)-1]
            signStack = signStack[:len(signStack)-1]

            index++
        } else if s[index] == ' ' {
            index++
        }
    }
    return res
}

func isDigit(c byte) bool{

    if c >= '0' && c <= '9' {
        return true
    }
    return false
}
```



## 739. 每日温度

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

思路：

利用单调栈记录数组`temperatures`的索引，每来一个新元素，都和栈顶元素进行对比，如果栈顶元素小，弹出（直到不符合规则）

```java
func dailyTemperatures(temperatures []int) []int {
     // 单调栈
     sk := make([]int,0) // 保存索引
     answer := make([]int,len(temperatures))

     for i := 0;i < len(temperatures);i++ {

        // 栈不为空 && 当前的温度 比 栈顶中的温度大
         for len(sk) != 0 && temperatures[i] > temperatures[sk[len(sk)-1]]  {
             answer[sk[len(sk)-1]] = i - sk[len(sk)-1]

             // 出栈 
             sk = sk[:len(sk)-1]
         }
         sk = append(sk,i) // 记录索引
     }
     return answer
}
```



## 153. 寻找旋转排序数组中的最小值

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

- `nums` 中的所有整数 **互不相同**

思路：

二分搜索算法，本质就是将不符合题意的结果搜索范围，通过收缩`left right`的方式，丢弃。只保留符合题意的搜索范围`[left,right]`，供下一次二分搜索。

结合图片理解代码

![image-20250106204028611](./images/image-20250106204028611.png)

![image-20250106204105649](./images/image-20250106204105649.png)

```java
func findMin(nums []int) int {

    left, right := 0,len(nums)-1
    for left <= right {
        mid := left + (right - left)/2

        if nums[mid] > nums[right] { // 说明最小值在 右边数组
            left = mid+1
        } else if nums[mid] < nums[right] {
            right = mid // mid 可能就是最小值
        } else {
            return nums[mid]
        }
    }

    return -1
}
```



## 297. 二叉树的序列化和反序列化

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

思路：

序列化问题其实就是遍历问题，你能遍历，顺手把遍历的结果转化成字符串的形式，不就是序列化了么？

前序遍历的特点是根节点在开头，然后接着左子树的前序遍历结果，然后接着右子树的前序遍历结果：

![image-20250107171113524](./images/image-20250107171113524.png)

所以如果按照前序遍历顺序进行反序列化的时候，就知道第一个元素是根节点的值，然后递归调用反序列化左右子树，接到根节点上即可，上述思路翻译成代码即可解决本题。

```java

type Codec struct {
    index int
    data []string
}

func Constructor() Codec {
    return Codec{}
    
}

// 前序遍历（序列化）
func (this *Codec) serialize(root *TreeNode) string {
    if root == nil {
        return "nil"
    }
  	// 利用 "," 分割
    return strconv.Itoa(root.Val)+","+ this.serialize(root.Left) +","+this.serialize(root.Right)
}

//反序列化
func (this *Codec) deserialize(data string) *TreeNode {    
  	// 初始化 index值
    this.index = 0
  	// 拆分字符串
    this.data = strings.Split(data,",")
    return this.deser()
}

func (this *Codec)deser() *TreeNode {
  	// 越界返回 nil
    if this.index >= len(this.data) {
        return nil
    }
  	
    val := this.data[this.index] //从头到尾，递归遍历this.data切片
    this.index++
    if val == "nil" { // 如果是nil字符串，返回nil
        return nil
    }  
		
  	// 说明是一个有效的节点值
    v ,_ := strconv.Atoi(val)
		
    root := &TreeNode{Val:v,Left:nil,Right:nil} //构造TreeNode根节点
    root.Left = this.deser() //反序列化，构造左节点
    root.Right = this.deser() //反序列化，构造右节点
    return root
}
```



## 468. 验证IP地址

给定一个字符串 `queryIP`。如果是有效的 IPv4 地址，返回 `"IPv4"` ；如果是有效的 IPv6 地址，返回 `"IPv6"` ；如果不是上述类型的 IP 地址，返回 `"Neither"` 。

**有效的IPv4地址** 是 `“x1.x2.x3.x4”` 形式的IP地址。 其中 `0 <= xi <= 255` 且 `xi` **不能包含** 前导零。例如: `“192.168.1.1”` 、 `“192.168.1.0”` 为有效IPv4地址， `“192.168.01.1”` 为无效IPv4地址; `“192.168.1.00”` 、 `“192.168@1.1”` 为无效IPv4地址。

**一个有效的IPv6地址** 是一个格式为`“x1:x2:x3:x4:x5:x6:x7:x8”` 的IP地址，其中:

- `1 <= xi.length <= 4`
- `xi` 是一个 **十六进制字符串** ，可以包含数字、小写英文字母( `'a'` 到 `'f'` )和大写英文字母( `'A'` 到 `'F'` )。
- 在 `xi` 中允许前导零。

例如 `"2001:0db8:85a3:0000:0000:8a2e:0370:7334"` 和 `"2001:db8:85a3:0:0:8A2E:0370:7334"` 是有效的 IPv6 地址，而 `"2001:0db8:85a3::8A2E:037j:7334"` 和 `"02001:0db8:85a3:0000:0000:8a2e:0370:7334"` 是无效的 IPv6 地址。

思路：

这题没有技巧，就是对整个字符串，按照题目要求的格式，进行验证即可

```java
func validIPAddress(queryIP string) string {
    // 1. 判断是ip4 ip6
    isIp4,isIp6 :=  strings.Contains(queryIP,"."),strings.Contains(queryIP,":")
    // 2.ip4 分成4份，每份的数值大小为 [0,255],不能有前导0

    if isIp4 && !isIp6 && ip4Check(queryIP) {
        return "IPv4"
    }

    // 3.ip6 分成8份，每份长度为[1,4]，是一个16进制数字
    if !isIp4 && isIp6 && ip6Check(queryIP) {
        return "IPv6"
    }

    return "Neither"
}

func ip4Check(queryIP string) bool {
    if ipSlice := strings.Split(queryIP,"."); len(ipSlice) == 4 { // 4份
        // 对每个片段进行 检查
        for _, val := range ipSlice {
            // 字符串长度 大于3 等于 0 无效，剩下 1 2 3范围的长度，如果长度大于1，表示有2位or3位数字，那么不能有前导0
            if len(val) > 3 || len(val) == 0 || (len(val) > 1 && val[0] == '0') {
                return false
            }
            // 数值需要 <= 255
            if v ,err := strconv.Atoi(val);err != nil || v > 255 {
                return false
            }
        }
        return true
    }
    return false
}


func ip6Check(queryIP string) bool {
    if ipSlice := strings.Split(queryIP,":"); len(ipSlice) == 8 {// 8份

        for _, val := range ipSlice {
          	// 长度在[1~4]之间
            if len(val) < 1 || len(val) > 4 {
                return false
            }
            // 将16进制数字，转换成64位的整数（能转成，说明是有效的16进制数字）
            if _,err:=strconv.ParseUint(val,16,64);err != nil {
                return false
            }
        }
        return true
    }
    return false
}
```



## 460. LFU缓存

请你为 [最不经常使用（LFU）](https://baike.baidu.com/item/缓存算法)缓存算法设计并实现数据结构。

实现 `LFUCache` 类：

- `LFUCache(int capacity)` - 用数据结构的容量 `capacity` 初始化对象
- `int get(int key)` - 如果键 `key` 存在于缓存中，则获取键的值，否则返回 `-1` 。
- `void put(int key, int value)` - 如果键 `key` 已存在，则变更其值；如果键不存在，请插入键值对。当缓存达到其容量 `capacity` 时，则应该在插入新项之前，移除最不经常使用的项。在此问题中，当存在平局（即两个或更多个键具有相同使用频率）时，应该去除 **最久未使用** 的键。

为了确定最不常使用的键，可以为缓存中的每个键维护一个 **使用计数器** 。使用计数最小的键是最久未使用的键。

当一个键首次插入到缓存中时，它的使用计数器被设置为 `1` (由于 put 操作)。对缓存中的键执行 `get` 或 `put` 操作，使用计数器的值将会递增。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

思路：

总结下题目的要求：

1、调用 `get(key)` 方法时，要返回该 `key` 对应的 `val`。

2、只要用 `get` 或者 `put` 方法访问一次某个 `key`，该 `key` 的 `freq` 就要加一。

3、如果在容量满了的时候进行插入，则需要将 `freq` 最小的 `key` 删除，如果最小的 `freq` 对应多个 `key`，则删除其中最旧的那一个。

![image-20250107190147396](./images/image-20250107190147396.png)

建议边看代码，边参考上图。代码不难，就是细节很多**很细细细细细细细细细**

```java
type Data struct {
    val int // 值

    // freq记录频率，
    freq int
    // ele 记录在freq频率下，链表中的节点
    ele *list.Element
}


type LFUCache struct {
    keyToData map[int]Data // key 映射 Data

    freqToKey map[int]*list.List  // 频率freq映射key，目的在于记录相同频率的key先来后到顺序，方便删除最早的key（按照正常情况下，在出现频率相同的情况下，删除访问时间最早的key，这里没有用时间戳，而是用一个列表，因为链表存放顺序，就有时间的含义）
    cap int // 容量
    minFreq int // 始终指向最小频率，通过freqToKey，找到最早的key，然后删除（目的在于删除）
}


func Constructor(capacity int) LFUCache {
  	// 初始化
    return LFUCache{
        keyToData : make(map[int]Data),
        freqToKey : make(map[int]*list.List),
        cap :capacity,
        minFreq : 0,
    }
}


func (this *LFUCache) Get(key int) int {
  	// 如果key存在
    if data ,ok := this.keyToData[key];ok {
        this.increaseFreq(key) // 升频
        return data.val // 返回数据
    }
    return -1
}

/*
increaseFreq 本函数执行两件事情：
第一个，用 freq 找到旧链表，并删除节点（额外注意：如果freq == minFreq 将最小频率+1）
第二个，将 freq++ 找到新链表，并新增节点
*/
func (this *LFUCache)increaseFreq(key int) {
  	//1.先取出源数据
    data := this.keyToData[key] 

    //2.通过频率，找到链表，然后从链表中删除节点
    l := this.freqToKey[data.freq]
    l.Remove(data.ele)

  	if l.Len() == 0 { // 如果链表为空，说明链表中没有数据了
        delete(this.freqToKey,data.freq) // 释放（节约内存）
        if data.freq == this.minFreq { // 如果频率恰好和最小频率相同（说明最小的频率已经被删除了，最小频率升频为次小频率）
            this.minFreq++
        }
    }

    //3.加入新的列表
    data.freq += 1 // 频率+1
    if _,ok := this.freqToKey[data.freq];!ok{ //新频率对应的链表不存在
        this.freqToKey[data.freq] = list.New() // 创建链表
    }
    data.ele = this.freqToKey[data.freq].PushBack(key) // 将key加入链表，返回节点，保存在data中
    this.keyToData[key] = data // 修改keyToData中的数据
}

func (this *LFUCache) Put(key int, value int)  {
    if this.cap <= 0 {
        return
    }

    // 1. 判断key是否存在
    if _,ok := this.keyToData[key];ok {
        //2. key存在，key对应的频率+1
        this.increaseFreq(key)
        // 更新key的val
        data := this.keyToData[key]
        data.val = value
        this.keyToData[key] = data
        return
    }

    //2.key 不存在
    if len(this.keyToData) >= this.cap { //容量超过预期，先删除一个
        this.removeKey()
    }

    //3. 【新】插入：频率肯定是1

    data := Data{val:value,freq:1} // 数值 + 频率
    if _,ok := this.freqToKey[1];!ok {
        this.freqToKey[1] = list.New()
    }
    data.ele = this.freqToKey[1].PushBack(key) // 对应链表中的元素
    this.keyToData[key] = data
    this.minFreq = 1 // 注意：最小频率变成1
}

func (this *LFUCache)removeMinFreqKey() {
    l := this.freqToKey[this.minFreq] // 找到最小频率链表

    deletedKey := l.Remove(l.Front()) // 删除链表的首部（因为最新的数据都是直接放入到尾部 PushBack(key） ）
    if l.Len() == 0 {
        delete(this.freqToKey,this.minFreq)
      	// this.minFreq++ // 这里这个写不写都无所谓，当要新增节点的时候，一定是因为容量不足，才执行的函数。当后续新增节点的是时候，节点是第一次加入， this.minFreq会被设定为1
    }
    delete(this.keyToData,deletedKey.(int)) // 删除key对应的数值
}

```



## 207. 课程表

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入：numCourses = 2, prerequisites = [[1,0]]
输出：true
解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。
```

思路：

比如 课程1依赖课程2 课程3，课程3又依赖课程1，这样就形成了循环依赖的关系。课程是无法完成学习的。

通过下图可以理解 `onPath`变量的意义，以及整个检测的可视化过程。建议边看代码边看图理解

![image-20250108184539428](./images/image-20250108184539428.png)

![image-20250108185123851](./images/image-20250108185123851.png)

![image-20250108185414643](./images/image-20250108185414643.png)

![image-20250108185701530](./images/image-20250108185701530.png)

```java
var isCircle bool // 表示课程是否存在循环依赖
var visited []bool // 表示课程已经做过检查了，不用重复检查
var onPath []bool  // 标记课程是否正在被占用
func canFinish(numCourses int, prerequisites [][]int) bool {

    visited = make([]bool,numCourses)
    onPath = make([]bool,numCourses)

    isCircle = false
    //1.先构建有向图；用临接表的方式
    graph := make([][]int,numCourses) // 总共有numCourses个课程，graph的目的是记录下每个课程依赖的课程列表

    for i := 0;i < len(prerequisites);i++ { // 课程prerequisites[i][0] 依赖于 课程prerequisites[i][1] 
        graph[prerequisites[i][0]] = append(graph[prerequisites[i][0]],prerequisites[i][1])
    }

    // 2. 遍历有向图中的所有节点 i 从 [0... numCoures-1] 表示每个课程id
    for i := 0; i < numCourses;i++ { 
        dfs(graph,i) // 从 每个课程 i 出发，检测依赖关系
    }

    return !isCircle // 没环，表示可以学习完所有的课程
}

// 这里的i可以理解为课程id（可以理解成向周围 散播的感觉），onPath用来记录课程已经被占中了
func dfs(graph [][]int,i int) {
  	// 现在访问的课程i，标记为占用中，说明课程被重复依赖了（标记有环）
    if onPath[i] {
        isCircle = true
    }

    if visited[i] || isCircle { // 课程已经检测过了，或者已经存在环，没必要继续下去了，尽快结束
        return
    }

    visited[i] = true // 表示课程i 已经检测过了（没必要重复检查了，为了剪枝，加快算法速度）
    onPath[i] = true // 标记课程i被占用了

    // 继续向周围散播
    // 看下课程i 依赖的课程列表graph[i]
    for j := 0;j < len(graph[i]);j++ { // i 下面的所有课程
        dfs(graph,graph[i][j]) // graph[i][j] 表示子课程
    }   

    onPath[i] = false // 取消占用标记
}
```



## 138. 随机链表的复制

给你一个长度为 `n` 的链表，每个节点包含一个额外增加的随机指针 `random` ，该指针可以指向链表中的任何节点或空节点。

构造这个链表的 **[深拷贝](https://baike.baidu.com/item/深拷贝/22785317?fr=aladdin)**。 深拷贝应该正好由 `n` 个 **全新** 节点组成，其中每个新节点的值都设为其对应的原节点的值。新节点的 `next` 指针和 `random` 指针也都应指向复制链表中的新节点，并使原链表和复制链表中的这些指针能够表示相同的链表状态。**复制链表中的指针都不应指向原链表中的节点** 。

例如，如果原链表中有 `X` 和 `Y` 两个节点，其中 `X.random --> Y` 。那么在复制链表中对应的两个节点 `x` 和 `y` ，同样有 `x.random --> y` 。

返回复制链表的头节点。

用一个由 `n` 个节点组成的链表来表示输入/输出中的链表。每个节点用一个 `[val, random_index]` 表示：

- `val`：一个表示 `Node.val` 的整数。
- `random_index`：随机指针指向的节点索引（范围从 `0` 到 `n-1`）；如果不指向任何节点，则为 `null` 。

你的代码 **只** 接受原链表的头节点 `head` 作为传入参数。

![image-20250108201137887](./images/image-20250108201137887.png)

思路：

这道题目，就属于会者不难，难者不会的那类题。

**对于数据结构复制，甭管他怎么变，你就记住最简单的方式：一个哈希表 + 两次遍历**。

第一次遍历专门克隆节点，借助哈希表把【原始节点和克隆节点】的映射存储起来；

第二次专门组装节点，照着原数据结构的样子，把克隆节点的指针组装起来。

```java
/**
 * Definition for a Node.
 * type Node struct {
 *     Val int
 *     Next *Node
 *     Random *Node
 * }
 */

func copyRandomList(head *Node) *Node {
    // hash表，存储 原始节点 -> 克隆节点 的映射
    origin2Clone := make(map[*Node]*Node)
    //1.遍历链表，创建 old -> new 映射关系
    for p := head;p != nil;p = p.Next {
        if _,ok := origin2Clone[p];!ok {
            origin2Clone[p] = &Node{Val:p.Val} // 老节点 -> 新节点
        }
    }

    //2. 进行映射
    // p表示旧节点 origin2Clone[p] 表示新节点
    for p := head;p != nil ;p = p.Next {
        origin2Clone[p].Next = origin2Clone[p.Next]
        origin2Clone[p].Random = origin2Clone[p.Random]
    }
		// 返回新头节点 origin2Clone[head]
    return origin2Clone[head]
}
```



## 402. 移掉K位数字

给你一个以字符串表示的非负整数 `num` 和一个整数 `k` ，移除这个数中的 `k` 位数字，使得剩下的数字最小。请你以字符串形式返回这个最小的数字。

思路：

我们以局部的视角看问题，**让相邻的两两数字，小的在前面，大的在后面**

比如`54`，相邻的两个数字，如果要想变小，肯定要让小的数字占据高位，那就是`45`这种格式。如果是移除，那就移除`5`只保留`4`即可。

再比如`541`，移除1位，让数值最小。按照上面的方案，我们移除`5`就可以得到`41`。可能会觉得`541`之间，1更小呀，为啥不移除 4。

我们只能进行1次移除操作，当从左到右遍历，也就是从高位到低位遍历，我们需要优先将高位变小，再让低位变小。如果高位不变小，只是把低位变小，那就是`541`去掉 4 变成 `51`。还是比上面的`41`结果更大的。

所以，结论就是**先让高位变小（用小的数字），然后再让后面的位变小**

再例如`1432219`，移除3位得到最小数值。

我们从左到右遍历字符串，来演示这个过程

- 先比较 14，高位 1已经很小了（保持不变），所以结果为  1432219

- 再比较 43，3更小，【去掉4】（注意是两两比较，一旦去掉了4，那么3就和1相邻的，其实这里也要比较下 13的关系，显然 1 更小），结果为 132219

-  32比较，【去掉3】，结果为 12219

- 22比较，相等，所以保持不变，结果为 12219

- 21比较，1更小，【去掉2】结果为 1219（这时候前一个2和1相邻的了，按照上面的理论1更小，应该【再去掉一个2】，结果为119）因为我们只需要3次移除操作，如果再移除一个2，就是4次移除操作了。

实际实现的时候，利用栈来存储数字。遍历到的数字和栈顶的数字比较（也就实现了两两比较的关系），让小的数字占据高位即可。

```java
func removeKdigits(num string, k int) string {
    
    stack := make([]rune,0)

    for _,c := range num { // 遍历字符串中的每个字符

      // 删除k个数字，并且栈里面有数字 并且 入栈字符c比栈顶元素小(也就是两两比较，让小的占据高位)
        for k > 0 && len(stack) != 0 && c < stack[len(stack)-1] { // 注意这里是个for循环
            //踢出栈顶元素
            stack = stack[:len(stack)-1]
            k-- // 每踢出一个元素，个数-1
        }
				
      	// 比如：102 这种格式， 10比较，0更小，如果让0入栈，最终的结果就是 02，实际应该是2
        if c == '0' && len(stack) == 0 { //前导0【忽略】
            continue
        }
        
        stack = append(stack,c) // 最后入栈
    }
		
  	// 特殊情况
    if k >= len(stack) { // 例如：100  k=2，只会执行1次移除操作（还缺少一次），并且最后的stack为空。直接返回 0
        return "0"
    } else {
        stack = stack[:len(stack)-k] // 例如：123456这种递增的格式，上面for循环不会移除任何字符，题目要求必须剔除k个 	1234 56 去掉尾部最大的数，余下的就是最小的值
    }
    return string(stack)
}
```



## 136. 只出现一次的数字

给你一个 **非空** 整数数组 `nums` ，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。

你必须设计并实现线性时间复杂度的算法来解决此问题，且该算法只使用常量额外空间。

思路：

记住异或运算，就是半加运算。也就是只做加法，但是不进位。所以相同的数字进行异或的结果就是`0`

![image-20250108215323276](./images/image-20250108215323276.png)

```java
func singleNumber(nums []int) int {
    // 这题的思路：异或运算 a^a = 0  a ^ 0 = a
    // 重复元素出现两次,异或后都是0，最后的结果就是那个只出现一次的元素
    result := 0
    for _ ,num := range nums {
        result ^= num
    }
    return result
}
```



## 11. 盛最多水的容器

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

![image-20250109145734234](./images/image-20250109145734234.png)

思路：

**用 `left` 和 `right` 两个指针从两端向中心收缩，一边收缩一边计算 `[left, right]` 之间的矩形面积，取最大的面积值即是答案**。

不过肯定有读者会问，下面这段 if 语句为什么要移动较低的一边：

```java
// 双指针技巧，移动较低的一边
if (height[left] < height[right]) {
    left++;
} else {
    right--;
}
```

**其实也好理解，因为矩形的高度是由 `min(height[left], height[right])` 即较低的一边决定的**：

你如果移动较低的那一边，那条边可能会变高，使得矩形的高度变大，进而就「有可能」使得矩形的面积变大；相反，如果你去移动较高的那一边，矩形的高度是无论如何都不会变大的（因为低的那一边决定了高度上限，也就是短板效应），所以不可能使矩形的面积变得更大。

```java

// 双指针技巧
func maxArea(height []int) int {
    left,right := 0,len(height)-1
		// 最终结果
    maxVal := 0
    for left < right {
        // 计算两条边围成的面积 高度的最小值 * 底边长度

        maxVal = max(maxVal,min(height[left],height[right]) * (right-left)) 

        if height[left] < height[right] { // left/right两条边，left边比较短，因为容器盛水，短边会限制容器的高度，如果移动right，即使找到更高的right，因为left比较短，最后可能容器的高度还是left高度
            left++

        } else {
            right--
        }
    }
    return maxVal
}

func max(a ,b int) int{
    if a > b {
        return a
    }
    return b
}

func min(a,b int) int {
    if a < b {
        return a
    }
    return b
}
```



## 47. 全排列II

给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。

思路:

请先做前置题目「[46. 全排列](https://leetcode.cn/problems/permutations/solutions/2363882/46-quan-pai-lie-hui-su-qing-xi-tu-jie-by-6o7h/)」

本题和上一题的区别是数组中“存在重复元素”。当数组存在重复元素时，排列方案中也存在重复的方案。

重复的排列方案，主要是因为重复的元素造成的。

比如：数字序列`[1,1]`，假如我们将第一个1叫做  1'  第二个1叫做 1"，那么数字序列我们改写为`[1' 1"]`。如果我们进行排列，那就包括了`[1' 1"]和[1" 1']`两种排列方案，其实这两种方案就是一种方案。

为了保证不重复，我们设定一个条件，就是要求 1' 必须要在1"的前面，那么`[1" 1']`这种方案自然也就不成立了。

那么怎么才能实现这个条件呢？

-  我们需要对数组进行排序，让相同的元素都相邻在一起
- 在每次选择一个元素的时候，都要保证相邻的【前一个】**相同**元素，出现的情况下，自己才能出现（也就是相对顺序要保证不变）。比如上面的 1" 要想出现，必须 1'先出现的情况下。。。而`[1" 1']`这种格式，1' 是在 1"后面出现的。

具体看下面代码

```java

var used []bool
var track []int
var result [][]int
func permuteUnique(nums []int) [][]int {

    // 1.排序
    sort.Slice(nums,func(i,j int)bool{
        return nums[i] < nums[j]
    })
    // 回溯算法
    used = make([]bool,len(nums)) //用来记录元素是否已经被使用过
    track = []int{}
    result = [][]int{}
    backtrack(nums)
    return result
}

func backtrack(nums []int) {

    if len(track) == len(nums) {
        tmp := make([]int,len(track))
        copy(tmp,track)
        result = append(result,tmp)
        return
    }

    for i := 0;i < len(nums);i++ {
        if used[i] {
            continue
        }

        // 保证重复的元素的【相对顺序】不变，例如前一个1没有被使用，后面的重复元素1也不能被使用，这样其实就保证重复元素的相对顺序不变。再例如：1 1' ，保证1'被选中的前提 1先被使用，这样就可以保证1 1'的顺序不变
        //当前选择的元素和前一个元素相同,如果前一个元素没有被使用，当前的这个元素也不能被使用
        if i > 0 && nums[i] == nums[i-1] && !used[i-1] {
            continue
        }

        //选择
        used[i] = true
        track = append(track,nums[i])
        backtrack(nums)

        //撤销选择
        used[i] = false
        track = track[:len(track)-1]
    }
}
```



## 79. 单词搜索

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

![image-20250111002805100](./images/image-20250111002805100.png)

思路:

采用 DFS 算法暴力搜索，这题和岛屿问题有类似之处，可以对比看下。

注意我们要对已经匹配过的字符做标记，比如用一个额外的 `visited` 布尔数组，或者使用其他方法标记 `board` 中已经匹配过的字符。

如果不做标记的话会出现错误的结果，比如这个测试用例：

```java
[["A","B","C","E"],
 ["S","F","C","S"],
 ["A","D","E","E"]]
```

你如果在其中搜索 `"ABCB"`，按道理不应该搜到，但如果你不对已经匹配过的字符做标记的话，算法可能匹配了第一行前三列的 `"ABC"` 之后又回头匹配了第二列的 `"B"`，导致出现错误的结果。

代码如下：

```java
var found bool
func exist(board [][]byte, word string) bool {
		// 记录是否已经搜索到了
    found = false

    m ,n := len(board),len(board[0])
    for i := 0;i < m;i++ {
        for j := 0;j < n ;j++ {
          	// 从每一个字符board[i][j]开始，进行搜索
            dfs(board,i,j,m,n,word,0)
            if found {
                return true
            }
        }
    }
    return false
}

//  board从i，j位置开始，word从p位置开始，寻找匹配的字符，最后判断能否完成匹配
func dfs (board [][]byte,i,j,m,n int,word string ,p int ) {
  	
    if p == len(word) { // 说明整个p完成了搜索，找到了尾部
        found = true
        return
    }
  	// 如果已经有匹配的结果，就不用继续下去了（为了剪枝）
    if found {
        return
    }

    if i < 0 || i >= m || j < 0 || j >=n { // 说明越界
        return
    }

    if board[i][j] != word[p] { // 不相同，忽略
        return
    }


    // 执行到这里，说明p位置的字符和board[i][j]位置的字符相同
  	board[i][j] = board[i][j] ^ byte(0x80) // 这个的目的就是把byte的最高位设置为1，就变成了一个其他的字符(肯定不是大小写字母,等价于打上了特殊标记)
		
  	// 扩展到周边字符 和 p+1 字符 比较
    dfs(board,i+1,j,m,n,word,p+1)
    dfs(board,i-1,j,m,n,word,p+1)
    dfs(board,i,j+1,m,n,word,p+1)
    dfs(board,i,j-1,m,n,word,p+1)


    board[i][j] = board[i][j] ^ byte(0x80) // 撤销标记

}
```



## LCR 155. 将二叉搜索树转化为排序的双向链表

将一个 **二叉搜索树** 就地转化为一个 **已排序的双向循环链表** 。

对于双向循环列表，你可以将左右孩子指针作为双向循环链表的前驱和后继指针，第一个节点的前驱是最后一个节点，最后一个节点的后继是第一个节点。

特别地，我们希望可以 **就地** 完成转换操作。当转化完成以后，树中节点的左指针需要指向前驱，树中节点的右指针需要指向后继。还需要返回链表中最小元素的指针。

思路：

**树中节点的左指针`left`需要指向前驱，树中节点的右指针`right`需要指向后继**

- 二叉搜索树的中序遍历为 **递增序列** 
- **排序链表：** 节点应从小到大排序，因此应使用 **中序遍历** “从小到大”访问树的节点
- **双向链表**： 在构建相邻节点的引用关系时，设前驱节点 pre 和当前节点 cur ，不仅应构建 pre.right = cur ，也应构建 cur.left = pre 
- **循环链表：** 设链表头节点 `head` 和尾节点 `tail` ，则应构建 `head.left = tail` 和 `tail.right = head`

![image-20250111221946626](./images/image-20250111221946626.png)

因为 `leetcode`没有`Go`的代码编辑器，这里提供`C++`的代码

```java
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/
class Solution {
public:
    Node* pre = NULL;  // 前驱节点
    Node* head = NULL; // 头部节点
public:
    // right 用来往后面指 left用来往前面指
    Node* treeToDoublyList(Node* root) {

        if (root == NULL) {
            return head;
        }
			
        doublyList(root);
        // 首尾相连（循环）
        head->left = pre;
        pre->right = head;
				// 返回链表的头节点
        return head;
    }

  	// 中序遍历	
    void doublyList(Node* root) {
        
        if (root == NULL) {
            return;
        }
      
        doublyList(root->left);
        if (head == NULL) {
            head = root; // 记录下头部节点,作为链表的头节点
            pre = root;  // 记录下前驱节点
        } else {
          	// 相邻节点(双向)  root表示当前节点（等价于上图中的节点4）， pre是前一个节点（等价于上图中的节点3）
            root->left = pre;
            pre->right = root;
            pre = root;
        }
        doublyList(root->right);
    }
};
```



## LCR 125. 图书管理

读者来到图书馆排队借还书，图书管理员使用两个书车来完成整理借还书的任务。书车中的书从下往上叠加存放，图书管理员每次只能拿取书车顶部的书。排队的读者会有两种操作：

- `push(bookID)`：把借阅的书籍还到图书馆。
- `pop()`：从图书馆中借出书籍。

为了保持图书的顺序，图书管理员每次取出供读者借阅的书籍是 **最早** 归还到图书馆的书籍。你需要返回 **每次读者借出书的值** 。

如果没有归还的书可以取出，返回 `-1` 。

思路：

这题有些绕，其实就是让你用栈实现队列，与[232. 用栈实现队列](https://leetcode.cn/problems/implement-queue-using-stacks) 相同

```java
type CQueue struct {
    sk1 []int
    sk2 []int
}


func Constructor() CQueue {

    return CQueue {
        sk1 : make([]int,0), // sk1用来保存最新的数据（看作 队列的尾部）
        sk2 : make([]int,0), // sk2用来出栈数据（看作 队列的首部）
    }
    
}


func (this *CQueue) AppendTail(value int)  { // 插入尾部
    this.sk1 = append(this.sk1,value)
}


func (this *CQueue) DeleteHead() int { // 删除头部
  	// 如果栈为空，说明没有书
    if len(this.sk1) == 0 && len(this.sk2) == 0 {
        return -1
    }
		
  	// 如果sk2为空，将栈sk2的内容，放入到栈sk1中
    if len(this.sk2) == 0 { 
        for len(this.sk1) != 0 {
            tempval := this.sk1[len(this.sk1)-1]
            this.sk2 = append(this.sk2,tempval)
            this.sk1 = this.sk1[:len(this.sk1)-1]
        }
    }

    // 出栈sk2（
    val := this.sk2[len(this.sk2)-1]
    this.sk2 = this.sk2[:len(this.sk2)-1]

    return val
}
```



## 498. 对角线遍历

给你一个大小为 `m x n` 的矩阵 `mat` ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。

思路：

这题主要是观察矩阵

- 找出边界位置的【行、列】的变化关系
- 通过`(r+c)%2 == 0`知道当前是【从左下到右上，还是从右上到左下】
- 在具体的的左下右上的移动中，知道行列的变动特点，是+1，还是-1

![image-20250111234249364](./images/image-20250111234249364.png)

📢注意：上图中的第一个红线和第二个红线，其实都是`r==0`。但是第二个红线 `c==n-1`已经是最后一列了（如果还对列+1，那就越界了）。所以，在判断的时候，要优先以`c==n-1`作为判断条件，再以`r==0`作为判断条件。注意看代码体会这个。

```java
func findDiagonalOrder(mat [][]int) []int {
    
    m,n := len(mat),len(mat[0])
    result := make([]int,m*n)

    r,c := 0,0 // r是行 c是列

    for i := 0;i < m*n;i++ {

        result[i] = mat[r][c]

        if (r+c) %2 == 0 { // 说明从左下到右上
             // 【注意这里的顺序】
            if c == n-1 { // 边界位置：列不变，行+1
                r++
            } else if r == 0 { // 边界位置:行不变，列+1
                c++
            } else {
                r--
                c++
            }
        } else { // 说明从右上到左下
            // 【注意这里的顺序】
            if r == m-1 { // 边界位置：行不变，列+1
                c++
            } else if c == 0 {// 边界位置：列不变，行+1
                r++
            }   else {
                r++
                c--
            }
        }
    }
    return result
}
```



## 958. 二叉树的完全性检验

给你一棵二叉树的根节点 `root` ，请你判断这棵树是否是一棵 **完全二叉树** 。

在一棵 **[完全二叉树](https://baike.baidu.com/item/完全二叉树/7773232?fr=aladdin)** 中，除了最后一层外，所有层都被完全填满，并且最后一层中的所有节点都尽可能靠左。最后一层（第 `h` 层）中可以包含 `1` 到 `2h` 个节点。

思路：

层序遍历：当遇到`nil`节点，后续不能再出现`【非nil】`节点，才能满足完全二叉树.

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func isCompleteTree(root *TreeNode) bool {
    
    if root == nil {
        return true
    }

    nodes := []*TreeNode{}
    nodes = append(nodes,root)//加入第一个节点
    end := false
    for len(nodes) != 0 {
        size := len(nodes)
        //层序遍历
        for i := 0;i < size;i++ {
            if nodes[i] == nil {
                end = true //遇到第一个nil时候，end就为true，说明后续就不应该出现【非nil】节点
            } else { //遇到非nil节点
                if end {
                    return false
                }
                //不判断是否为nil，直接加入
                nodes = append(nodes,nodes[i].Left)
                nodes = append(nodes,nodes[i].Right)
            }
        }
        nodes = nodes[size:]//踢出已经遍历过的节点
    }
    return true
}
```



## 55. 跳跃游戏

给你一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。数组中的每个元素代表你在该位置可以跳跃的最大长度。

判断你是否能够到达最后一个下标，如果可以，返回 `true` ；否则，返回 `false` 。

思路：

从尾部开始倒序遍历；要想到达尾部，看下前面的某个节点能否达到尾部；比如某个节点`x`可以到达尾部；那就继续看`x`之前的某个节点能否到达`x`，间接的等价于可以到达尾部；

```java
func canJump(nums []int) bool {
  
    targetIdx := len(nums)-1 //期望到达的位置
  
  	// i 从倒数第二个索引 targetIdx-1开始
    for i := targetIdx-1;i >= 0;i-- {
      
        if nums[i] +i >= targetIdx { // 从位置i能到达 targetIdx 位置
            // 那么期望到达的新位置为i，只要前面的其他的节点到达i, 等价于间接的可以到达尾部
            targetIdx = i 
        }
    }
    return targetIdx == 0 // 期望到达的位置为0的时候，而此时我们要从0的位置出发，所以就可以表明我们能到达尾部；
}
```



## 补充题23：检测循环依赖

直接看这篇文章即可  https://mp.weixin.qq.com/s/pCRscwKqQdYYN7M1Sia7xA  文章采用`BFS`的方式来寻找依赖关系，也就是拓扑排序。

如果有印象的话，这题其实和 **207. 课程表**是类似的题目，不过采用的是`DFS`的写法。**210. 课程表 II**建议也看下，你会发现和**207. 课程表**答案几乎一样。



## LCR 170. 交易逆序对的总数

在股票交易中，如果前一天的股价高于后一天的股价，则可以认为存在一个「交易逆序对」。请设计一个程序，输入一段时间内的股票交易记录 `record`，返回其中存在的「交易逆序对」总数。

**示例 1：**

```
输入：record = [9, 7, 5, 4, 6]
输出：8
解释：交易中的逆序对为 (9, 7), (9, 5), (9, 4), (9, 6), (7, 5), (7, 4), (7, 6), (5, 4)。
```

思路：

本题是**归并排序**的应用。

归并排序套路：

![image-20241216124441311](./images/image-20241216124441311.png)

- 将数组不断的拆分成两两子数组（并进行排序），最后再不断的两两合并有序子数组，变成一个更大的有序子数组

逆序对的记录，就是在合并的过程中，对有序数组，多一个比较的过程。

![image-20250112173638761](./images/image-20250112173638761.png)

![image-20250112173719634](./images/image-20250112173719634.png)

具体看下面代码

```java

var temp []int
var count int
func reversePairs(record []int) int {
    count = 0

    n := len(record)
    if n == 0 { // 空数组，不用排序
        return count
    }
    // 归并排序
    temp = make([]int,len(record))
    sort(record,0,len(record)-1)
    return count
}

// sort函数定义： 对数组record [lo,hi]范围内的元素进行排序（升序）
func sort(record []int, lo,hi int) { 
    if lo == hi { // 说明只有一个元素
        return
    }
    // 拆分成两个子数组
    mid := lo + (hi-lo)/2
    sort(record,lo,mid) //对前半部分进行排序
    sort(record,mid+1,hi)// 对后半部分进行排序
    merge(record,lo,mid,hi) // 合并两个有序数组

}

func merge(record []int, lo ,mid ,hi int) {
    // lo 指向前半部分的有序数组，首部
    // mid+1 指向后半部分的有序数组，首部

    //1.先将有序数组record，放到temp中保存（复制一份），此时的record和temp是完全一样的；
    for i := lo;i <= hi;i++ {
        temp[i] = record[i]
    }


   	
    // 这里就是计算逆序对的代码逻辑
  
    j := mid+1 //表示后面的子数组指针
    for i := lo;i <= mid;i++ { // i表示前面的子数组指针
        for j <= hi && record[i] > record[j] { // 说明 【前面的元素 > 后面的元素】，是一个【逆序对】
            j++
        }
      	// 执行到这里，说明[mid+1,j) 之间的元素，和record[i]位置的元素，都可以构成逆序对
        count += j - (mid+1) // 逆序对的个数
    }


    //2.然后合并两个有序数组temp，将结果保存到record中

    left := lo // temp中的左边子数组
    right := mid+1 // temp中的右边子数组

    for p := lo;p <= hi;p++ { //这里的p表示record的位置

        if left == mid+1 { // 说明temp左边的子数组已经遍历完了
            record[p] = temp[right] // 剩下temp右边的，放入进去
            right++
        } else if right == hi+1 { // 说明temp右边的子数组已经遍历完了
            record[p] = temp[left]/// 剩下temp左边的，放入进去
            left++
        } else if temp[left] > temp[right] {
            record[p] = temp[right] // 放小的进去
            right++
        } else {
            record[p] = temp[left] // 放小的进去
            left++
        }
    }

}
```



## 7. 整数反转

给你一个 32 位的有符号整数 `x` ，返回将 `x` 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 `[−231, 231 − 1]` ，就返回 0。

**假设环境不允许存储 64 位整数（有符号或无符号）。**

**示例 1：**

```
输入：x = 123
输出：321
```

**示例 2：**

```
输入：x = -123
输出：-321
```

 思路：

这题其实就是考察**取余**

```java
func reverse(x int) int {
    res := 0
    for x != 0 {
        res = res * 10 + x % 10 // x % 10求余 
        x = x / 10
    }
		// 题目要求
    if res >= math.MaxInt32 || res <= math.MinInt32 {
        return 0
    }
    return res
}
```



## 40. 组合总和II

给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。

`candidates` 中的每个数字在每个组合中只能使用 **一次** 。

**注意：**解集不能包含重复的组合。 

思路：

建议和**39. 组合总和**对比学习下。

本题解题的关键点在于下面几个条件的限制：

- 元素存在重复

- 组合不能有重复的结果
- 每个数字在每个组合中只能使用一次

```java
var result [][]int

func combinationSum2(candidates []int, target int) [][]int {
	// 回溯算法
	result = [][]int{}
	// 1.排序 ，非常重要一点，必须整个数组是有序的（因为包含重复的数字，为了判断）
	sort.Ints(candidates)
	// 2.回溯
	path := []int{}
	backtrack(0, candidates, path, 0, target)
	return result
}

// start保证每次选择元素的起始范围，不用每次都是从start==0开始，因为要找的是组合，而不是排列
func backtrack(start int, candidates, path []int, sum int, target int) {

	if sum >= target { // 这里的  1 <= candidates[i] <= 50 都是正数，所以 sum > target 就可以退出了
		if sum == target {
			// 一个组合结果
			t := make([]int, len(path))
			copy(t, path)
			result = append(result, t)
		}
		return
	}

	for i := start; i < len(candidates); i++ {
		// 【本次循环】重复的数字不再选择（保证解集不包含重复的组合）
    // 例如  1 1 2 求target = 3,第一个1使用过了，第二个1就不用再使用了。
		if i-1 >= start && candidates[i-1] == candidates[i] {
			continue
		}
        
		path = append(path, candidates[i])
    sum += candidates[i]
    // 下一个元素为 i+1，保证每个元素在一个组合中只能使用一次
		backtrack( i+1, candidates, path, sum, target)
		path = path[:len(path)-1]
    sum -= candidates[i]
	}
}
```



## 16. 最接近的三数之和

给你一个长度为 `n` 的整数数组 `nums` 和 一个目标值 `target`。请你从 `nums` 中选出三个整数，使它们的和与 `target` 最接近。

返回这三个数的和。

假定每组输入只存在恰好一个解。

思路：

- 先排序（排序的目的是为了使用二分搜索，因为二分搜索需要数据是有序的）
- 固定第一个数`nums[i]`，再去 `nums[i+1..]` 中寻找另外两个数字，使三数之和无限接近`target`

解释下代码片段的含义

```java
 // 这里只是为了减枝（避免多次计算）
if i-1 >= 0 && nums[i-1] == nums[i] { // 表示当前数字 nums[i]和前一个数字nums[i-1]相同，直接跳过
  	continue
}
```

![image-20250112190257867](./images/image-20250112190257867.png)

```java
for left < right && nums[left] == leftValue { // 重复的数值，直接跳过
  	left++ // left++ 目的让 sum变大一些
}
```

![image-20250112190017990](./images/image-20250112190017990.png)

这题的答案和之前的求**15. 三数之和**的部分代码是雷同的（不记得可以去复习下）

```java
func threeSumClosest(nums []int, target int) int {

    sort.Ints(nums)// 正向排序

    result := math.MaxInt
   
    for i := 0;i < len(nums);i++ {

        // 这里只是为了减枝（避免多次计算）
      	if i-1 >= 0 && nums[i-1] == nums[i] { // 表示当前数字 nums[i]和前一个数字nums[i-1]相同，直接跳过
            continue
        }
      // 固定数字nums[i], 在 [i+1:len(nums)-1] 范围找另外两个数字
        left ,right := i+1, len(nums)-1 
        for left < right {
            
            leftValue := nums[left]
            rightValue := nums[right]
            sum := nums[i] + leftValue + rightValue

            // 说明sum更接近于target，记录下来
            if abs(sum - target) < abs(result- target) {
                result = sum
            }

            if sum < target { 

                for left < right && nums[left] == leftValue { // 重复的数值，直接跳过
                    left++ // left++ 目的让 sum变大一些
                }
                
            } else { 
                for left < right && nums[right] == rightValue { // 重复的数值，直接跳过
                    right-- // right-- 目的让sum变小一些
                }
            }
        }
    }
    return result
}

func abs(a int) int {
    if a < 0 {
        return -a
    }
    return a
}
```



## 61. 旋转链表

给你一个链表的头节点 `head` ，旋转链表，将链表每个节点向右移动 `k` 个位置。

```java
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func rotateRight(head *ListNode, k int) *ListNode {
    // 初始：空/只有一个/移动0位
    if head == nil || head.Next == nil || k == 0{
        return head
    }

    //1.链表长度 && p 指向链表尾部
    count := 1
    p := head
    for p.Next != nil {
        count++
        p = p.Next
    }

    k = k % count
    if k == 0 { // k是count的整数倍，等价于不移动
        return head
    }

    // 2.首位串成环
    p.Next = head

    // 3. 找到，需要断开的节点
    count = count - k
    for count > 0 {
        p = p.Next
        count--
    }
    // 此时p是结果的 尾部节点
		// p.Next才是新链表的头节点
    result := p.Next // 链表头节点
    p.Next = nil // 断开

    return result
}
```



## 123.买卖股票的最佳时机 III

给定一个数组，它的第 `i` 个元素是一支给定的股票在第 `i` 天的价格。设计一个算法来计算你所能获取的最大利润。你最多可以完成 **两笔** 交易。

**注意：**你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

思路：

上面已经写了**买卖股票的 121  122 题**，关键点在与理解动态规划中`dp`数组的定义。

`dp[i][k][0 or 1]` 的含义就是：`i`表示 在从 `0`到 `i`天，完成了`k`笔交易，此时不持有`0` or 持有 `1`股票，能获取的最大利润为`dp[i][k][0 or 1]`

一定要理解 `i`不是指的仅仅第`i`天，而是时间段从`0`到`i`

`k`表示在这个时间内已经完成了`k`笔交易（如果题目没有对交易次数进行限定，可以不要这个）

`0 和 1`的含义：此时手中的股票是持有还是不持有（意思就是，我买了股票我可以一直拿着不卖，也可以卖掉），到了第`i`天此时股票是拿着还是已经卖了。

注意题目中有个**注意事项**：你不能同时参与多笔交易，也就是你如果现在持有股票，此时如果还想买，就需要先卖掉之前的股票保证是空仓的状态，才能去买其他的（当然，你可以一直空仓，不去进行任何交易）

接下来请理解下面的状态转移方程（其实很简单，用日常的思维去理解）

```java
状态转移方程：
// 不持有股票
// dp[i][k][0] 从 0..i天,完成k笔交易，0表示此时手中没有股票
dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i]) 
// 要达成  dp[i][k][0] 这个状态，其实有两种情况
// 第一种： 从 0...i-1天，完成了k笔交易，并且此时手中也没有股票，到了第i天，我继续保持不交易的不就是 dp[i][k][0]
// 第二种： 从 0...i-1天，完成了k笔交易，并且此时手中持有股票，到了第i天，我要想不持有股票，怎么办？那就在第i天卖掉呀。。既然是卖掉，那利润就要加上 prices[i]的价格即可。


// 持有股票
// dp[i][k][1] 从 0..i天,完成k笔交易，1表示此时手中持有股票
dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i] ) 
// 要达成  dp[i][k][1] 这个状态，其实有两种情况
// 第一种： 从 0...i-1天，完成了k笔交易，并且此时手中持有股票，到了第i天（因为题目中说了不能同时参与多笔交易），所以继续保持持有状态（不可能卖，卖了就不是持有状态了，你也可能说，我当天卖当天买，那不就等于不买不卖吗，是吧。）
// 第二种：从 0...i-1天，完成了 k-1 笔交易，此时手中没有持有股票，到了第i天，买入股票，那么第i天不就可以持有股票了，此时的交易次数 从 k-1 变成了 k 次（买入算一次交易次数，卖出就不用再算交易次数了），既然是买入，利润减去 prices[i]的价格即可
 
```

最终的实现代码如下：

```java
func maxProfit(prices []int) int {
  
    n := len(prices)
  	// 定义 dp数组
    dp := make([][][]int,n) //n天

    for k,_ := range dp {
        dp[k] = make([][]int,3) // 2次交易 0 1 2

        for k1,_:= range dp[k] {
            dp[k][k1] = make([]int,2) // 持有or不持有
        }
    }

   

    for i := 0;i < n;i++ {
      	// k == 0 表示完成0次交易，也就是不会进行交易肯定都是0了，不需赋值了
        for k := 1;k <= 2;k++ {
            if i == 0 {
                dp[0][k][0] = 0 // 不持有
                dp[0][k][1] = -prices[0] // 持有
                continue
            }
            dp[i][k][0] = max(dp[i-1][k][0],dp[i-1][k][1] + prices[i])
            dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i] )
        }
    }
		
  	// 要想利润最大，那肯定是完成多次交易，并且手中不持有股票
    return dp[n-1][2][0] // 在第n-1天，完成2笔交易，并且不持有股票的最大利用
}

func max(a,b int) int {
    if a > b{
        return a
    }
    return b
}
```



## 238. 奇偶链表

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别组合在一起，然后返回重新排序的列表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

![image-20250403190953151](./images/image-20250403190953151.png)

思路：

将原始链表拆分成两个子链表，然后拼接到一起即可。

这里利用 `fast`一次跳跃两个节点：

- `fast`指向的就是奇数索引节点
- `fast.Next`指向的就是偶数索引节点

特殊情况，当`fast`指向尾部最后一个节点时候，`fast.Next`为`nil`,所以需要将这个`fast`指向的节点额外处理，作为奇数索引节点，拼接到`p1.Next`

![image-20250403193605584](./images/image-20250403193605584.png)

```java
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func oddEvenList(head *ListNode) *ListNode {

    p1 := &ListNode{} // 定义头节点，记录奇数节点
    recordP1 := p1

    p2 := &ListNode{} // 定义头节点，记录偶数节点
    recordP2 := p2

    fast := head

    // fast 节点 + fast.Next 都存在的情况下，进行奇偶拼接
    for fast != nil && fast.Next != nil {

        p1.Next = fast // 奇数索引拼接到 p1
        p1 = p1.Next

        p2.Next = fast.Next // 偶数索引拼接到 p2
        p2 = p2.Next

        // 每次跳跃两个节点
        fast = fast.Next.Next
    }

    // 特殊情况，只剩下一个节点的时候（也就是没有 fast.Next,上面的逻辑是不会执行的）
    if fast != nil { // 也可能 fast == nil ，所以不用执行拼接
        p1.Next = fast
        p1 = p1.Next
    }
    // p2需要断开尾部
    p2.Next = nil
    
    p1.Next = recordP2.Next // p1的尾部 拼接上 p2的头部
    return recordP1.Next // 返回p1的头部
}
```

这里再扩展一个变形题：字节跳动常考

给定一个奇数位升序，偶数位降序的链表，将其重新排序。

```
输入: 1->8->3->6->5->4->7->2->NULL
输出: 1->2->3->4->5->6->7->8->NULL
```

题目意思就是偶数索引位置的是降序的，奇数位置是升序的；需要将整个链表排序为升序

解法：

```
1. 按奇偶位置拆分链表，得1->3->5->7->NULL和8->6->4->2->NULL
2. 反转偶链表，得1->3->5->7->NULL和2->4->6->8->NULL
3. 合并两个有序链表，得1->2->3->4->5->6->7->8->NULL
```

按照上面的方法，我们已经可以得到升序的奇数链表和 降序的偶数链表；只需要将偶数链表反转，然后合并两个有序链表为一个升序链表。

链表反转上面已经做过类似的题目，合并两个升序链表也做过，大家可以用来练下手，试试。



## 518. 零钱兑换II

给你一个整数数组 `coins` 表示不同面额的硬币，另给一个整数 `amount` 表示总金额。请你计算并返回可以凑成总金额的硬币组合数。如果任何硬币组合都无法凑出总金额，返回 `0` 。假设每一种面额的硬币有无限个。 题目数据保证结果符合 32 位带符号整数。

思路：

我们可以把这个问题转化为背包问题的描述形式：

有一个背包，最大容量为 `amount`，有一系列物品 `coins`，每个物品的重量为 `coins[i]`，**每个物品的数量无限**。请问有多少种方法，能够把背包恰好装满？

![image-20250403204656314](./images/image-20250403204656314.png)

注意：`i`表示物品的个数，如果要取到该物品，需要`i-1`得到索引



```java
func change(amount int, coins []int) int {
	
		// 定义 dp 数组
    n := len(coins) // n个物品
    dp := make([][]int,n+1)
    for i := 0;i < n+1;i++ {
        dp[i] = make([]int,amount+1) // 背包容量 amount
    }

    // base case
    // 背包容量为0，也就是不需要选择物品，即可完成填充
    for i := 0;i <= n;i++ {
        dp[i][0] = 1 // i个物品，背包容量为0（也就是全都不选择物品，即可完成填充），默认都是1种组合
    }
    // 物品个数为0，肯定就是0，所以不用额外初始化，所以i从1开始
    for i := 1;i <= n;i++ {
        for j := 1;j <= amount;j++ {
						// 看第i个物品，能否装入背包（注意：第i个物品，对应 coins中的i-1的索引）
            if j - coins[i-1] >= 0 { // 说明物品可以装入背包（可以选择装入 or 不装入） 两种组合求和
                dp[i][j] = dp[i-1][j] + dp[i][j-coins[i-1]]
            } else { // 说明物品太大，无法装入（即，选择不装入）
                dp[i][j] = dp[i-1][j]
            }
        }
    }
  
    // n个物品，装满背包amount的组合
    return dp[n][amount]
}
```



## 26. 删除有序数组中的重复项

给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。

考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：

- 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
- 返回 `k` 。

思路：

有序数组中删除重复出现的元素，利用快慢指针的技巧。

我们让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就告诉 `slow` 并让 `slow` 前进一步。这样当 `fast` 指针遍历完整个数组 `nums` 后，**`nums[0..slow]` 就是不重复元素**。

```java
func removeDuplicates(nums []int) int {
  	
  	//注意理解：slow指向的元素是最终结果的尾部元素，fast 用来遍历整个数组
    slow,fast := 0,0

    for fast < len(nums) {
        if nums[fast] != nums[slow] { // 当slow 和 fast指向的元素不相同
            slow++ // slow先前进一步
            nums[slow] = nums[fast] // 然后在slow位置处，保存下来最新不重复元素
        }
        fast++ // fast一直不断的移动
    }
    // [0,slow]指向的就是最终的结果

    return slow+1
}
```



## 75. 颜色分类

给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**[原地](https://baike.baidu.com/item/原地算法)** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。

我们使用整数 `0`、 `1` 和 `2` 分别表示红色、白色和蓝色。

必须在不使用库内置的 sort 函数的情况下解决这个问题。

- 你能想出一个仅使用常数空间的一趟扫描算法吗？

思路：

这题是上面一题快慢指针技巧的进阶。`slow`用来维护最终的结果，`fast`用来遍历整个数组，最后整个数组分成了两个部分，一部分是最终结果，另外一部分是其他数据。（这样只能分成两个部分）

本题，需要将数组分割成3个部分。可以考虑，在数组的左右都维护一个 `slow`指针，用来记录结果。依然用`fast`指针来遍历整个数组。这样，就可以将整个数组分割成3个部分。

本题可以当做一个结论记住即可，这种排序方法也叫三色排序算法。

- `fast`遇到 0 ，和左边交换
- `fast`遇到 1，不交换
- `fast`遇到 2，和右边交换 

```java
func sortColors(nums []int)  {
    // 三色排序；这题我个人觉得解法还是挺实用的
    // 用三个指针，分别指向，头/尾/中

    leftSlow,fast,rightSlow := 0,0,len(nums)-1
    for fast <= rightSlow { // fast 和 rightSlow相遇
      
        if nums[fast] == 0 { // 将0和左边交换
          	
            nums[leftSlow],nums[fast] = nums[fast],nums[leftSlow]
            fast++
            leftSlow++ // 此时 leftSlow指向下一个待保存位置
          
        } else if nums[fast] == 1 { // 1 继续遍历
            fast++
        } else if nums[fast] ==2 { //将2和右边交换
            nums[fast],nums[rightSlow] = nums[rightSlow],nums[fast]
            //index++ 这里注意（一个坑）：2和 rightSlow 位置的元素交换以后，index位置的元素可能是0或1也可能是2 ，从上面知道1  fast++,如果是0，还要和leftSlow 交换，如果是2，那就需要继续和 rightSlow交换
            rightSlow-- // 此时 rightSlow指向下一个待保存位置
        }
    }
}
```

看完算法，估计很多的疑问，我觉得可以对照下图再思考下

本图针对 `nums[fast] ==2`进行解释

![image-20250403221548069](./images/image-20250403221548069.png)

本图针对 `nums[fast] == 0 `

![image-20250403223024171](./images/image-20250403223024171.png)



## LCR 159. 库存管理 III

仓库管理员以数组 `stock` 形式记录商品库存表，其中 `stock[i]` 表示对应商品库存余量。请返回库存余量最少的 `cnt` 个商品余量，返回 **顺序不限**。

**示例 1：**

```
输入：stock = [2,5,7,4], cnt = 1
输出：[2]
```

**示例 2：**

```
输入：stock = [0,2,3,6], cnt = 2
输出：[0,2] 或 [2,0]
```

思路：

本题就是求，在无序的数组中，如何查找最小的两个数字

利用大根堆，堆大小限定为2，当堆容量超过2的时候，弹出堆顶的最大元素，剩下的就是较小的两个元素。当所有的元素遍历一遍，并且都经过大根堆的过滤后，此时大根堆中剩余的两个元素，就是要找的元素。

```java
func inventoryManagement(stock []int, cnt int) []int {
	// 本质就是找，在有序数组中，获取最小的cnt个数值

    maxHeap := &MaxHeap{}

    heap.Init(maxHeap)
    for i := 0;i < len(stock);i++ { // 遍历所有元素

        heap.Push(maxHeap,stock[i]) // 保存到大根堆中
       	
      	// 保证堆中数据为cnt个
       if maxHeap.Len() > cnt { // 超出cnt个，就弹出
            heap.Pop(maxHeap)
       }
    }

    return maxHeap.data // 最后剩下的就是结果（最小的）
}

// 维护大根堆，最后剩下的就是最小的cnt个数

type MaxHeap struct {
    data []int
}

func (t *MaxHeap)Len() int {
    return len(t.data)
}

func (t *MaxHeap)Swap(i,j int) {
    t.data[i],t.data[j] = t.data[j],t.data[i]
}

func (t *MaxHeap)Less(i,j int) bool {
    return t.data[i] > t.data[j]
}

func (t *MaxHeap)Push(x any) {
    t.data = append(t.data,x.(int))
}

func (t *MaxHeap)Pop() any {
    x := t.data[len(t.data)-1]
    t.data = t.data[:len(t.data)-1]
    return x
}
```



## 59. 螺旋矩阵 II

给你一个正整数 `n` ，生成一个包含 `1` 到 `n^2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。

![image-20250404223754800](./images/image-20250404223754800.png)



思路：

本题和 **54.螺旋矩阵**相似。

- 先构建二维数组
- 转圈的方式将数据保存到二维数组中

```java
func generateMatrix(n int) [][]int {


    // 构建 n*n 矩阵
    matrix := make([][]int,n)
    for k := range matrix {
        matrix[k] = make([]int,n)
    }

    left,right := 0,n-1
    top,end := 0,n-1

    val := 1
		
  	// 填入 n*n 个数值
    for val <= n*n {

        if top <= end { // 保证 top 和end不越界
          
            for i:= left;i <=right;i++ { //在上面top 从左到右
                matrix[top][i] = val
                val++
            }
        }
        top++

        if left <=right { // 保证 left 和 right 不越界
            for i := top;i <= end;i++ { //在右边right 从上到下
                matrix[i][right] = val
                val++
            }
        }
        right--


        if top <= end {  // 保证 top 和end不越界
            for i := right; i>=left;i-- { // 在底部end，从右到左
                matrix[end][i] = val
                val++
            }
        }
        end--

        if left <= right { // 保证 left 和 right 不越界
            for i := end;i>= top;i-- { // 在左边 left，从下到上
                matrix[i][left]= val
                val++
            }
        }
        left++
    }
		// 返回二维数组
    return matrix
}
```



## 145. 二叉树的后序遍历

给你一棵二叉树的根节点 `root` ，返回其节点值的 **后序遍历** 。

思路：

尽可能地将左子节点压入栈，直到最左边。然后处理栈顶元素，如果有右子节点且未被处理过，就转向处理右子节点。否则，处理当前节点，并记录pre，防止重复处理。

这样通过栈来模拟递归的过程，同时利用pre变量来标记已经处理过的右子树，避免重复入栈。整个过程能够正确地按照后序遍历的顺序访问所有节点。

那pre的作用是什么呢？比如在处理完某个节点的右子树后，当再次回到该节点时，可以通过pre判断右子树是否已经处理过。比如在例子中的节点2，第一次处理时发现右子节点5未被处理，所以压回栈，然后处理5。当再次处理2时，pre是5，也就是右子节点已经被处理过了，这时候就可以处理节点2自己了。

代码执行示例

```java
树结构：

     1
    / \
   2   3
  / \
 4   5

初始状态:
stack = []
root = 1, pre = nil

步骤1: 1,2,4 入栈
stack = [1->2->4]
root = nil

步骤2: 弹出4 (无右子节点)
result = [4]
pre = 4
stack = [1->2]

步骤3: 弹出2 (发现右子节点5未访问)
stack重新压入2，转向5
stack = [1->2]
root = 5

步骤4: 5入栈后弹出
result = [4,5]
pre = 5
stack = [1->2]

步骤5: 再次弹出2 (右子节点已访问)
result = [4,5,2]
pre = 2
stack = [1]

...（后续步骤类似）
```



```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func postorderTraversal(root *TreeNode) []int {
    result := []int{}
    stack := []*TreeNode{}
		
  	// 目的在于避免右节点重复入栈
    var pre *TreeNode = nil
  
    for len(stack) > 0 || root != nil {
        // 入栈
        for root != nil {
            stack = append(stack,root)
            root = root.Left
        }
      
        // 出栈
        root = stack[len(stack)-1] //栈尾
        stack = stack[:len(stack)-1]
      
        if root.Right == nil || root.Right == pre { //如果发现没有右边节点、或，右边节点重复前一个节点
            //保存结果
            result = append(result,root.Val)
            pre = root // 记录前一个节点
            root = nil // （注意这里：root = nil）再出栈一个新元素
        }else {
            stack = append(stack,root) //入栈
            root = root.Right
        }
    }
    return result
}
```



思路二：

通过递归的方式，这种最简单

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var result []int
func postorderTraversal(root *TreeNode) []int {
    result = []int{}
    traversal(root)
    return result
}

func traversal(root *TreeNode) {

    if root == nil {
        return
    }

    traversal(root.Left)
    traversal(root.Right)
    result = append(result,root.Val)
}
```



## 50. Pow(x,n)

实现 [pow(*x*, *n*)](https://www.cplusplus.com/reference/valarray/pow/) ，即计算 `x` 的整数 `n` 次幂函数（即，`xn` ）。

**示例 1：**

```
输入：x = 2.00000, n = 10
输出：1024.00000
```

**示例 2：**

```
输入：x = 2.10000, n = 3
输出：9.26100
```

思路：

要计算n 个 x相乘，可以先结算 n/2 个x相乘（将问题的规模缩小），知道了 n/2个x相乘的结果 `result`后，只需要将 `result*result`即可。比如我们要求 2 的4次方，可以先去求 2 的 2次方。

要注意：n可能是奇数，所以如果是奇数，需要额外处理一下，将n变成偶数，才能除以2，具体请看下面代码。

```java
func myPow(x float64, n int) float64 {

    if n == 0 {
        return 1 
    }

    if n == 1 {
        return x
    }
    
    if n < 0 {
        return myPow(1/x ,-n) // 转成正数
    }
   
    if n & 1 == 1 { // n%2 == 1 表示奇数
        return  x * myPow(x,n-1)

    } 
    
    // 表示偶数
    result := myPow(x,n/2)
    return result * result
}
```



## LCR 174. 寻找二叉搜索树中的目标节点

某公司组织架构以二叉搜索树形式记录，节点值为处于该职位的员工编号。请返回第 `cnt` 大的员工编号。

思路：

树为二叉搜索树，节点上的数据如果按照中序遍历的方式（左中右），数据是按照递增排列的，方便找第`cnt`小的数

注意题目，要找到第 `cnt`大的数值（不是第 `cnt`小的数值），大的数据在尾部。所以我们可以采用（右中左）的中序遍历方式，让数据按照倒序排列

本题就是考一下逆向的思维，缺失容易让人想当然。

具体看下面代码

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// 方法一：利用递归
var result int
func findTargetNode(root *TreeNode, cnt int) int {
    result = 0
    dfs(root,&cnt)
    return result
}

// cnt的目的在于计数，当 cnt = 0 表示找到了
func dfs(root *TreeNode,cnt *int) {

    if root == nil || *cnt == 0{
        return
    }
		// 中序遍历
    dfs(root.Right,cnt) // 右
  	// 中
    (*cnt)--
    if *cnt == 0 { // 找到数值
        result = root.Val
        return
    }
    dfs(root.Left,cnt) // 左
}

// 方法二：利用栈，迭代的方式
func findTargetNode11(root *TreeNode, cnt int) int {

    stack := []*TreeNode{}

    for root != nil || len(stack) > 0 {
        if root != nil { 
            stack = append(stack,root)
            root = root.Right  // 右节点入栈（正常情况下，应该是左节点入栈）
        } else {
            // 出栈
            root = stack[len(stack)-1]
            stack = stack[:len(stack)-1]
						// 在这里对cnt进行计数
            cnt--
            if cnt == 0 {
                return root.Val
            }
            root = root.Left
        }
    }
    return 0
}
```



## 114. 二叉树展开为链表

给你二叉树的根结点 `root` ，请你将它展开为一个单链表：

- 展开后的单链表应该同样使用 `TreeNode` ，其中 `right` 子指针指向链表中下一个结点，而左子指针始终为 `null` 。
- 展开后的单链表应该与二叉树 [**先序遍历**](https://baike.baidu.com/item/先序遍历/6442839?fr=aladdin) 顺序相同。

思路：

这题的关键在于理解 `flatten`函数的定义

**给 `flatten` 函数输入一个节点 `root`，那么以 `root` 为根的二叉树就会被拉平为一条链表**。

如何利用这个定义来完成算法？你想想怎么把以 `root` 为根的二叉树拉平为一条链表？

很简单，以下流程：

1、将 `root` 的左子树和右子树拉平。

2、将 `root` 的右子树接到左子树下方，然后将整个左子树作为右子树。

至于如何把 `root` 的左右子树拉平，不用你操心，`flatten` 函数的定义就是这样，交给他做就行了。

所以，在用递归方式解题的关键，就在于递归函数的定义，将复杂问题，简化为一个子问题，只要把子问题解决了，整个问题全部解决了。

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

//定义：flatten 以 root为根的树拉平为链表
func flatten(root *TreeNode)  {
    if root == nil {
        return
    }
    //把左子树拉平为链表
    flatten(root.Left)
    //把右子树拉平为链表
    flatten(root.Right)

    
    l := root.Left
    r := root.Right

    root.Left = nil //左边设置为空
    root.Right = l //左边代替右边

    //把剩下的右边r拼接到root.Right（这个其实就是原来的左边）链表的尾部
    p := root
    for p.Right != nil { //找到链表的最后一个节点
        p = p.Right
    }
    p.Right = r //拼接
}
```



## 572. 另一棵树的子树

给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。

二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。

思路：

注意：题目要求和`subRoot` 具有相同结构和节点值的子树，而不是存在和 `subRoot`重叠的部分。注意看下示例`2`的例子，只是有重叠，而不是相同的子树。

-  将 `subRoot`进行序列化为一个字符串
- 分别对`root`中的各个子树进行序列化，对比字符串是否相同

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

func isSubtree(root *TreeNode, subRoot *TreeNode) bool {
    return isSub(root,encodeTree(subRoot))  // encodeTree(subRoot) 对 subRoot进行序列化
}

func isSub(root *TreeNode, str string) bool {
    
  	// 对 root 进行序列化，判断是否和 str 相同
    if encodeTree(root) == str {
        return true
    }
		// root == nil 就不存在左右子树
    if root == nil {
        return false
    }
  	// 分别对 root.Left  root.Right  序列化 结果和 str 比较
    return isSub(root.Left,str) || isSub(root.Right,str)
}


// 对树序列化
func encodeTree(root *TreeNode) string {
    if root == nil {
        return "#"
    }
    return strconv.Itoa(root.Val) +"," + encodeTree(root.Left) +","+ encodeTree(root.Right)
}
```



## 440. 字典序的第K小数字

给定整数 `n` 和 `k`，返回 `[1, n]` 中字典序第 `k` 小的数字。

**示例 1:**

```
输入: n = 13, k = 2
输出: 10
解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
```

**示例 2:**

```
输入: n = 1, k = 1
输出: 1
```

思路：

这题确实挺难，建议多看几遍记住即可。边看代码边对照逻辑示例对比看

        这里用举例的方式解释代码的逻辑：
        
        比如n = 13 k=8 
        字典序： 1 10 11 12 13 2 3 4 5 6 7 8 9 
        按照上面的字典序，k=8的位置，就是数字 4
        
        实际的解法：就是构建一个多叉树的结构
        树的根部为：虚拟的节点0
                   0
                1     2
             [0..9] [0..9]   
    
        1和2相当于0的两个子树（分叉）；
        左子树都是以1开头的数字（也就是以1开头的数字都在1树下）；构成 1 10 11 12 13 ...
        右子树都是以2开头的数字（也就是以2开头的数字都在2树下）; 构成 2 ...
        
        题目要求找第k个数值
        那么就需要知道数值，在哪个树里面（也就需要知道子树中节点的个数）如果k=8;以1为根的子树，里面只有5个节点（即 1 10 11 12 13）；说明要找的数值不在左子树中，那就从1的右边树找，那就是以2为根的子树；
    
        1树中共有5个节点；我要找第8个，那等价于在2树中 找8-5= 3（第3个）相当于把问题，落在了每一个子树中找对应的节点；
    
        怎么知道一棵树有多少个节点呢？只需要知道每一层有多少个节点（所有的层加一起，就是整个树的节点数）；【找每一层的最小节点值和最大节点值 求差】，这里还有一个限制条件，就是 题目给定的整数n（不能超过n+1） 
        
         													0
               			 		1     							2
              0 1 2 3 4 5 6 7 8 9   0 1 2 3 4 5 6 7 8 9
        比如：左子树1，根节点为1，最左边节点为1，最右边节点为2，本层也就是 2-1=1个节点
        继续下一层本层的最左边节点为10，最右边的节点为 20，所以 20-10=10个节点
        所以，得出左子树1中，一共有 11 个节点（即： 1  10 11 12 13 14 15 16 17 18 19）


```java
func findKthNumber(n int, k int) int {
   

    cur := 1 // cur 看作每棵树的根节点

    for k != 1 { // k表示我们要第k个数值，当k==1的时候，就是要找的数值
        //计算以当前的cur作为根节点的数值有多少个，是否满足k的个数
        left,right := cur,cur+1 // left表示每一层的最左边的节点，right表示每一层的最右边的节点
        nodeNum := 0 // 计算出以cur为起点的节点个数，包括cur这个节点
        for left <= n { // left没有超过n，说明层数还没有找完；
          // right的值，不能越界 n+1 (也就是整个数值最大值就是n)
           nodeNum +=  min(n+1,right) - left // 这个计算每一层的节点数
           // 下一层
           left *= 10
           right *= 10
        }

        if nodeNum < k { // 说明当前cur节点，拥有的节点个数太少了；我们需要换棵树；
            k -= nodeNum
            cur++ // 换到另外一棵树（比如上面例子的 右子树 2）
        } else {
            // 执行到这里，说明cur为节点的树中包括k个节点；
            k-- // 表示去掉cur节点；
            cur *= 10 // 然后去本树的下层节点开始找第k个节点；首先当前cur节点肯定不是要找的，如果是要找的k== 1,那就跳出循环了；这里就是以1下面的0作为新的根节点，同时对于1下面的0节点而言，他旁边的1就算是其他的树了；
       /*
           1       
        [0..1 9] 
        */     
        }
    }
  
    return cur
}

func min(a ,b int) int{
    if a < b{
        return a
    }

    return b
}
```



## 450. 删除二叉搜索树中的节点

给定一个二叉搜索树的根节点 **root** 和一个值 **key**，删除二叉搜索树中的 **key** 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

1. 首先找到需要删除的节点；
2. 如果找到了，删除它。

思路：

1. 先找到`key`节点

2. 删除节点 分成3种情况
   节点没有子节点（直接删除）
   节点仅有一个子节点（子节点代替自己）
   节点有两个子节点（选择左子树最大值 or 右子树最小值 代替自己保证BST的性质不变）

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

 // 在root树中删除key节点，返回树的根节点
func deleteNode(root *TreeNode, key int) *TreeNode {
    
    if root == nil {
        return root
    }
    // 当前的根节点，就是要找的key
    if root.Val == key { 

        // 没有左子树
        if root.Left == nil {
            return root.Right 
        }
        // 没有右子树
        if root.Right == nil {
            return root.Left
        }

        // 执行到这里，说明左右子树都不为nil,从右子树找到最小节点（目的：作为当前节点的替换节点）
        minNode := getMin(root.Right)
        // 先从右子树中删除 minNode节点
        root.Right = deleteNode(root.Right,minNode.Val)

        // 用minNode节点，替换root位置
        minNode.Left = root.Left
        minNode.Right = root.Right
				// 将 minNode作为新的root
        root = minNode

    } else if root.Val > key { // 要找的 key 在左子树中
        root.Left = deleteNode(root.Left,key) // 从左子树中删除key，并将新的根节点和 root.Left拼接到一起
    } else { // 要找的 key 在右子树中
        root.Right = deleteNode(root.Right,key)// 从右子树中删除key，并将新的根节点和 root.Right 拼接到一起
    }
    return root
}

// 找右子树的最小节点
func getMin(root *TreeNode) *TreeNode {

    for root.Left != nil {
        root = root.Left
    }
    return root
}
```



## 125. 验证回文串

如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。

字母和数字都属于字母数字字符。

给你一个字符串 `s`，如果它是 **回文串** ，返回 `true` ；否则，返回 `false` 。

**示例 1：**

```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```

**示例 2：**

```
输入：s = "race a car"
输出：false
解释："raceacar" 不是回文串。
```

思路：

这道题很简单，只要先把所有字符转化成小写，并过滤掉空格和标点这类字符，然后对剩下的字符执行 **两端向中心的双指针算法**即可。

```java
func isPalindrome(s string) bool {
    // 1.大写转小写，并去掉 非【字母+数字】字符
		
  	// tempStr 存储转换后的结果
    tempStr := []byte{}
    for i := 0;i < len(s);i++ {
        c := 	convert(s[i]) 
        if c != ' ' { // 不是空字符，存储到 tempStr中
            tempStr = append(tempStr,c)
        }
    }

    // 双指针技巧
    left,right := 0,len(tempStr)-1
    for left <= right {
        if tempStr[left] == tempStr[right] {
            left++
            right--
        } else {
            return false
        }
    }

    return true
}

func convert(c byte) byte {
		// 小写原样
    if c >= 'a' && c <= 'z' {
        return c
    }
		// 大写转小写
    if c >= 'A' && c <= 'Z' {

        return 'a' + (c - 'A')
    }
    // 数字原样
    if c >= '0' && c <='9' {
        return c
    }
		// 其他字符输出空
    return ' '
}
```



## 91. 解码方法

一条包含字母 `A-Z` 的消息通过以下映射进行了 **编码** ：

```
"1" -> 'A' "2" -> 'B' ... "25" -> 'Y' "26" -> 'Z'
```

然而，在 **解码** 已编码的消息时，你意识到有许多不同的方式来解码，因为有些编码被包含在其它编码当中（`"2"` 和 `"5"` 与 `"25"`）。

例如，`"11106"` 可以映射为：

- `"AAJF"` ，将消息分组为 `(1, 1, 10, 6)`
- `"KJF"` ，将消息分组为 `(11, 10, 6)`
- 消息不能分组为 `(1, 11, 06)` ，因为 `"06"` 不是一个合法编码（只有 "6" 是合法的）。

注意，可能存在无法解码的字符串。

给你一个只含数字的 **非空** 字符串 `s` ，请计算并返回 **解码** 方法的 **总数** 。如果没有合法的方式解码整个字符串，返回 `0`。

题目数据保证答案肯定是一个 **32 位** 的整数。

**示例 1：**

```
输入：s = "12"
输出：2
解释：它可以解码为 "AB"（1 2）或者 "L"（12）。
```

**示例 2：**

```
输入：s = "226"
输出：3
解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。
```

思路：

本次采用动态规划的思路：核心在于理解`dp`数组的定义（也就是先思考局部的解码问题，然后推广为一般的解法）

```java
dp的定义：

dp[i][0]: i表示从[0,i]的字符串，0表示把s[i]作为一个字符进行解码，那么能得到的解码方法的总数
dp[i][1]: i表示从[0,i]的字符串，1表示把s[i-1]s[i]两个字符一起进行解码，那么能得到的解码方法的总数

即： 从[0,i]的字符串,尾部单独解码（还剩下前面的i-1个）的解码方法数 or 两个一起解码（还剩下前面的i-2个）的解码方法数，【求和】

// 一般递推关系
// i单独解码的解码总数 = i-1 可以单独 加上  i-2 i-1一起解码
dp[i][0] = dp[i-1][0] + dp[i-1][1] 

// i-1和i一起解码总数 = i-2单独解码  加上   i-3 i-2一起解密
dp[i][1] = dp[i-2][0] + dp[i-2][1]

// 特殊情况
当i单独解码，并且s[i] == 0,是不对的解码方式，dp[i][0] = 0
当 i-1/i一起解码，并且s[i-1]s[i]的取值范围不在【10，26】，是不对的解码方式 dp[i][1] = 0

```

具体请看下面代码（本题看完代码不难理解，但是细节比较多）

```java
func numDecodings(s string) int {

   
    n := len(s)
    dp := make([][]int,n)
    for k := range dp {
        dp[k] = make([]int,2)
    }

    // base case
		
  	// 单独编码
    if s[0] == '0' { // 注意 字符是 0的情况
        dp[0][0] = 0
    } else {
        dp[0][0] = 1 
    }
  	// 联合解码
    dp[0][1] = 0 // 没有s[-1]所以为0


    for i := 1;i < n;i++ { // 这里从1开始【注意】

        // 单独编码
        if s[i] == '0' { 
            dp[i][0] = 0
        } else {
            dp[i][0] = dp[i-1][0] + dp[i-1][1] 
        }
        
        // 联合编码
        num := s[i-1:i+1] 
        // 当获取两个字符的时候，这两个字符一定处于 [10...26]之间的数字，可以用字符串进行比较
        if num >= "10" && num <= "26" { // 过滤了 "06"的情况

            if i == 1 { // 越界的特殊情况
                dp[i][1] = 1
            } else {
                dp[i][1] = dp[i-2][0] + dp[i-2][1]
            }
        } else {
            dp[i][1] = 0
        }
    }

    return dp[n-1][0] + dp[n-1][1]
}
```



## LCR 143. 子结构判断

给定两棵二叉树 `tree1` 和 `tree2`，判断 `tree2` 是否以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。
注意，**空树** 不会是以 `tree1` 的某个节点为根的子树具有 **相同的结构和节点值** 。

思路：

这题注意和 **572. 另一棵树的子树**进行区别。这里只需要存在相同的结构和节点值即可，不需要完全一模一样的子树结构。

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
// 函数定义：A中是否包含B这个子结构 (子结构：表示存在相同部分，而不需要完全一模一样的子树)
func isSubStructure(A *TreeNode, B *TreeNode) bool {

    if A == nil && B == nil { // 同时是空
        return true
    } 

    if A == nil || B == nil { // 约定空树不是任意一个树的子结构
        return false
    }
    // 执行到这里，说明A和B都不为空

    // isSame(A,B) 判断A和B是否相同（如果相同，说明是子结构）；如果不相同没关系，同时看下A的【左边或者右边】是否存在B这个子结构，只要有一个满足即可
    return isSame(A,B) || isSubStructure(A.Left,B) || isSubStructure(A.Right,B)

}


// 定义递归函数：以a和b作为【起点】的两棵树是否重叠（相同）
func isSame( a,b *TreeNode) bool {
    if b == nil { // 说明b树是空，不管a是否有值，说明都是a包含b的关系
        return true
    }
    if a == nil && b != nil {
        return false
    }

    if a.Val != b.Val { // 执行到这里a和b一定都不是nil，如果两个节点值不同，说明不重叠
        return false
    }

    return isSame(a.Left,b.Left) && isSame(a.Right,b.Right) // 如果a和b相同，再分别看下左右节点是否也相同
}
```



## LCR 127. 跳跃训练

今天的有氧运动训练内容是在一个长条形的平台上跳跃。平台有 `num` 个小格子，每次可以选择跳 **一个格子** 或者 **两个格子**。请返回在训练过程中，学员们共有多少种不同的跳跃方式。

结果可能过大，因此结果需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

**示例 1：**

```
输入：n = 2
输出：2
```

**示例 2：**

```
输入：n = 5
输出：8
```

思路：

本题和 **70. 爬楼梯** 是相同题目

`dp[i]`表示：跳到第`i`个格子的方式。我们可以选择从第`i-1`个格子跳跃一次到 `i`，也可以选择中第`i-2`个格子跳跃一次到`i`。

```java
func trainWays(num int) int {

    // dp[i] = dp[i-1] + dp[i-2]
    // num 表示格子个数

    dp := make([]int,num+1)

    for i := 0;i < num+1;i++ {
        if i == 0 {
            dp[i] = 1 // 第0个格子，其实就是没有格子（所以不要跳跃，即默认1种跳跃方式）
        } else if i == 1 {
            dp[i] = 1
        } else {
            dp[i] = (dp[i-1] + dp[i-2]) % 1000000007 
        }
    }
    return dp[num] 
}
```



## 329. 矩阵中的最长递增路径

给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。

思路：

- 理解 `dp[i][j]`的含义：作为备忘录，用来记录从 `i,j` 出发，最长递增路经的值（避免重复计算）
- 理解`dfs`函数的定义： 从 `i,j` 出发的最长递增路经长度

一般递推关系

```tex

在保证【上下左右】不越界的情况下，如果【上下左右】的值比 matrix[i][j] 大，说明递增路径可以+1

	// 上
	if i-1 >= 0 && matrix[i-1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i-1,j,m,n,dp) + 1)
	}

	// 下
	if i+1 < m && matrix[i+1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i+1,j,m,n,dp) + 1)
	}

	// 左
	if j-1 >= 0 && matrix[i][j-1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j-1,m,n,dp) + 1)
	}

	// 右
	if j+1 < n && matrix[i][j+1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j+1,m,n,dp) + 1)
	}
```

这题其实和岛屿问题有点点类似，只是这里额外定义了一个`dp`数组，用来记录每个`i,j`位置的，最大递增长度

```java

var result int

func longestIncreasingPath(matrix [][]int) int {
	

	m, n := len(matrix), len(matrix[0])
    // 定义 dp 数组
	dp := make([][]int, m)
	for i := range dp {
		dp[i] = make([]int, n)
	}

	result := 0
  
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			// 从每个i,j元素出发，在resut中记录下 最最最最最最 大的路径值
			result = max(result, dfs(matrix, i, j, m, n,dp))
		}
	}
	return result
}

//dfs函数的定义： 从 i,j 出发的最长递增路经长度
func dfs(matrix [][]int, i, j, m, n int, dp [][]int) int {

  // 默认 dp[i][j] 中的值为0
	if dp[i][j] != 0 {  // 说明已经处理过了
		return dp[i][j] // 直接返回
	}

	// dp[i][j] == 0 说明是第一次处理该节点，默认长度为1（也就是i,j这个数字本身）
	dp[i][j] = 1

	// 上
	if i-1 >= 0 && matrix[i-1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i-1,j,m,n,dp) + 1) // 上面的最大长度 + 1 和 dp[i][j] 比较，作为最大值
	}

	// 下
	if i+1 < m && matrix[i+1][j] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i+1,j,m,n,dp) + 1)// 下面的最大长度 + 1 和 dp[i][j] 比较，作为最大值
	}

	// 左
	if j-1 >= 0 && matrix[i][j-1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j-1,m,n,dp) + 1)// 左面的最大长度 + 1 和 dp[i][j] 比较，作为最大值
	}

	// 右
	if j+1 < n && matrix[i][j+1] > matrix[i][j] {
		dp[i][j] = max(dp[i][j], dfs(matrix,i,j+1,m,n,dp) + 1)// 右面的最大长度 + 1 和 dp[i][j] 比较，作为最大值
	}

    // dp[i][j] 中保存的就是遍历过上下左右，得到的i，j位置的最大长度
    return dp[i][j]
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```



## 445. 两数相加 II

给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

![image-20250407004546889](./images/image-20250407004546889.png)

思路：

这道题是** 2. 两数相加 **的进阶问题，我们模拟加法运算当然是从最低位开始加，这样才能正确的处理进位。但现在单链表的开头是最高位，那么最直接的想法就是先  翻转链表，这样就可以继续玩第 2 题那一套了，没什么难度。

不过本题也说了，如果不让你反转链表怎么办？其实也好办，我们可以利用栈这种先进后出的数据结构，把链表节点从头到尾放进栈中，再从栈拿出来就是从尾到头的顺序，相当于是反转链表的效果，然后又回到了第 2 题的加法逻辑。

还有一个需要注意的是，计算结果的高位也应该放在结果链表的左侧，也就是插入到 `dummy` 节点的后面。具体看代码吧。

```java
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    

    sk1,sk2 := []int{},[]int{}
		
  	// 入栈 l1链表
    p1 := l1
    for p1 != nil {

        sk1 = append(sk1,p1.Val)
        p1 = p1.Next
    }
		// 入栈 l2 链表
    p2 := l2
    for p2 != nil {

        sk2 = append(sk2,p2.Val)
        p2 = p2.Next
    }
	
  
  	// 定义 dummy节点
    dummy := &ListNode{Val:0,Next:nil}
    

    carry := 0 // 进位

    for len(sk1) != 0 || len(sk2) != 0 || carry != 0 {

        sum := 0
      	
        sum += carry
     		// 出栈求和
        if len(sk1) != 0 {
            sum += sk1[len(sk1)-1]
            sk1 = sk1[:len(sk1)-1]
        }
				// 出栈求和
        if len(sk2) != 0 {
            sum += sk2[len(sk2)-1]
            sk2 = sk2[:len(sk2)-1]
        }
       
        carry = sum / 10 // 进位
        val := sum % 10 // 余数
        
        // 将节点拼接到 dummy 后面（注意这里放置的位置）
        node := &ListNode{Val:val,Next:nil}
        node.Next = dummy.Next
        dummy.Next = node
    }
		
    return dummy.Next
}
```



## 442. 数组中重复的数据

给你一个长度为 `n` 的整数数组 `nums` ，其中 `nums` 的所有整数都在范围 `[1, n]` 内，且每个整数出现 **最多****两次** 。请你找出所有出现 **两次** 的整数，并以数组形式返回。

你必须设计并实现一个时间复杂度为 `O(n)` 且仅使用常量额外空间（不包括存储输出所需的空间）的算法解决此问题。

**示例 1：**

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[2,3]
```

**示例 2：**

```
输入：nums = [1,1,2]
输出：[1]
```

思路：

这道题就用常规的解法做吧，用哈希集合（也就是`map`)很容易找到 `nums` 中那些重复的元素。

但是题目要求使用常量的额外空间（看到这个，就是要我们直接在原始数组上做文章）

因为题目说 `nums` 中的元素取值都在 `[1, n]` 之间，即元素本身就和索引成映射关系，所以可以用 `nums` 本身模拟哈希集合的效果

![image-20250407014506318](./images/image-20250407014506318.png)

注意：用乘 -1 的方式给索引做标记的前提是，`nums` 中的元素都为正数，不能包含 0，否则无法区分该索引是否被标记。

```java
func findDuplicates(nums []int) []int {

	res := []int{}

   // 将每个数减 1 当作索引值，看下索引对应的 数值是否是负数，如果是负数，说明已经存在相同的数值，否则将值设定为负
	for i := 0; i < len(nums); i++ {
		
		idx := abs(nums[i]) - 1
		if nums[idx] > 0 { // 不是负数，要标记为负数；
			nums[idx] = -nums[idx]
		} else { // 是负数，说明当前元素是重复元素
			res = append(res, abs(nums[i]))
		}
	}
	return res
}

// 因为设定负数的原因，需要先转成正数
func abs(a int) int {
	if a < 0 {
		return -a
	}
	return a
}
```



## 45. 跳跃游戏 II

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:

- `0 <= j <= nums[i]` 
- `i + j < n`

返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。

思路：

本题采用动态规划的思路，最简单容易理解

- 定义`dp[i]`：表示从`0`跳跃到`i`位置的最小跳跃次数
- 当前如果就处于`0`位置，就不需要跳跃，所以`dp[0] = 0`
- 当位于`i`位置的时候，我可以选择从`[0,i-1]`任意位置（前提能跳跃到`i`)跳跃到`i`位置，当然我们只需要记录下最小的次数即可

```java
func jump(nums []int) int {
   

    n := len(nums)
    
    // 定义dp数组
    dp := make([]int,n)
    //初始化dp数组，跳跃的次数为无穷大的数（n即可）跳跃次数肯定是不会大于n的
    for k,_ := range dp { 
        dp[k] = n
    }

    dp[0] = 0 // base case 不用跳跃

    for i := 1;i < n;i++ {
        for j :=0;j < i ;j++ { // i之前的j跳跃到i位置(找最小的记录下来)

            if j + nums[j] >= i { // 说明从j位置可以跳跃到i位置
                dp[i] = min(dp[j]+1,dp[i])
            }
        }
    }
    return dp[n-1]
}

func min(a,b int) int {
    if a < b {
        return a
    }
    return b
}
```



## LCR 121. 寻找目标值-二维数组

`m`*`n` 的二维数组 `plants` 记录了园林景观的植物排布情况，具有以下特性：

- 每行中，每棵植物的右侧相邻植物不矮于该植物；
- 每列中，每棵植物的下侧相邻植物不矮于该植物。

 请判断 `plants` 中是否存在目标高度值 `target`。

思路：

本题和 **240. 搜索二维矩阵II**相同。

我们不要从左上角开始，而是从右上角开始，规定只能向左或向下移动。

你注意，如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话我们就可以根据当前位置的元素和 `target` 的相对大小来判断应该往哪移动，不断接近从而找到 `target` 的位置。

```java
func findTargetIn2DPlants(plants [][]int, target int) bool {
    row := len(plants) // 获取行数
    if row == 0 { // 特殊情况，如果row=0,直接不存在二维数组，直接返回
        return false
    }
    
    column := len(plants[0]) //获取列数

    i,j := 0,column-1 // 第0行第n-1列(从右上角开始遍历二维数组)

    for i <  row && j >= 0 {

        if plants[i][j] == target {
            return true
        } else if plants[i][j]  < target {
            i++ // 下行的数据更大
        } else {
           j-- // 左列的数据更小
        }
    }
    // 没找到，默认返回 false
    return false
}
```



## LCR 161. 连续天数的最高销售额

某公司每日销售额记于整数数组 `sales`，请返回所有 **连续** 一或多天销售额总和的最大值。

要求实现时间复杂度为 `O(n)` 的算法。 

**示例 1：**

```
输入：sales = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：[4,-1,2,1] 此连续四天的销售总额最高，为 6。
```

**示例 2：**

```
输入：sales = [5,4,-1,7,8]
输出：23
解释：[5,4,-1,7,8] 此连续五天的销售总额最高，为 23。
```

思路：

本题和**53. 最大子数组和**一样的题解。

- 定义`dp[i]`表示：以`i`为【结尾】的子数组的最大和（ 潜在含义：子数组求和，是必须以`soles[i]`作为尾部元素的子数组 ）

- 数组中的每个元素，都可以看做一个单独的子数组（只有一个元素）。所以，子数组和的初始值，就是只包含一个元素的值。

- 一般递推关系

  `dp[i] = max(dp[i-1],0) + sales[i]`

  `sales[i]`的含义：`dp[i]`处的子数组和，在子数组中，当只包含`sales[i]`这一个元素的时候，就是初始子数组和

  `max(dp[i-1],0)`的含义：如果`dp[i-1]`的子数组和小于`0`和 `sales[i]`元素进行拼接，只会让 `dp[i]`变的更小，所以，小于`0`需要舍弃

  

```java
func maxSales(sales []int) int {
   
    dp := make([]int,len(sales))
		
  	// base case 
  	// 第一个元素，子数组和就是 sales[0]
    dp[0] = sales[0]
  	// 初始最大值就是 sales[0]
    result := sales[0]

    for i := 1;i < len(sales);i++ {
      // dp[i] 子数组和 = 前面 dp[i-1]子数组和 (前提：需要dp[i-1]>0，否则只会让 dp[i]变的更小，还不如不要前面的子数组，只保留 sales[i]这个单独的元素构成子数组) + 当前位置元素的值 sales[i]
        dp[i] = max(dp[i-1],0) + sales[i]
        
      	// 比较留下，最大值
        result = max(dp[i],result)
    }
    return result
}

func max(a,b int) int {
    if a > b{
        return a
    }
    return b
}
```



## 135. 分发糖果

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

**示例 1：**

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

思路：

- 构造`candyVec`数组，初始值都是`1`

  ![image-20250407214329999](./images/image-20250407214329999.png)

- 从左到右遍历 `ratings`数组，`if ratings[i] > ratings[i-1]`  说明 右边 `i`> 左边 `i-1`    `candyVec[i] = candyVec[i-1] + 1`  即，右边`i`得到的糖果肯定是要比左`i-1`多一个

  ![image-20250407214830381](./images/image-20250407214830381.png)

- 从右向左遍历 `if ratings[i] > ratings[i+1]` 说明左边`i` >右边`i+1` ，所以 `candyVec[i] = candyVec[i+1] + 1`

  最后`candyVec[i]`位置处的值，取【两个结果中的最大值`max`】

  ![image-20250407215102274](./images/image-20250407215102274.png)

```java
func candy(ratings []int) int {
    
  	// candyVec 用来记录每个孩子得到的糖果数量
    candyVec := make([]int,len(ratings))
    for k,_ := range candyVec { // 初始化为1
        candyVec[k] = 1
    }

    for i := 1;i < len(ratings);i++ { // 从左向右遍历
        if ratings[i] > ratings[i-1] { // 如果i大于左边i-1的数值，说明i的评级高，那么得到的糖果一定要大于i-1
            candyVec[i] = candyVec[i-1]+1
        }
    }       

    for i := len(ratings)-2;i >= 0;i-- { // 从右向左遍历
        if ratings[i] > ratings[i+1]{ // 如果i大于右边的，说明i的评级高，那么得到的糖果一定要大于i+1
            candyVec[i] = max(candyVec[i],candyVec[i+1]+1) //取最大值的原因：这样才能满足，i得到的糖果数量，既满足大于左边，又满足大于右边；
        }
    }

    result := 0
		// 统计 candyVec 中所有的糖果数量
    for _,v := range candyVec {
        result += v
    }
    return result
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```



## LCR 126. 斐波那契数列

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

思路：

这题属于基础题型，是动态规划题型入门的基础。

- 定义一个`dp`数组：`dp[i]`表示前面两项数字之和（`dp`数组的定义需要大家在写整个代码的过程中，要时刻记住 & 理解）

- 推导一般的递推关系（当然这题已经直接给出了递推关系）

   `dp[i] = dp[i-1] + dp[i-2]`

```java

func fib(n int) int {
    
    dp := make([]int,n+1)
    for i := 0; i <= n;i++ {
        if i == 0 { // base case 
            dp[i] = 0
        } else if i == 1 {
            dp[i] = 1 // base case
        } else{
          	 // 递推关系
             dp[i] = (dp[i-1] + dp[i-2]) % 1000000007 // 这个是题目要求【取模】
        }
    }
  	
    return dp[n]    
}
```



## 圆环回原点问题

圆环上有10个点，编号为0~9。从0点出发，每次可以逆时针和顺时针走一步，问走n步回到0点共有多少种走法。

```
输入: 2
输出: 2
解释：有2种方案。分别是0->1->0和0->9->0
```

思路：

本题在`leetcode`上没有对应题，这里作为补充题。

这题的理解可以先去做下**第`70`题爬楼梯**问题（有助于理解本题）。

题目要求走`n`步到`0`点的方案数，那我们可以考虑【走 `n-1`到`1`的方案数】 和 【走`n-1`步到`9`的方案数】，因为分别只需要单独再走一步，就可以到`0`点了（因为是个圆环）。

因此，若设`dp[i][j]`为，经过`i`步，从`0`到达位置`j` 的方案数（其中，`i`表示步数，`j`表示位置）

一般递推关系为：

`dp[i][j] = dp[i-1][(j-1 + length)%length] + dp[i-1][(j+1) % length]`

因为是一个圆环：

`(j-1 + length)%length`：表示位置`j`的左边一位

`(j+1) % length`：表示位置 `j`的右边一位

最终要求的结果为`dp[n][0]`的值

```java
package main

import "fmt"

func main() {
	// dp[i][j] 定义：经过i步，从0到达位置j 的方案数
	//一般递推函数 dp[i][j] = dp[i-1][(j+1)% length] + dp[i-1][(j-1+length)% length]

	length := 10 // 圆环点数量
	n := 2       // n表示步数

	dp := make([][]int, n+1)
	for k := range dp {
		dp[k] = make([]int, length)
	}

	dp[0][0] = 1 // base case 一种方案（保持不动,即可）

	for i := 1; i < n+1; i++ {
		for j := 0; j < length; j++ {

			dp[i][j] = dp[i-1][(j+1)%length] + dp[i-1][(j-1+length)%length]
		}
	}

	fmt.Println(dp[n][0])
}

```



## 347. 前 K 个高频元素

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1:**

```
输入: nums = [1,1,1,2,2,3], k = 2
输出: [1,2]
```

思路：

-  先用`map`记录数值和出现的频率
- 定义个频率数组，索引就是频率（这里的频率数组可以看作一个桶，用来装数值）
- 倒序从频率数组中获取`k`个元素即可（倒序的原因，因为数组尾部的频率更大，题目要找的也是出现次数多的数）

```java
func topKFrequent(nums []int, k int) []int {
    
    // map记录数值->频率的关系
    m := make(map[int]int)
    for _ , num := range nums {
        m[num]++
    }

    // 然后定义一个频率数组，索引为出现的频率（最大的频率无外乎所有的元素都是同一个元素）所以最大的频率索引是len(nums)
    freqArray := make( [][]int,len(nums)+1 ) // 二维数组：频率-> 同频率的一堆数值

    for val, freq := range m {
        freqArray[freq] = append(freqArray[freq],val)
    }

    // 然后倒序从freqArray中找到k个元素即可 
    result := []int{}
    for i := len(freqArray)-1;i >= 0;i-- { // 从后往前 第i个频率

        for j := 0;j < len(freqArray[i]);j++ { // 频率下的数值
            
            result = append(result,freqArray[i][j])
            if len(result) == k { // 结果为k说明找到了k个高频单词
                return result
            }
        }
    }

    return result
}
```



## 10. 正则表达式匹配

给你一个字符串 `s` 和一个字符规律 `p`，请你来实现一个支持 `'.'` 和 `'*'` 的正则表达式匹配。

- `'.'` 匹配任意单个字符
- `'*'` 匹配零个或多个前面的那一个元素

所谓匹配，是要涵盖 **整个** 字符串 `s` 的，而不是部分字符串。

**示例 1：**

```
输入：s = "aa", p = "a"
输出：false
解释："a" 无法匹配 "aa" 整个字符串。
```

思路：

正则表达算法问题只需要把住一个基本点：看 `s[i]` 和 `p[j]` 两个字符是否匹配，一切逻辑围绕匹配/不匹配两种情况展开即可。

- 定义`dp[i][j]`为：长度为`i`的字符串 和 长度为`j`的字符串 是否匹配

字符串的匹配分成以下几种情况：(注意：**这里的`i`和`j`都是长度，转化成索引需要`i-1 j-1`**)

- 当 `s[i-1] == p[j-1] || p[j-1] == '.'`

  此时长度为`i`的字符串 和 长度为`j`的字符串 是否匹配，只需要看长度为`i-1`的字符串 和 长度为`j-1`的字符串 是否匹配 ，即`dp[i][j] = dp[i-1][j-1]`

  ![image-20250410222130272](./images/image-20250410222130272.png)

- 当 `p[j-1] == '*'`

  需要注意理解题目中`*`的含义：表示前面的字符重复的次数 `0`次 or `1`次 or 多次，比如`a*` 表示的含义为 没有`a` 或者只有一个`a` 或者 无数个`a`。所以，看到`*`出现的时候，需要看`*`号前面的字符是什么，也就是`*`本身不代表任何“字符含义”，只是表示前面字符重复的次数

  ![image-20250411014423423](./images/image-20250411014423423.png)

  当`p[j-1] == '*'` 前提下

  如果 `s[i-1] == p[j-2]  或者  p[j-2] == '.'`

  如上：说明字符串`p`中的 `c*`  可以和 字符串`s`中的 `c` 做匹配

  ```java
  方案一：c* 和 c 只完成一次匹配 ，
  字符串s剩余 ab
  字符串p剩余ab
  那么 dp[i][j] = dp[i-1][j-2]
  
  方案二： c*和 c 完成匹配后，继续用c*（*表示字符c可以无限次使用）和剩余的字符串s匹配
  字符串s剩余ab
  字符串p剩余 abc*  
  那么 dp[i][j] = dp[i-1][j]
  
  方案三： c*不和 c匹配，也就是忽略 c*的存在（*可以表示字符c 出现零次）
  字符串s剩余 abc
  字符串p剩余 ab
  那么 dp[i][j] = dp[i][j-2]
  ```

  

  

```java
func isMatch(s string, p string) bool {
	/*
		    dp[i][j] : 长度为i的字符串 和 长度为j的字符串 是否匹配

	     这个题目中*的含义：表示前面的字符重复的次数 0次 or 1次 or多次，比如a* 表示的含义为 没有a 或者 无数个a

		   if s[i-1] == p[j-1] || p[j-1] == '.' {
		       dp[i][j] = dp[i-1][j-1]
		   } else if p[j-1] == '*' {
	            // 这里要看下*前面的字符p[j-2]是否和 s[i-1] 有匹配关系

	            if s[i-1] == p[j-2] || p[j-2] == '.' { // 说明有匹配关系
	                // dp[i-1][j-2] :表示只用来匹配一次
	                // dp[i-1][j] 表示继续用来匹配
	                // dp[i][j-2] 虽然匹配，当时我选择 当前的这个*不起作用
	                dp[i][j] = dp[i-1][j-2] || dp[i-1][j] || dp[i][j-2]

	            } else { // 之间不匹配，说明*重复前面的字符没有意义，相当于重复0次，也就是不用来匹配（不起作用）
	                dp[i][j] = dp[i][j-2]
	            }
		   }
	*/

	m, n := len(s), len(p)
	dp := make([][]bool, m+1)
	for k := range dp {
		dp[k] = make([]bool, n+1)
	}
	
  // base case 两个长度都是0
	dp[0][0] = true
   
  // i的长度为0, j的长度>=2的时候
	for j := 2; j <= n; j++ {
		if p[j-1] == '*' { // s为空串 ，p不为空，在出现*的时候，默认全部都不起作用
			dp[0][j] = dp[0][j-2]
		}
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if s[i-1] == p[j-1] || p[j-1] == '.' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[j-1] == '*' { // 因为*的含义：就是前面字符重复的次数（0次or无数次）
				// 这里要看下*前面的字符p[j-2]是否和 s[i-1] 有匹配关系

				if s[i-1] == p[j-2] || p[j-2] == '.' { // 说明有匹配关系
					// dp[i-1][j-2] :表示只用来匹配一次
					// dp[i-1][j] 表示继续用来匹配
					// dp[i][j-2] 虽然匹配，但是我选择 当前的这个*不起作用
					dp[i][j] = dp[i-1][j-2] || dp[i-1][j] || dp[i][j-2]

				} else { // 之间不匹配，说明*重复前面的字符没有意义，相当于重复0次，也就是不用来匹配（不起作用）
					dp[i][j] = dp[i][j-2]
				}
			}
		}
	}
	return dp[m][n]
}
```



## 208. 实现 Trie（前缀树）

**[Trie](https://baike.baidu.com/item/字典树/9825209?fr=aladdin)**（发音类似 "try"）或者说 **前缀树** 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补全和拼写检查。

请你实现 Trie 类：

- `Trie()` 初始化前缀树对象。
- `void insert(String word)` 向前缀树中插入字符串 `word` 。
- `boolean search(String word)` 如果字符串 `word` 在前缀树中，返回 `true`（即，在检索之前已经插入）；否则，返回 `false` 。
- `boolean startsWith(String prefix)` 如果之前已经插入的字符串 `word` 的前缀之一为 `prefix` ，返回 `true` ；否则，返回 `false` 

思路：

这题是非常经典的题目。如果看过我之前的`gin`源码解析，有提到过本算法。本算法的目的就是为了做字符串的匹配。通过构建多叉树，将字符串保存到树中（每个节点就是一个字符），当需要查找某个字符串时，只需要从根节点开始，进行匹配字符即可。

```java
type Trie struct {
    next [26]*Trie // 26个字母（26叉树）
    s string // 记录字符串
}

func Constructor() Trie {
   return Trie{}
}

// 保存字符串
func (this *Trie) Insert(word string)  {

    for _, w := range word { // 遍历字符串
        // 在树中判断字母
        node := this.next[ w -'a']
        if node == nil {
            node = new(Trie)
            this.next[w-'a'] = node
        }
        this = node // 让this指向新节点
    }

    this.s = word // 表示当前this最后指向的位置，就是字符串的最后一个字母
}

// 搜索字符串
func (this *Trie) Search(word string) bool {

    for _,w := range word {
        node := this.next[w-'a']
        if node == nil { // 说明没有找到字母
            return false
        }

        // 找到了，继续下一个字母
        this = node
    }
    // 例如 :先插入 apple ，然后搜索app，确实可以搜到，但是app不是有效的字符串（因为没有插入app)，只是恰好和apple的前半部分相同而已（就是要求完全匹配）
    return this.s == word
}

// 搜索前缀
func (this *Trie) StartsWith(prefix string) bool {
    for _,w := range prefix {
        node := this.next[w-'a']
        if node == nil { // 说明没有找到字母
            return false
        }
        // 找到了，继续下一个字母
        this = node
    }
    // 因为只是找前缀，并不是要求完全匹配
    return true
}

```



## 230. 二叉搜索树中第K小的元素

给定一个二叉搜索树的根节点 `root` ，和一个整数 `k` ，请你设计一个算法查找其中第 `k` 小的元素（从 1 开始计数）。

思路：

本题和**LCR 174. 寻找二叉搜索树中的目标节点**一样的题目（这个是求第K大元素），只是本题是求第K小元素。

利用中序遍历：左根右，**注意和 LCR174的区别（右根左）**

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */


func kthSmallest(root *TreeNode, k int) int {
	stack := []*TreeNode{}
	for root != nil || len(stack) > 0 {

		for root != nil { // 不断的往栈中追加元素
			stack = append(stack, root)
			root = root.Left
		}
		// 从栈中弹出元素
		root := stack[len(stack)-1]
		stack = stack[:len(stack)-1]

		k--
		if k == 0 { // 找到第k小的元素
			return root.Val
		}
		root = root.Right
	}
	return 0
}

```



## 295. 数据流的中位数

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 MedianFinder 类:

- `MedianFinder() `初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

思路：

本题的核心思路是使用两个 优先级队列。注意：大根堆和小根堆只是保证【堆顶元素为最大or最小值】，堆中的其他的元素不是有序的。

![image-20250412193552213](./images/image-20250412193552213.png)

这里用两个堆的目的在于将数组从中间一切两半：

前一半（小的部分）用大根堆，保证最大的元素在顶部

后一半（大的部分）用小根堆，保证最小的元素在顶部

这大根堆和小根堆 堆顶的两个元素，恰好就是数组的中间的两个元素（很巧妙）

```
这里再举例说明下算法的运行原理：

题目意思：中位数：即【有序数组】的中间值，但是addNum数值的时候是无序增加；所以让我们要想办法，来能找到这个中位数

例如：
元素为 3 5 8 1 2 4
有序数组为 1 2 3 4 5 8 （即，排序后的有序数组）

前面的部分【小】，用大根堆存储 123 ，
【3】
【2】
【1】
堆顶元素是3

后面的部分【大】，用小根堆存储 
【4】
【5】
【8】
堆顶元素是4

中位数即为：大根堆 3 + 小根堆 4 = 3.5

```

每次有新元素 `addNum` 的时候，需要先经过【大根堆】过滤（目的在于沉淀下来较小的元素），弹出较大的元素；

然后将较大的元素，再放入到【小根堆】过滤（目的在于沉淀下来较大的元素）, 弹出较小的元素；

保证大根堆元素数量 >= 小根堆元素数量（当数量相同，表示元素是偶数个，当大根堆元素大于小根堆，说明是奇数个）

```java
// 大根堆
type MaxHeap struct {
    nums []int
}

func (m *MaxHeap)Swap(i,j int) {
    m.nums[i],m.nums[j] = m.nums[j],m.nums[i]
}

func(m *MaxHeap)Less(i,j int) bool {
    return m.nums[i] > m.nums[j]
}

func(m *MaxHeap)Len() int{
    return len(m.nums)
}

func (m *MaxHeap) Push(x any) {
    m.nums = append(m.nums,x.(int))
}

func (m *MaxHeap)Pop() any {
    x := m.nums[len(m.nums)-1]
    m.nums = m.nums[:len(m.nums)-1]
    return x
}

func(m *MaxHeap)Top() int {
    return m.nums[0]
}

// 小根堆

type MinHeap struct {
    nums []int
}

func (m *MinHeap)Swap(i,j int) {
    m.nums[i],m.nums[j] = m.nums[j],m.nums[i]
}

func(m *MinHeap)Less(i,j int) bool {
    return m.nums[i] < m.nums[j]
}

func(m *MinHeap)Len() int{
    return len(m.nums)
}

func (m *MinHeap) Push(x any) {
    m.nums = append(m.nums,x.(int))
}

func (m *MinHeap)Pop() any {
    x := m.nums[len(m.nums)-1]
    m.nums = m.nums[:len(m.nums)-1]
    return x
}

func(m *MinHeap)Top() int {
    return m.nums[0]
}

type MedianFinder struct {
    maxHeap *MaxHeap
    minHeap *MinHeap
}


func Constructor() MedianFinder {

    finder :=  MedianFinder {
        maxHeap: &MaxHeap{},
        minHeap: &MinHeap{},
    }

    // 初始化大小堆 对象
   // heap.Init(finder.maxHeap)
   // heap.Init(finder.minHeap)
    return finder
}


func (this *MedianFinder) AddNum(num int)  {
    // 先放入大根堆
    heap.Push(this.maxHeap,num)
    // 弹出大根堆堆顶元素，再放入小根堆
    heap.Push(this.minHeap,heap.Pop(this.maxHeap))

    // 保证大根堆 >= 小根堆
    for this.maxHeap.Len() < this.minHeap.Len() {
        heap.Push(this.maxHeap, heap.Pop(this.minHeap)) // 弹出小根堆，放入大根堆
    }
}

func (this *MedianFinder) FindMedian() float64 {
    if this.maxHeap.Len() > this.minHeap.Len() { // 说明元素个数，奇数
        return float64(this.maxHeap.Top())
    }

    return float64(this.maxHeap.Top() + this.minHeap.Top()) / 2  // 说明元素个数，偶数
}

```



## LCR 187. 破冰游戏

社团共有 `num` 位成员参与破冰游戏，编号为 `0 ~ num-1`。成员们按照编号顺序围绕圆桌而坐。社长抽取一个数字 `target`，从 0 号成员起开始计数，排在第 `target` 位的成员离开圆桌，且成员离开后从下一个成员开始计数。请返回游戏结束时最后一位成员的编号。

**示例 1：**

```
输入：num = 7, target = 4
输出：1
```

**示例 2：**

```
输入：num = 12, target = 5
输出：0
```

思路：

本题属于约瑟夫环问题，只需要记住结论结论即可。

这里通过举例子的方式来推导本题的解法（如果数学好的，也可以用数学公式来求解）

这里以`num = 5 target = 3`为例，即总共有`5`个数字，每次删除第`3`个数字

```java
一开始的数字为 0 1 2 3 4
从索引0开始，删除第3个数字（也就是数字2），结果为： 0 1  3 4，这里我们整理下，将下一个要开始的索引，放到第一位，也就是 3 4 0 1
我们继续从索引0开始，删除第3个数字（也就是数字0），结果为： 3 4 1，继续整理下，将一下要开始的索引，放到第一位，也就是 1 3 4
同上，从索引0开始，删除第3个数字（也就是数字4），结果为 1 3，继续整理下，将一下要开始的索引，放到第一位，也就是 1 3
同上，从索引0开始，删除第3个数字（也就是数字1），结果为 3，也就是本题的最终结果

整理下整个的数字如下：
0 1 2 3 4
3 4 0 1 
1 3 4
1 3
3
从这里其实也看不出什么规律来。
我们可以从最后一行 3 着手，此时索引为0，我们知道最后一行是由倒数第二行 1 3得来的

推广成一般结论即：
如果我们在数字3前面再加回 target = 3 个数字呢？那就是 1,3,1,3 
原本索引下标是0的3由于前面加了 target个数字，因此现在索引下标成了0+target，而且我们补成了1,3的循环，所以通过取模方式可以知道前面一个数字3的下标索引idx=(0+target)%2

公式中0其实是最后一行数字3的下标，
而公式中2是倒数第二行的元素个数，
最后求得倒数第二行数字3的下标。
所以很容易得出了 idx=(idx+target)%num 这个公式

通过这个公式可知，我们不需要知道最后一个数值是什么，只需要知道 target num 这两个数值，以及起始idx=0即可
```

![image-20250413195826191](./images/image-20250413195826191.png)

```java
func iceBreakingGame(num int, target int) int {
    
    // num个数字，每次删除第target数字，最后留下来的数字是 ??

    idx := 0 // 其实索引
    for i := 2;i <=num;i++ {
				//  target表示删除第几个数
        idx = (idx + target) % i // i表示每行元素个数 
    }

    return idx
}
```



## 189. 轮转数组

给定一个整数数组 `nums`，将数组中的元素向右轮转 `k` 个位置，其中 `k` 是非负数。

**示例 1:**

```
输入: nums = [1,2,3,4,5,6,7], k = 3
输出: [5,6,7,1,2,3,4]
解释:
向右轮转 1 步: [7,1,2,3,4,5,6]
向右轮转 2 步: [6,7,1,2,3,4,5]
向右轮转 3 步: [5,6,7,1,2,3,4]
```

思路：

```java
这题主要是看出思路,就很简单(其实就是数组被切割成了两个部分)
[1,2,3,4,5,6,7]
整体翻转
[7,6,5,   4,3,2,1]
围绕k分成左右子数组，分别翻转
[5,6,7    1,2,3,4]
```

```java
func rotate(nums []int, k int) {

	k = k % len(nums) //  k == 0 说明转了一圈，又转回来的，不用去做轮转了

	if k > 0 { // 说明需要进行轮转

		// 1. 先对整个数组进行翻转
		left, right := 0, len(nums)-1
		reverse(nums, left, right)

		// 2. 然后以 k 作为分割，将左右子数组分别进行翻转
		left, right = 0, k-1 // 左子数组
		reverse(nums, left, right)

		left, right = k, len(nums)-1 // 右子数组
		reverse(nums, left, right)
	}
}

func reverse(nums []int, left, right int) {

	for left < right {
		nums[left], nums[right] = nums[right], nums[left]
		left++
		right--
	}
}
```



## 225. 用队列实现栈

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。

思路：

这种题目只是来锻炼思维逻辑，不用在意题目有没有什么意义。

其实只需要用一个队列即可模拟栈的效果

![image-20250413212335432](./images/image-20250413212335432.png)

```java
type MyStack struct {
    queue []int
}


func Constructor() MyStack {
    return MyStack{
        queue:make([]int,0),
    }
}


func (this *MyStack) Push(x int)  {
    l := len(this.queue) // 先记录下队列已有的元素数量

    this.queue = append(this.queue,x) // 入队一个新元素

    for l > 0 { // 将新元素前面的，旧元素，出队并且再入队（相当于保存到了新元素的后面，达到栈的效果）
        
        this.queue = append(this.queue,this.queue[0]) // 将队列首部元素，又重新放入尾部
        this.queue = this.queue[1:] // 去掉首部元素
        l--
    }
}


func (this *MyStack) Pop() int {
    x := this.queue[0]

    this.queue = this.queue[1:]

    return x
}


func (this *MyStack) Top() int {
    x := this.queue[0]

    return x
}


func (this *MyStack) Empty() bool {
    return len(this.queue) == 0
}

```



## 287. 寻找重复数

给定一个包含 `n + 1` 个整数的数组 `nums` ，其数字都在 `[1, n]` 范围内（包括 `1` 和 `n`），可知至少存在一个重复的整数。

假设 `nums` 只有 **一个重复的整数** ，返回 **这个重复的数** 。

你设计的解决方案必须 **不修改** 数组 `nums` 且只用常量级 `O(1)` 的额外空间。

**示例 1：**

```
输入：nums = [1,3,4,2,2]
输出：2
```

思路：

提供了两种解法：

第一种解法：类似于**141.环形链表**寻找环点（可以先看下，在来看下本题）

第二种解法：如果题目没有不能修改数组的限制，类似于**442. 数组中重复的数据**解法

```java
// 解法一：
func findDuplicate(nums []int) int {
    // 这题的思路很奇特，用数组的值（作为索引位置），判断数组的环
    //1.初始化快慢指针

    slow,fast := 0,0 // 将slow,fast都理解为数值
    // 例如： 0  [1  2  2] 
    // slow，fast一开始都指向数值0,这个0其实是个虚拟的起始节点
    for {
        slow = nums[slow] // slow跳跃一下，由数值0->数值1
        fast = nums[nums[fast]] // 相当于fast跳跃了两次，从0 ->1 -> 2

        // 此时 1 ！= 2 ，继续跳跃

        // slow 从 1->2
        // fast 从 2->2->2 ,此时slow==fast
        if slow == fast {
            break
        }
    }
    // 上面只是表示有环，要求的是环的起始相交点
    slow = 0 
    for {
        slow = nums[slow]
        fast = nums[fast]
        if slow == fast {
            break
        }
    }
    return slow
}


// 解法二，修改了数组中的元素（虽然也是可以找到答案）
func findDuplicate1(nums []int) int {


    for i := 0;i < len(nums);i++ {

        idx :=  abs(nums[i]) - 1

        if nums[idx] > 0 {
            nums[idx] = -nums[idx]
        }else {
            return abs(nums[i])
        }
    }
    return 0
}

func abs(a int) int {
    if a < 0 {
        return -a
    }

    return a
}
```



## LCR 139. 训练计划 I

教练使用整数数组 `actions` 记录一系列核心肌群训练项目编号。为增强训练趣味性，需要将所有奇数编号训练项目调整至偶数编号训练项目之前。请将调整后的训练项目编号以 **数组** 形式返回。

**示例 1：**

```
输入：actions = [1,2,3,4,5]
输出：[1,3,5,2,4] 
解释：为正确答案之一
```

思路：

本题采用快慢指针技巧，`fast`负责遍历所有元素，`slow`负责存储奇数

```java
func trainingPlan(actions []int) []int {

    slow, fast := 0,0
    for fast < len(actions) {

        if actions[fast] % 2 == 1 { // 奇数
            actions[slow],actions[fast] = actions[fast],actions[slow]
            slow++
        }
        fast++
    }   

    return actions
}
```



## 106. 从中序与后序遍历序列构造二叉树

给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。给定两个整数数组 `inorder` 和 `postorder` ，其中 `inorder` 是二叉树的中序遍历， `postorder` 是同一棵树的后序遍历，请你构造并返回这颗 *二叉树* 。

思路：

本题和**105. 从前序与中序遍历序列构造二叉树**题目类似。前序遍历和后序遍历是破题的关键

```java
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(inorder []int, postorder []int) *TreeNode {
    //1.从后序遍历，先找到根节点
    if len(postorder) == 0 {
        return nil
    }
    postVal := postorder[len(postorder)-1] // 尾部的元素（即为，根节点值）
    root := &TreeNode{Val:postVal,Left:nil,Right:nil}
    //2.截取 inorder 和 postorder
    leftLen := 0
    for k,v := range inorder {
        if v == postVal {
            leftLen = k
            break
        }
    }
    
    root.Left = buildTree(inorder[0:leftLen],postorder[0:leftLen])
    root.Right = buildTree(inorder[leftLen+1:],postorder[leftLen:len(postorder)-1])

    return root
}
```



## 9. 回文数

给你一个整数 `x` ，如果 `x` 是一个回文整数，返回 `true` ；否则，返回 `false` 。

回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。

- 例如，`121` 是回文，而 `123` 不是。

**示例 1：**

```
输入：x = 121
输出：true
```

**示例 2：**

```
输入：x = -121
输出：false
解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。
```

思路：

- 根据上面示例可知，如果是负数，直接返回 `false`即可
- 如果是正数，这里利用求余数的方式，构建一个新的正数`y`，只需要判断`x==y`即可知道是否为回文数

```java
func isPalindrome(x int) bool {
    // 其实是利用数字求余数%，得到一个整数d，然后对整数再拼接成y = y * 10 +d（一开始y=0),最后得到的数值是否和x一样；
    if x < 0 { // 因为下面的计算规则，负数也是满足的；所以对负数额外处理，
        return false
    }
    temp := x //表示对x求余以后，剩下的整数
    y := 0

    for temp != 0 { // 如果x是0的话，直接不用执行这里
        y = y*10 + temp%10 // 构建新的整数y
        temp = temp/10
    }
    // 最后判断生成的y的数值，是不是和x一样，因为回文数字，正反读是一样的；
    return x == y
}
```



## 384. 打乱数组

给你一个整数数组 `nums` ，设计算法来打乱一个没有重复元素的数组。打乱后，数组的所有排列应该是 **等可能** 的。

实现 `Solution` class:

- `Solution(int[] nums)` 使用整数数组 `nums` 初始化对象
- `int[] reset()` 重设数组到它的初始状态并返回
- `int[] shuffle()` 返回数组随机打乱后的结果

思路：

本题利用洗牌算法来打乱数组。

为了让数组足够的乱，我们知道一个长度为`n`的数组如果重新排列，有`n!`种排列方法，所以，设计的算法，需要让排列的结果能够满足`n!`。

比如:

第一个数值，我们可以从 `n`个位置种选择一个存放；

第二个数值，我们可以从 `n-1`个位置种选择一个存放；

第三个数值，我们可以从 `n-2`个位置种选择一个存放；

以此类推，那就是 `n * n-1 * n-2 ..... * 1 = n!`

代码实现如下：

```java
// 洗牌算法：打乱的本质；也就有多少种排列的可能，n!（n表示数组的长度）

type Solution struct {
    nums []int
}


func Constructor(nums []int) Solution {
    return Solution{nums}
}


func (this *Solution) Reset() []int { // 这个返回原始的数组
    return this.nums
}   


func (this *Solution) Shuffle() []int {
		// 复制一个 temp
    temp := make([]int,len(this.nums))
    copy(temp,this.nums)


    for i := 0;i < len(temp);i++ { // 字符选中i，随机的索引范围从[i,n-1]之间选择：例如i= 0,随机索引[0,n-1]也就是n种选择，当i=1的时候，随机索引[1,n-1]也就是n-1种选择，以此类推
        randIdx := rand.Intn(len(temp)-i)+i// 函数rand.Intn 返回[0,len(temp)-i)之间的随机数，随着i的增大，随机的范围在缩小；+i的目的是让随机的索引范围>=i（主要是这个函数的特性决定这样的代码写法)
        temp[i],temp[randIdx] = temp[randIdx],temp[i] // 交换元素
    }
    return temp
}
```



## 96. 不同的二叉搜索树

给你一个整数 `n` ，求恰由 `n` 个节点组成且节点值从 `1` 到 `n` 互不相同的 **二叉搜索树** 有多少种？返回满足题意的二叉搜索树的种数。

思路：

假设给算法输入 `n = 5`，也就是说用 `{1,2,3,4,5}` 这些数字去构造 `BST`

如果固定 `3` 作为根节点，左子树节点就是 `{1,2}` 的组合，右子树就是 `{4,5}` 的组合：

![image-20250414205012806](./images/image-20250414205012806.png)

那么 `{1,2}` 和 `{4,5}` 的组合有多少种呢？

所以，只需要定义`dp[i][j]`表示 `[i,j]` 范围的数值组成二叉搜索树的种数。

那么`{1,2}`表示为`dp[1][2]`(由上图可知，有`2`种)

那么`{4,5}`表示为`dp[4][5]`(由上图可知，有`2`种)

所以，固定 `3` 作为根节点，拿得到的组合为`dp[1][2] * dp[4][5] = 2* 2 = 4`种

一般的递推逻辑为：

`dp[i][j] +=` 对范围`[i,j`]的每个元素都固定一次作为根节点`mid` （那么，对应的组合数为 `dp[i][mid-1] * dp[mid+1][j]`) 

特殊情况：当 ` i >= j`可以看作只能组成一棵`nil`树或者只包含一个节点的树，即`dp[i][j] = 1`

代码如下：

```java
func numTrees(n int) int {
    // dp[i][j] 表示 [i,j] 范围的数值，组成二叉搜索树的种数；
  
    // if i >= j dp[i][j] = 1
  
    // 转移方程： dp[i][j] += 【  对于范围[i,j]每次固定一个数字mid    dp[i][mid-1] * dp[mid+1][j]  】
    // return dp[1][n] 


  	// 定义二维dp数组
    dp := make([][]int,n+1)
    for i := 0;i < n+1;i++ {
        dp[i] = make([]int,n+1)
    }

    for i := 0;i < n+1;i++ {
        for j := i;j >= 0;j-- { // i>=j的 范围默认都是 1（也就是只能组成一个 nil树 or 只有一个节点的树）
            dp[i][j] = 1
        }
    }

    // 这里是 i < j 的关系
    for i := n;i >= 0;i-- {  // 这里为什么i要先从n开始，而不是i先从0开始？？这需要你看下递推函数，要想求dp[i][j],需要先知道 dp[i][mid-1] 和 dp[mid+1][j]的值是吧，其中索引 mid+1 的值是大于i的值，也就是我们需要先知道比i大的，才能知道 i的值，所以需要i从n开始（也就是从大数开始）；同理，j从小数开始，因为需要先知道 mid-1的值，才能求j ，【这个细节一般不容易注意到，因为之前的很多 dp数组都是由小的索引，来推导大的索引。所以，都是从 0开始】
        for j := i+1;j < n+1;j++ {
            
            // 相当于从 【i,j】 范围中每次找一个点mid作为根节点
            for mid := i; mid <=j;mid++ {

                left,right := 1,1
                if mid-1 >= 0 {
                    left = dp[i][mid-1]
                }
                if mid+1 <=n {
                    right = dp[mid+1][j]
                }
                dp[i][j] += left * right // 选中某个mid作为根，得到的bst的组合数
            }
        }
    }
  	// 最终要求的 [1,n]的组合数
    return dp[1][n]
}
```



## 120. 三角形最小路径和

给定一个三角形 `triangle` ，找出自顶向下的最小路径和。

每一步只能移动到下一行中相邻的结点上。**相邻的结点** 在这里指的是 **下标** 与 **上一层结点下标** 相同或者等于 **上一层结点下标 + 1** 的两个结点。也就是说，如果正位于当前行的下标 `i` ，那么下一步可以移动到下一行的下标 `i` 或 `i + 1` 。

**示例 1：**

```
输入：triangle = [[2],[3,4],[6,5,7],[4,1,8,3]]
输出：11
解释：如下面简图所示：
   2
  3 4
 6 5 7
4 1 8 3
自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 = 11）。
```

代码如下：

```java
// 解法一：
func minimumTotal1(triangle [][]int) int {
    // 动态规划： dp[i][j] 定义，到达位置i和j的最小路径和为 dp[i][j]

    // 如何到达：来源于上一行i-1 【同一列j 或 前一列j-1】 即，dp[i][j] = min(dp[i-1][j],dp[i-1][j-1]) + triangle[i][j]

    // 最终的结果是最后一行的某一列 dp[n-1][...]

    // base case : dp[0][0] = triangle[0][0]

    // 这里初始化要对整个二位数组初始化为 math.MaxInt（因为求最小值，初始值设定为最大值）
    n := len(triangle)
    dp := make([][]int,n) // n 行
    for i := 0;i < n;i++ {
        dp[i] = make([]int,n) // n列，题目提示说了，每一行长度是上一行长度+1，所以最大列数和行数其实是一样的
        for j := 0;j < n;j++ {
            dp[i][j] = math.MaxInt // 初始化为最大值
        }
    }   
    // base case 第一行只有一个元素
    dp[0][0] = triangle[0][0]

    for i := 1;i < n;i++ { // 从第二行开始
      	column := triangle[i] // 注意很重要(该行有column列)
        for j := 0; j < len(column);j++ { // 
            if j == 0 {
                 // j == 0 说明是边上，只能正上方可以到达当前位置
                dp[i][j] = dp[i-1][j] + triangle[i][j]
            } else {
                dp[i][j] = min(dp[i-1][j-1],dp[i-1][j]) + triangle[i][j]
            }
        }
    }

    result := math.MaxInt
  	// 最后:在最后一行找到-最小值
    for j := 0; j < n;j++ {
        result = min(dp[n-1][j],result)
    }

    return result
}

func min ( a,b int) int {
    if a < b {
        return a
    }

    return b
}


// 进阶解法二（先看解法一，再看解法二容易理解点）
func minimumTotal(triangle [][]int) int {

    n := len(triangle)
  
		// 这里只定义一维数组
    arr := make([]int,n)
    for i := range arr {
        arr[i] = math.MaxInt
    }

  	// 第一个元素值为 triangle[0][0]
    arr[0] = triangle[0][0]

    for i := 1; i < n;i++ { // 从第二行开始
        column := triangle[i]

     	 for j := len(column)-1;j >= 0;j-- { // 倒序(注意这里的区别，因为是一维数据，需要先求后面的，避免前面的被提前覆盖)

            if j == 0 {
                arr[j] = triangle[i][j] + arr[j]
            } else {
                arr[j] = triangle[i][j] + min(arr[j],arr[j-1]) 
            }
        }
    }
		
  	// 在一维数组中，找到最小值
    res := math.MaxInt
    for _,v := range arr {
        res = min(res,v)
    }
    return res
}
```



## 210. 课程表 II

现在你总共有 `numCourses` 门课需要选，记为 `0` 到 `numCourses - 1`。给你一个数组 `prerequisites` ，其中 `prerequisites[i] = [ai, bi]` ，表示在选修课程 `ai` 前 **必须** 先选修 `bi` 。

- 例如，想要学习课程 `0` ，你需要先完成课程 `1` ，我们用一个匹配来表示：`[0,1]` 。

返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 **任意一种** 就可以了。如果不可能完成所有课程，返回 **一个空数组** 。

思路：

**207. 课程表**题解，这两题基本就是一样的题目，只是多了一个返回课程的过程。

直观地说，拓扑排序就是让你把一幅无环图「拉平」，而且这个「拉平」的图里面，所有箭头方向都是一致的：

![image-20250414231509346](./images/image-20250414231509346.png)

在进行拓扑排序之前，首先要确保图中无环，这就依赖中讲的**207. 课程表**环检测算法。



这里对比较难理解的`onPath`图示说明：

比如 课程1依赖课程2 课程3，课程3又依赖课程1，这样就形成了循环依赖的关系。课程是无法完成学习的。

通过下图可以理解 `onPath`变量的意义，以及整个检测的可视化过程。建议边看代码边看图理解

![image-20250108184539428](./images/image-20250108184539428.png)

![image-20250108185123851](./images/image-20250108185123851.png)

![image-20250108185414643](./images/image-20250108185414643.png)

![image-20250108185701530](./images/image-20250108185701530.png)

```java

var postOrder []int // 课程的学习顺序列表
var isCircle bool // 是否有环标志
var visited []bool // 表示节点是否已经访问过,这个是为了剪枝
var onPath []bool  // 节点正在被占用中（访问中），这个是为了，记录下访问路径有没有重叠
func findOrder(numCourses int, prerequisites [][]int) []int {
		
    visited = make([]bool,numCourses)
    onPath = make([]bool,numCourses)
    postOrder = []int{}
    isCircle = false
  
    //1.先构建有向图（用临接表的方式，其实就是二维数组）
    graph := make([][]int,numCourses) // 总共有numCourses个课程，graph的目的是记录每个课程（依赖的子课程）


    // 表示 prerequisites[i][0] 依赖于 -> prerequisites[i][1]
    for i := 0;i < len(prerequisites);i++ {
        graph[prerequisites[i][0]] = append(graph[prerequisites[i][0]],prerequisites[i][1])
    }

    // 2.遍历有向图；也就是以每个课程出发，然后遍历和它关联的所有的子课程（目的：看课程是否存在强制循环依赖关系）
    for i := 0; i < numCourses;i++ { 
        dfs(graph,i) // i 表示课程
    }
    if isCircle {
        return []int{}
    }
    
    return postOrder
}

func dfs(graph [][]int,i int) {

    // 判断课程i 正在被占用
    if onPath[i] {
        isCircle = true
    }

    if visited[i] || isCircle { // 节点已经访问过，或者已经存在环，没必要继续下去了，尽快结束
        return
    }

    visited[i] = true
    onPath[i] = true // 标记：正在访问
    
    // 先固定i课程，然后看i下面依赖的所有子课程（如果子课程在dfs遍历的时候，发现会访问到已经被占用的课程，说明有环）
    for j := 0;j < len(graph[i]);j++ { // i下面的所有子课程
        dfs(graph,graph[i][j]) // graph[i][j] 表示子课程
    }   
    
    // 因为 i 依赖于 graph[i]中的子课程先学习， 所以放置到后续遍历位置记录最终结果
    postOrder = append(postOrder,i) 

    onPath[i] = false // 标记：取消访问
}
```



## 213. 打家劫舍 II

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 **围成一圈** ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，**如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警** 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 **在不触动警报装置的情况下** ，今晚能够偷窃到的最高金额。

思路：

本题是**198. 打家劫舍**的进阶版。

方案1.如果【偷】第一个`0`房间，那么`nums[1]`和`nums[n-1]`都不能偷，那就只能偷 `[2,n-2]`范围的闭合区间,可以偷窃；

方案2.如果【不偷】第一个房间，那么可以偷取的范围`[1,n-1]`

上面两种方案有个共同点，都需要我们实现一个偷取`[i,j]`范围内房子的函数。这个正好就是**198. 打家劫舍**实现的函数。

```java
func rob(nums []int) int {
    
    n := len(nums)
    if n == 1 { // 只有一个房屋，直接偷
        return nums[0]
    }

    if n == 2 { 
        return max(nums[0],nums[1])/ / 只有两个房屋,选最大的偷
    }
		// nums[0]+ rob1(nums[2:n-1])  对应方案1
  	// rob1(nums[1:n]) 对应方案2
    return max(nums[0]+ rob1(nums[2:n-1]),rob1(nums[1:n])) // 注意Go切片最后一个位置要+1（语言特性决定的）
}

// 从 nums 中能偷窃的最大值
func rob1(nums []int) int {

    if len(nums) == 0 {
        return 0
    }
    // 定义：dp[x] 表示从0到x能偷窃的最高金额
    // 递推函数：dp[x] = max(dp[x-1],nums[x]+ dp[x-2])  
  	// 当前x不偷窃，那就是dp[x-1]的最高金额等于dp[x]
    // 当前x偷窃，那 nums[x] + dp[x-2]的最高金额
		
  	// 构建dp数组
    dp := make([]int ,len(nums))
  	// base case
    dp[0] = nums[0]
    if len(nums) > 1 {
        dp[1] = max(nums[0],nums[1]) 
    }

    for i := 2; i < len(nums);i++ {
        dp[i] = max(dp[i-1],nums[i]+ dp[i-2])
    }
  	// 表示从 0 到 len(nums)-1能偷窃的最大值
    return dp[len(nums)-1]
}

func max(a,b int) int{
    if a > b {
        return a
    }
    return b
}
```



## 516. 最长回文子序列

给你一个字符串 `s` ，找出其中最长的回文子序列，并返回该序列的长度。

子序列定义为：不改变剩余字符顺序的情况下，删除某些字符或者不删除任何字符形成的一个序列。 

**示例 1：**

```
输入：s = "bbbab"
输出：4
解释：一个可能的最长回文子序列为 "bbbb" 。
```

思路：

首先回文的定义就是，正向读和反向读，都一样的

动态规划： 

`dp[i][j] `定义：字符串 `s[i...j] `的最长回文子序列长度 `dp[i][j]`

一般递推关系：

 `s[i] == s[j]    dp[i][j] = dp[i+1][j-1] + 2`

`s[i] != s[j]     dp[i][j] = max(dp[i+1][j],dp[i][j-1])` 

![image-20250415113143896](./images/image-20250415113143896.png)

这题的注意点在于索引`i`的遍历方向（也就是倒序方式）

以前的题解都是求`i`需要先求`i-1`，所以`i`从`0`开始遍历，将小的作为结果，来推导出大的；

但是这里，由递推关系可知` dp[i][..]` 的值是由` dp[i+1][..] `得来的，所以，需要先来算出`dp[i+1]`的值，再来求`dp[i]`因此`i`要先从大索引值开始，然后到小的；

而`j`恰好符合之前的正序方式：`dp[..][j]` 由 `dp[..][j-1]`得来，所以`j` 是符合从小大的规则，正序即可。

```java
func longestPalindromeSubseq(s string) int {

    // 首先回文的定义就是，正向读和反向读，都一样的；也就是字符串的首尾的字符相同
    // 动态规划： dp[i][j] = x :定义 字符串 s[i...j] 的最长回文子序列长度 dp[i][j]
  
    // s[i] == s[j] dp[i][j] = dp[i+1][j-1] + 2
    // s[i] != s[j] dp[i][j] = max(dp[i+1][j],dp[i][j-1])
    n := len(s)
    dp := make([][]int,n)

    for i := 0;i < n;i++ {
        dp[i] = make([]int,n)
        dp[i][i] = 1 // base case 单独的元素就是1个回文串
    }

    for i := n-1;i>=0;i-- { 
        for j := i+1;j < n;j++ { // 这里j = i+1,因为前面j==i的情况在base case中已经处理了（这个递推关系只能在i!=j的前提下成立）
            if s[i] == s[j] {
                dp[i][j] = dp[i+1][j-1] + 2 
            } else {
                dp[i][j] = max(dp[i+1][j],dp[i][j-1])
            }
        }
    }


    return dp[0][n-1]
}

func max( a,b int) int{
    if a > b{
        return a
    }
    return b
}
```



## 678. 有效的括号字符串

给你一个只包含三种字符的字符串，支持的字符类型分别是 `'('`、`')'` 和 `'*'`。请你检验这个字符串是否为有效字符串，如果是 **有效** 字符串返回 `true` 。

**有效** 字符串符合如下规则：

- 任何左括号 `'('` 必须有相应的右括号 `')'`。
- 任何右括号 `')'` 必须有相应的左括号 `'('` 。
- 左括号 `'('` 必须在对应的右括号之前 `')'`。
- `'*'` 可以被视为单个右括号 `')'` ，或单个左括号 `'('` ，或一个空字符串 `""`。

思路：

遇到括号的问题，一般都是采用栈的方式解决

- 本题用栈记录的是【索引值】：`leftStack`记录左括号索引 `starStack`记录星号索引
- 当遇到 `)`右括号，查找 `leftStack starStack`栈，匹配
- 当匹配结束以后，`leftStack`可能还剩余左括号，需要用剩余的星号完成匹配。（前提，星号的索引 大于 左括号的索引）

```java
func checkValidString(s string) bool {
    ///！！！利用栈实现
    leftStack := []int{} // 记录(左括号 索引
    starStack := []int{} // 记录*号 索引

    for k,v := range s {
        if v == '(' { // 遇到左括号，记录索引
            leftStack = append(leftStack,k) 
        } else if v == '*' { // 遇到*号，记录索引
            starStack = append(starStack,k)
        } else { // 遇到 ）右括号
          	// 先匹配 leftStack，比如： *() 格式，遇到 ）匹配 ( 而不是匹配 *
            if len(leftStack) != 0 {
                leftStack = leftStack[:len(leftStack)-1] // 弹出（
            } else if len(starStack) != 0 {
                starStack = starStack[:len(starStack)-1] // 弹出 *
            } else {
                return false // (和*都不存在，说明右括号无法匹配
            }
        }
    }
  	
  	//当上面的所有【右括号】匹配完成后，可能还会剩余【左括号】，所以需要对剩下的左括号做匹配，比如：(*() 格式，还会剩下 (*
  
    // 一个左括号，一定要有个处于其【右边的星号】来匹配，即： * 的索引 > 左括号（ 的索引
    for len(leftStack) != 0 {

        if len(starStack) == 0 {
            return false
        }

        if starStack[len(starStack)-1] < leftStack[len(leftStack)-1] { // (*  即： *的索引，需要大于（的索引 
            return false
        }
      
        leftStack = leftStack[:len(leftStack)-1]
        starStack = starStack[:len(starStack)-1]
    }

    return true
}
```



## 44. 通配符匹配

给你一个输入字符串 (`s`) 和一个字符模式 (`p`) ，请你实现一个支持 `'?'` 和 `'*'` 匹配规则的通配符匹配：

- `'?'` 可以匹配任何单个字符。
- `'*'` 可以匹配任意字符序列（包括空字符序列）。

判定匹配成功的充要条件是：字符模式必须能够 **完全匹配** 输入字符串（而不是部分匹配）。

思路：

本题和 **10. 正则表达式匹配**有类似之处，但是更简单。

定义：`dp[i][j]`表示 长度` i` 的字符串 `s` 是否和 长度 `j` 的字符串 `p` 相匹配

```java
 if s[i-1] == p[j-1] || p[j-1] == '?' { // 当尾部的两个字符相同 或者 p尾部为 ？
	       dp[i][j] = dp[i-1][j-1] 
	   } else if p[j-1] == '*' { // 当 p 尾部字符为 *
   				// dp[i-1][j] 表示 用s尾部的字符和p尾部字符*进行一次匹配，匹配后s长度变短，p保持不变（也就是*还可以继续用来匹配）
   				// dp[i][j-1] 表示 p尾部字符 * 不用来匹配（忽略*的存在）
	       dp[i][j] = dp[i-1][j] || dp[i][j-1]  
	   }
```

代码如下：

```java
func isMatch(s string, p string) bool {
	

	m, n := len(s), len(p)
  // 定义二维dp数组
	dp := make([][]bool, m+1)
	for i := 0; i <= m; i++ {
		dp[i] = make([]bool, n+1)
	}
	// base case 两个长度都是0
	dp[0][0] = true
	
  // 当s的长度为0，p字符串为：*****
	for j := 1; j <= n; j++ {
		if p[j-1] == '*' { // p尾部字符为*时（忽略*的存在）
			dp[0][j] = dp[0][j-1]
		}
	}

	for i := 1; i <= m; i++ {
		for j := 1; j <= n; j++ {
			if s[i-1] == p[j-1] || p[j-1] == '?' {
				dp[i][j] = dp[i-1][j-1]
			} else if p[j-1] == '*' {
				dp[i][j] = dp[i-1][j] || dp[i][j-1] // dp[i-1][j] 表示*匹配一个字符 dp[i][j-1] 表示*不匹配字符（忽略*）
			}
		}
	}
    return dp[m][n]
}
```











