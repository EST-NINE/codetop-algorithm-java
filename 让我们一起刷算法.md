---
typora-copy-images-to: ./images
---



[TOC]

# 前言

> 多学一分钟，女友都不同，把障碍变成机会，把问题变成可能。

学习新知识的核心就在于 **重复 + 重复 + 重复**

本人也是从一无所知开始尝试刷算法，中间断断续续痛苦/纠结/无能狂怒。第1次的时候，整人是蒙圈的，看着别人的标准答案慢慢的摸索算法的含义，那真是一支笔一杯茶，一道力扣刷一天。当重复到第5次的时候，开始有些感觉了，看到题目的标题，就可以立刻回想到题目的大概的解题方向，但是很多细节还是脑袋一团浆糊，那就继续重复，当到了第8次的时候，突然就觉得就是这样的，很容易记住呀，不过如此呀。

刷题（本质就是背诵）我们的目的就是要去面试，所以题目尽可能的要选择命中率高的题库去刷，而不是力扣的题目从第一题开始，意义不大。当背诵了300道题目以后，去面试的时候，只要考算法题目，我其实很兴奋的（因为背的很熟悉），刷过的题目的命中率还挺高的。

大家不要把算法题想象的过于高大上，既然是题目，那就是有答案和解题套路的。背诵答案 + 总结解题套路，同类型的题目即使你题目都看的懵懵懂懂，都有可能蒙出来。

本文章题目都是来源于 https://codetop.cc/home  里面考察频度高的题目，都是面试后人工标记出来的（面试命中率高）。我写这个文章的目的，就是提供一份参考答案，包括代码每行的含义，以及通用的套路。因为一旦理解了，按照自己的方式去记忆会容易很多。
只需要用这个网站作为题目**是否做过**的标记即可（因为笔记功能要收费），自己的答案直接保存在力扣官方刷题网站上

![](./images/20241212172641.png)

这里还有一份适合小白的算法书  https://www.hello-algo.com/  在Github上还挺火的。我个人觉得也可拿来扫下盲，或者刷题遇到理解上的困难可以拿来看看。

![](./images/20241212172245.png)

# 解题套路

解题套路可以先简单看下，当遇到相关的题目，可以回来再细细品味。建议还是先直接刷题。

## 滑动窗口解题套路

- 定义 `left right := 0,0` 指向起始位置 `0`
- 让 `right`不断的右移，当遇到不符合题意的条件`condition`，停止移动 `right`
- 然后开始让`left`不断右移，直到条件`condition`得到满足，继续重复👆的步骤，右移`right`
- 当 `right`越界，全部结束

动态规划套路伪代码

```go
nums := []int{1,2,3,4,5,6}
func main() {
  
  //1. 定义 `left right := 0,0` 指向起始位置 `0`
  left, right := 0,0
  
  // right 越界结束
  for right < len(nums) {
    
    // 2.不断移动 right
    val := nums[right]
    right++ 
    
    // do something.....
    
    // 3.当 condition 不符合题意的时候，移动 left，直到满足题意，跳出 condition
    for  condition {
      val := nums[left]
      left++
    }
    
    //.......
  }
}
```

滑动窗口解题套路主要流程是包括

- `left right`的定义 
-  `condition`条件的选取（这个要结合题意）
- 以及两个`for`循环



## 动态规划解题套路

动态规划难点就是在于递推关系的发现，这个只能从具体的题目中来感受。如果说理解+ 背诵题目的话，其实动态规划的题目又是最容易记忆和理解的

- 明确`dp`数组的定义
- 明确 `dp[i]`和 `dp[i-1]`之间递推关系的定义(这个是动态规划的难点，其实说白了，就是要根据题意，找`dp[i]`和 `dp[i-1]`的关系 )，形式上看起来和高中学过的函数推到关系是一摸一样的，比如 `f(x) = f(x-1) + f(x-2)`

在实现代码的时候包括三个方面：

- 创建`dp`数组
- 初始化`dp`数组（需要特殊处理的值）
- 遍历 `nums`数组，实现一般性的递推关系

伪代码

```go
func main() {
  nums := []int{1,2,3,4}
  
  //1.定义 dp 数组
  
  dp := make([]int,len(nums))
  
  //2. 初始化 dp 数组（根据题目要求也可能不需要这一步骤）
  
  for k := range dp {
    dp[k] = 1
  }
  
  //3. 遍历 `nums`数组，实现一般性的递推关系
  
  for i := 0;i < len(nums);i++ {
    dp[i] = dp[i-1] + 1 // 比如：这里的递推关系为：前一个的 dp[i-1]的基础上，加1
  }
  
  //......
}
```

有一道动态规划最简单的入门题目 斐波那契数  https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/ 可以来体会下上面说的套路

LCR 126. 斐波那契数

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

> F(0) = 0
>
> F(1) = 1
>
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

思路：

- `dp`定义： 在 `i`位置的数字和 `dp[i]`
- `dp`递推关系：每一项数字都是前面两项数字的和，所以有 `dp[i] = dp[i-1] + dp[i-2]`

其实，题目已经直接给出了 递推关系 `F(n) = F(n-1)+F(n-2)`，但是大部分的题目是不会给出，需要我们结合题目自己是思考这个递推关系。

```go
func fib(n int) int {
    
  	//1. 定义 dp 数组
    dp := make([]int,n+1)
  	
    for i := 0; i <= n;i++ {
      	// 2. 初始化 （需要特殊处理的值）
        if i == 0 {
            dp[i] = 0
        } else if i == 1 { // 2. 初始化 （需要特殊处理的值）
            dp[i] = 1
        } else{
          	// 3. 递推关系 实现
             dp[i] = (dp[i-1] + dp[i-2]) % 1000000007 // 这个是题目要求【取模】
        }
    }
  	// 4. 返回 F(n) 的结果，即 dp[n]
    return dp[n]    
}
```



## 回溯算法代码套路

- 回溯算法：每一层选择一个元素，剩下的元素留给下一层选择，一层一层的进行选择，直到将所有的情况遍历完成

打个比方：

有 A B  C 三个苹果，有小明和小王 2个同学，去选择一个苹果。

如果小明先选择 A 苹果，那么小王只能选择B 或者 C 苹果；

如果小明选择 B 苹果，那么小王只能选择 A 或者 C 苹果；

如果小明选择 C 苹果，那么小王只能选择 A 或者 B 苹果。

可以看到，小明在选中一个苹果后，小王只能在剩下的苹果中选择一个留给自己（因为另一个已经被小明占用了）

回溯算法，就是在穷尽所有的情况，在 `backtrack`的 `for`循环中选中一个元素，剩下的的元素（通过 `start`来圈定）就留给 下一个 `backtrack`函数进行选择。

`start`不是必须的，有些题目可能需要在全部里面选择（比如，小明先选择 A 苹果，那么小王可以 选择A 或者 B 或者 C 苹果），有些需要在 `start`圈定的范围内选择（小明先选择 A 苹果，那么小王只能选择B 或者 C 苹果）

伪代码

```go
/*
nums  数组
start 遍历数组的起始位置（这个要根据题意，有时不需要）
trace 记录回溯的结果
*/
func backtrack(nums []int , start int, trace []int) {
  
  // 结束条件
  if condition {
    return
  }
  
  for i := start;i < len(nums);i++ {
    
    // 当前选择
    trace = append(trace,nums[i])
    
    // 继续下一轮的回溯
    backtrack(nums,i+1,trace)
    
    // 撤销当前选择
    trace = trace[:len(trace)-1]
  }
}
```

`start`用来限定每次 `backtrace`函数，能选择的元素范围

`trace = append(trace,nums[i])`在当前层选中某个元素，剩下的元素留给下层的回溯`backtrack`选择

![image-20241217163642574](./images/image-20241217163642574.png)

# CodeTop参考答案



## 3.无重复字符的最长字串 （滑动窗口）

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度

```
示例1
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

思路：

- 理解**子串**的含义：**子字符串** **是字符串中连续的** **非空** **字符序列。** 比如：`abc`的字串 `abc ab bc`等，但是 `ac`就不是字串，因为`a`和`c`并不连续，中间间隔了`b`
- 滑动窗口：保证 `left right`之间的字符没有重复出现。用`win`记录字符出现的次数，当`conditon`为 `win`中当某个字符出现次数 `>1`，保持 `right`不变，移动 `left`直至条件重新成立。

```go
func lengthOfLongestSubstring(s string) int {
    //滑动窗口【左右边界】
    left,right := 0,0

    // 记录窗口中字符出现的次数
    win := make(map[byte]int)

    result := 0
		
  	// 匿名函数，求最大值
    max := func (a ,b int) int {
        if a > b {
            return a
        }
        return b
    }
  
  	
    for right < len(s) {
				// 移动右边界+1
        ch := s[right] 
        right++ 
      	// 窗口中字符出现的次数+1
        win[ch]++
      	
	
        for win[ch] > 1 { //当字符出现的次数多于1次，说明滑动窗口中存在重复字符，不符合题意；需要移动左边界，把重复字符删掉，保证滑动窗口的字符数量都是1个，满足题意
            d := s[left]
            left++
            win[d]--
        }

        // 当前窗口中的字符数量
        result = max(result,right-left)
    }
    return result
}

```



## 146. LRU缓存

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

思路：

- LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的[页面置换算法](https://baike.baidu.com/item/页面置换算法/7626091?fromModule=lemma_inlink)，选择最近最久未使用的页面予以淘汰。该算法赋予每个[页面](https://baike.baidu.com/item/页面/5544813?fromModule=lemma_inlink)一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。（也就是当需要淘汰数据的时候，选择最久没有被使用的数据淘汰，刚刚使用的数据不要淘汰）
- 记忆点：两个数据结构 `map +  list `， `map`用于快速的判断`key`是否存在并获取到值，`list`用于记录【刚被访问】和【很久没访问】的数组，当需要淘汰数据的时候，直接从链表尾部淘汰即可。

```go
type LRUCache struct {
  	m map[int]*list.Element // 为了满足，题目要求的 o(1)的平均时间复杂度
    l *list.List // 链表：【刚被访问】数据在链表头部，【很久没访问】数据在链表尾部（当需要淘汰时，尾部的数据直接删除）
    cap int // 容量
}


type Data struct {
    Key int
    Value int
}

// 构造 LRUCache 对象
func Constructor(capacity int) LRUCache {
    cache := LRUCache{}
    cache.m = make(map[int]*list.Element,capacity)
    cache.l = list.New()
    cache.cap = capacity
    return cache
}

// Get 获取
func (this *LRUCache) Get(key int) int {
  	// 存在
    if v,ok := this.m[key];ok { 
      	//移动到头部（因为刚被访问了）
        this.l.MoveToFront(v)
      	//返回当前值
        return v.Value.(Data).Value
    }
  	// 不存在直接返回 -1
    return -1
}


// Put 修改
func (this *LRUCache) Put(key int, value int)  {
  	// 不存在
    if v,ok := this.m[key];!ok {
      	// 容量已经满了～～
        if this.cap == this.l.Len() { 
          	// 删除最久没访问的（也就是链表尾部元素）
            data := this.l.Remove(this.l.Back())
          	// 同时 map 中也要删除
            delete(this.m,data.(Data).Key) 
        }
        //新增（刚被访问过）
        e := this.l.PushFront(Data{key,value})
        this.m[key] = e

    }else { // 存在
      	// 修改数值
        v.Value = Data{key,value} 
      	// 同时移动到头部（刚被访问过）
        this.l.MoveToFront(v)
    }
}
```



## 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![image-20241214163002911](./images/image-20241214163002911.png)

思路：

- **对于递归算法，最重要的就是明确递归函数的定义**。具体来说，我们的 `reverseList` 函数定义是这样的：**输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的【头结点】**。

```go
// 递归算法 reverseList 函数的定义：将「以 head 为起点」的链表反转，并返回反转之后的【头结点】
func reverseList(head *ListNode) *ListNode {
  	// 当没有节点 or 只有一个节点的时候，直接返回head
    if head == nil || head.Next == nil {
        return head
    }
		
  	// 这里表示：将「以 head.Next 为起点」的链表反转，并返回反转之后的【头结点】
    last := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return res
}
```

![image-20241214165538983](./images/image-20241214165538983.png)

- 对于**迭代算法**，我们只需要定义一个前驱节点 `pre`，每次用当前节点`cur`替换 前驱节点`pre`

```go
func reverseList(head *ListNode) *ListNode {
  	// 前驱节点 pre
    var pre *ListNode = nil
    
    for head != nil {

        temp := head.Next // 临时保存后缀节点

        head.Next = pre //将head.Next 指向pre
        pre = head //  head 变成新的前驱节点pre

        head = temp // 继续下一个节点
    }
    return pre
}
```



## 215. 数组中的第K个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第  `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```
示例 1:

输入: [3,2,1,5,6,4], k = 2
输出: 5

```

思路:

- 第一种解法：利用**快速排序**算法，找到第 `k`个最大的元素

```go
func findKthLargest(nums []int, k int) int {

    //求第k大的元素，假如数组按照正序已经排列好了，那么第k大元素的索引位置为：len(nums)-k

    targetIndex := len(nums) - k

    lo,hi := 0,len(nums)-1

    for {
      	// 先确定某一个元素的索引位置
        idx := quickSort(nums,lo,hi) 
      	// 如果索引位置和 预期的targetIndex相同，说明找到了该元素
        if targetIndex == idx {
            return nums[idx]
        } else if targetIndex < idx { // 想找的元素索引位于左边，收缩 hi
            hi = idx-1
        } else { // 想找的元素索引位于右边，收缩 lo
            lo = idx+1
        }
    }

    return 0
}

// quickSort 快速排序，找一个参照元素v，使左边的元素都小于v，右边的元素都大于等于v，从而确定v在数组中的存储索引位置
func quickSort(nums []int ,lo,hi int) int {
    
    v := nums[lo] // 参照元素值

    left := lo+1
    right := hi
  	
  	// 保证 left <= right 的前提下
    for left <= right {
      	
      	// 让left指向的元素都要比v小
        for left <= right && v > nums[left] { 
            left++
        }
				// 让right指向的元素都要比v大or相等
        for left <= right && v <= nums[right] { 
            right--
        }
      	
        if left > right {
            break
        }

        // 执行到这里，说明left和right的元素不满足 nums[left] < v <= nums[right] 即left小right大的规则，交换left和right，重新满足条件
        nums[left],nums[right] = nums[right],nums[left]
    }

    // 最后交换 lo和right 例如 2 13，执行到这里，left指向 3 right指向 1，最后需要交换1和2的位置
    nums[lo],nums[right] = nums[right],nums[lo]
    return right
}
```

![image-20241214180009540](./images/image-20241214180009540.png)

- 第二个种解法：利用**小根堆**，保持堆中元素的数量最多 K 个。当超过 K 个元素，弹出堆顶元素，遍历数组中的所有元素，并经过 小根堆的过滤。当所有元素遍历完成后，堆顶元素就是第K大的元素

```go
// 利用小根堆，堆大小设定为k。遍历数组，将元素直接保存到堆中；保证的堆大小维持在 <=k
// 当所有的元素经过堆以后，最后堆堆顶元素就是结果
type MinHeap struct {
    data []int
}

func (m *MinHeap)Swap(i,j int) {
    m.data[i],m.data[j] = m.data[j],m.data[i]
}

func(m *MinHeap)Len() int {
    return len(m.data)
}

func (m *MinHeap)Less(i,j int) bool {
    return m.data[i] < m.data[j]
}

func (m *MinHeap)Push(x any) {
    m.data = append(m.data,x.(int))
}

func (m *MinHeap)Pop() any {
    x := m.data[len(m.data)-1]
    m.data = m.data[:len(m.data)-1]
    return x
}

func (m *MinHeap)Top() int {
    return m.data[0]
}

func findKthLargest(nums []int, k int) int {
    minH := &MinHeap{}
    heap.Init(minH)
  	// 遍历数组
    for _ , num := range nums {
      	// 保存到小根堆中
        heap.Push(minH,num)
      	// 当元素个数超过 k
        for minH.Len() > k {
            heap.Pop(minH) // 删除堆顶元素
        }
    }
    return minH.Top() // 最终结果，就是小根堆的堆顶元素值
}
```

下图表示演示了， 数组 `2 1 3` 求第 1 大元素的过程

![image-20241214183809449](./images/image-20241214183809449.png)



## 25. K个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

思路：

- 按照 长度k截取一段链表，然后将这段链表进行反转。【反转前的链表的头节点，变成了反转后的链表的尾部节点】
- 继续对后续的链表递归调用 `reverseKGroup(head *ListNode, k int) *ListNode`，并且进行拼接

![image-20241215164514723](./images/image-20241215164514723.png)

```go
// reverseKGroup 函数定义： 按照k个一组，反转从 head 开始的链表，并返回反转后的链表的头节点
func reverseKGroup(head *ListNode, k int) *ListNode {
    a,b := head,head
    //截取一个长度为k的链表
    for i :=0;i < k;i++{
      	// 说明不够k个一组，那就不需要反转
        if b == nil { 
            return head
        }
        b = b.Next
    }
  
  	//翻转链表 [a,b) 注意不包括节点b
    last := reverse(a,b)
  	// 对 [a,b) 进行反转以后，此时的节点 a，就是反转后的链表的最后一个尾部节点（因为：一开始a是第一个头节点）
    a.Next = reverseKGroup(b,k)
    return last
}

//翻转指定范围 [a,b)链表,返回头节点
func reverse(a,b *ListNode) *ListNode {
    var pre *ListNode = nil
    for a != b {
        temp := a.Next

        a.Next = pre
        pre = a
        a = temp
    }
    return pre
}
```



## 15. 三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

思路：

- 先给数组从小到大排序，然后双指针 `left` 和 `right` 分别在数组开头和结尾，这样就可以控制 `nums[left]` 和 `nums[right]` 这两数之和的大小：
- 如果你想让它俩的和大一些，就让 `left++`，如果你想让它俩的和小一些，就让 `right--`
- 基于两数之和可以得到一个万能函数 `nSumTarget`，扩展出 n 数之和的一般解法

![image-20241215171006692](./images/image-20241215171006692.png)

```go
func threeSum(nums []int) [][]int {
  	//1. 对数组进行排序
    sort.Ints(nums)
    return nSumTarget(nums,3,0,0)
}

// nums: 数组
// n： n数之和
// start： 数组遍历的边界
// target：目标和
func nSumTarget(nums []int, n int ,start int, target int) [][]int{
    size := len(nums)
    var result [][]int
    if n < 2 || size < n { // 最低求两数之和 or 数组中数据个数不能小于n
        return result
    } else if n == 2 {//求两数和
      	// left 左边界 right 右边界
        left,right := start,size-1
        for left < right {

            leftValue := nums[left]
            rightValue := nums[right]
          	//左右位置的两数和
            sum := leftValue + rightValue

            if sum < target { // 求的sum值，比目标和偏小，增大left
                for left <right && nums[left] == leftValue {
                    left++
                }
            } else if sum > target { // 求的sum值，比目标和偏大，减小right
                for left < right && nums[right] == rightValue {
                    right--
                }
            } else {
              	// 找到一组 leftValue 和 rightValue
                result = append(result,[]int{leftValue,rightValue})
              	// 题目要求不能重复
                for left <right && nums[left] == leftValue {
                    left++
                }
                for left < right && nums[right] == rightValue {
                    right--
                }
            }
        }
    }else {
        for i := start;i<size;i++{ //固定一个数值，求剩下的两个数值
            sub := nSumTarget(nums,n-1,i+1,target-nums[i])
            //对结果整合
            for _,v := range sub {
                v = append(v,nums[i])//追加当前数值，组成n数之和
                result = append(result,v)
            }
            //判断下一个数值是否和当前值重复（一样）
            for i+1 < size && nums[i] == nums[i+1]{
                i++
            }
        }
    }

    return result
}
```



## 53. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**：是数组中的一个连续部分。

思路：

- `dp` 数组的定义：**以 `nums[i]` 为结尾的「最大子数组和」为 `dp[i]`。**

- `dp`数组递推关系为： `dp[i] = max(0,dp[i-1]) + num[i]`

  `dp[i]` 有两种「选择」，要么与前面的相邻子数组`dp[i-1]`连接，形成一个和更大的子数组；要么不与前面的子数组连接，自己单独一个元素，作为一个子数组。

```go
func maxSubArray(nums []int) int {
	
  // 1. 构建dp数组
	dp := make([]int, len(nums))
  // 2.初始化：根据定义，第一个元素的最大子数组和，就是第一个元素值
	dp[0] = nums[0]
  
  // result 记录最大子数组和
  result := nums[0] 

	// 3.应用递推关系：针对每个元素i作为结尾，求以元素i结尾的最大子数组和
	for i := 1; i < len(nums); i++ {
    // 如果dp[i-1]为负数，当前元素本身就是最大和（也就是不需要和前面其他元素进行连接）；
    dp[i] = max(dp[i-1],0) + nums[i] 
		result = max( result , dp[i] )
	}
	return result
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```



## 912. 排序数组

给你一个整数数组 `nums`，请你将该数组升序排列。你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。

思路：

这里提供必考的**3种排序算法**

> 快速排序

**快速排序是先将一个元素排好序，然后再将剩下的元素排好序**。

```go
func sortArray(nums []int) []int {
    //快速排序
    quickSort(nums,0,len(nums)-1)
    return nums
}

func quickSort(nums []int, lo ,hi int) {
    if lo >= hi { //相当于只有一个数，或者越界，就不用比较了
        return
    }

    //1.选择一个数，作为参考元素
    val := nums[lo]

    //2.左右起始索引
    left := lo + 1
    right := hi

    //3.使左边nums[left]比val小   右边nums[right]比val大
    for left <= right {
        for left <= right && nums[left] < val { //ums[left]记录比val小的数据索引
            left++
        }

        for left <= right && nums[right] >= val {//nums[right]记录比val大的数据索引
            right--
        }
        if left > right {
            break
        }
        // 执行到这里，说明 nums[left]比 val 大， nums[right] 比val 小（也就是不满足上面的条件）
        // 交换 left 和 right，让 left right 指向的元素继续满足条件
        nums[left],nums[right] = nums[right],nums[left]
    }
    //交换 lo 和right，这样nums[lo]这个元素已经排序完成，保存在了 right 索引位置
    nums[lo],nums[right] = nums[right],nums[lo]

  	// 递归调用 quickSort，让[lo,right-1] [right+1,hi] 两个子数组也都有序。
    //左边数组
    quickSort(nums,lo,right-1)
    //右边数组
    quickSort(nums,right+1,hi)
    return 
}
```

![image-20241216102101741](./images/image-20241216102101741.png)

> 归并排序

![image-20241216124441311](./images/image-20241216124441311.png)

```go
var temp []int = nil
func sortArray(nums []int) []int {

    //归并排序
    temp = make([]int,len(nums)) //临时数组，用来临时存储merge后的有序结果
    sort(nums,0,len(nums)-1)
    return nums
}

// sort 函数定义：对数组nums范围[lo,hi]排序，并使之有序
func sort(nums []int ,lo int,hi int) {
    if lo == hi { //单个元素就不用排序了
        return
    }
    mid := lo + (hi-lo)/2//将数组一分为二
    sort(nums,lo,mid)//对左边排序
    sort(nums,mid+1,hi)//对右边排序
    merge(nums,lo,mid,hi) //合并左右 有序数组
}

//合并有序数组
func merge(nums []int,lo int ,mid int,hi int) {

    left := lo //左边有序数组起始点
    right := mid+1//右边有序数组起始点

    for i := lo;i <= hi;i++ { //总共[lo,hi]个元素
        if left == mid+1 { //左边全部遍历完
            temp[i] = nums[right]
            right++
        } else if right == hi+1 { //右边全部遍历完
            temp[i] = nums[left]
            left++
        } else if nums[left] > nums[right]{ // 优先合并小的元素
            temp[i] = nums[right]
            right++
        } else {
            temp[i] = nums[left]
            left++
        }
    }
    //将临时数组中的数组temp，复制到 nums中
    for i:= lo;i<=hi;i++{
        nums[i] = temp[i]
    }
}
```







> 堆排序



利用的下沉操作sink，将数组最大元素移动到数组首部，然后和尾部元素交换（尾部元素就不用再管了，因为已经有序了）此时尾部就是最大的值；然后对剩下的数组元素进行下沉操作；保证次大的元素，成为新的首部元素；继续和尾部交换（注意这里的尾部不是最后一个，是倒数第二个了）

![image-20241216112926897](./images/image-20241216112926897.png)

```go
func sortArray(nums []int) []int {
   
    length := len(nums)
  	// 1.一开始需要针对数组，进行初始化操作,从第一个非叶子节点开始
    for i := length/2-1;i >= 0;i-- {  // 倒着遍历
        sink(nums,i,length) 
    }
  	// 2.上面初始化完成后，保证了数组中的最大值，已经成为数组的第一个元素

    for i := length-1;i >= 0;i-- {
        // 交换首部和尾部元素
        nums[0],nums[i] = nums[i],nums[0]
        length-- // 上面交换以后，尾部元素就是最大的有序元素了；只需要对前面剩余的length-1长度的元素进行排序，需要排序的长度变短了，这也就是为什么倒序遍历的原因（因为最后一个元素已经处理好了）
        // 对首部元素进行下沉操作（因为首部元素经过上面的交互，已经变成了一个新元素，不一定是次大的元素）
        sink(nums,0,length)
    }

    return nums
}


// 下沉操作，就是比较节点的和左右节点的大小关系；找出三个节点中的最大的索引值
func sink(nums []int ,idx ,len int) {
    for leftIdx(idx) < len { // 目的：如果左边的索引都越界了，右边的索引肯定也越界了
        maxIdx := idx

        // 注意：这里的用的是 nums[maxIdx]
        if leftIdx(idx) < len && nums[maxIdx] < nums[leftIdx(idx)] { // 左边的元素比较大
            maxIdx = leftIdx(idx)
        }   

        if rightIdx(idx) < len && nums[maxIdx] < nums[rightIdx(idx)] {
            maxIdx = rightIdx(idx)
        }

        // maxIdx的目的：为了记录最大的索引是哪个
        if maxIdx == idx { // 说明自己就是最大的那个，不需要下沉了(maxIdx在这里有种指针的感觉)
            break
        }

        // 交换数值
        nums[maxIdx],nums[idx] = nums[idx],nums[maxIdx]
      	// 继续进行下沉操作
        idx = maxIdx 
    }
}

func leftIdx(idx int) int {
    return idx *2 +1
}

func rightIdx(idx int) int {
    return idx*2+2
}
```

![image-20241216111613587](./images/image-20241216111613587.png)



## 21.合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

![image-20241216125835417](./images/image-20241216125835417.png)

思路：

这个算法的逻辑类似于「拉拉链」，`list1, list1` 类似于拉链两侧的锯齿，指针 `cur` 就好像拉链的拉索，将两个有序链表合并。

**代码中还用到一个链表的算法题中是很常见的「虚拟头节点」技巧，也就是 `dummy` 节点**，它相当于是个占位符，可以避免处理空指针的情况，降低代码的复杂性。

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
  	// 1.定义虚拟头结点
    var dummy *ListNode = &ListNode{Val : 0,Next:nil}
    cur := dummy
		
  	//2. 将两个链表中，值小的一个节点拼接到 cur 后面
    for list1 != nil && list2 != nil {
        if list1.Val <= list2.Val {
            cur.Next = list1
            list1 = list1.Next
        } else {
            cur.Next = list2
            list2 = list2.Next
        }
         cur = cur.Next
    }
		//3. 假如两个链表一个长 or 一个短，会导致其中一个链表还有剩余节点，直接拼接到cur后面即可
    if list1 != nil {
        cur.Next = list1
    }

    if list2 != nil {
        cur.Next = list2
    }
		//4. 返回dummy节点的下一个节点，才是要求的结果
    return dummy.Next
}
```



## 5. 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

思路：

**寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串**

```go
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    更新答案
```

找回文串的关键技巧是传入两个指针 `l` 和 `r` 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。

```go
for 0 <= i < len(s):
    // 找到以 s[i] 为中心的回文串
    palindrome(s, i, i)
    // 找到以 s[i] 和 s[i+1] 为中心的回文串
    palindrome(s, i, i + 1)
    更新答案
```

比如 `abba`的最长回文子串是 `abba` 如果只是以一个字符`s[i]`作为中心查找，该字符串是查不到回文串的。

```go
func longestPalindrome(s string) string {

	var result string

	for i := 0; i < len(s); i++ {

		s1 := isPalidrome(s, i, i)
		if len(s1) > len(result) {
			result = s1
		}

		s2 := isPalidrome(s, i, i+1)
		if len(s2) > len(result) {
			result = s2
		}
	}

	return result
}

func isPalidrome(s string, left, right int) string {

	for left >= 0 && right <= len(s)-1  && s[left] == s[right] {
			left--
			right++
	}
	return string(s[left+1 : right])
}
```



## 102. 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![image-20241216131328055](./images/image-20241216131328055.png)

思路：

这题就是固定的解法套路，没有技巧，全靠记忆

```go
func levelOrder(root *TreeNode) [][]int {
    
    result := [][]int{}
  	//1. 判断是否为空树
    if root == nil {
        return result
    }
  	//2. 定义数组，保存根节点
    saveKey := []*TreeNode{}
    saveKey = append(saveKey,root) 
		//3. 判断是否为空
    for len(saveKey) != 0 { 
      	//4. 确定本次的边界
        count := len(saveKey) 
        temp := []int{}
        for i := 0;i< count;i++ { 
          	//5.把边界内的数值取出，并保存下来。
            temp = append(temp,saveKey[i].Val)
          	//6.注意这里，不为nil才保存到 saveKey中
            if saveKey[i].Left != nil {
                saveKey = append(saveKey,saveKey[i].Left)
            }
            if saveKey[i].Right != nil {
                saveKey = append(saveKey,saveKey[i].Right)
            }
        }
        result = append(result,temp)
      	//7.从 count截断 saveKey，剩下的就是下层的节点
        saveKey = saveKey[count:]
    }
    return result
}
```



## 1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。

思路：

- 简单说，数组其实可以理解为一个「索引 -> 值」的哈希表映射，而我们又建立一个「值 -> 索引」的映射即可完成此题。

```go
func twoSum(nums []int, target int) []int {
    //利用map实现
    m := make(map[int]int) //key表示数值 value表示索引值
    
    for k,v := range nums {
      	// target-v查找哈希表，判断是否已经存在该值
        if index ,ok := m[target-v];ok {
            return []int{k,index}
        }
      	// 保存 值->索引
        m[v] = k
    }
    return nil
}
```



## 33.搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

思路：

- 题目要求时间复杂度`O(log n)` 那就要想到二分法

![image-20241216151627555](./images/image-20241216151627555.png)

```go
func search(nums []int, target int) int {
    //！！！ 二分法查找；需要画图理解
    left , right := 0,len(nums)-1
    for left <= right {
        mid := left + (right-left)/2

        if nums[mid] == target { // 找到 target
            return mid
        } else if nums[left] <= nums[mid] { // 说明 [left,mid] 是有序递增的子数组
            if nums[left] <= target && target < nums[mid]  {//2. target 位于 [left,mid]有序递增数组中
                right = mid-1 // 收缩右边界（其实就是丢弃右边的子数组）
            }else {
                left = mid+1
            }
        }else { //说明 [mid,right] 是有序递增的子数组
            if nums[mid] < target && target <= nums[right] { // target位于 [mid,right]有序递增数组中
                left = mid+1  // 收缩左边界（其实就是丢弃左边的子数组）
            }else {
                right = mid-1
            }
        }
    }
    return -1
}
```



## 200.岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

思路：

- 用 DFS 算法解决岛屿题目是最常见的，每次遇到一个岛屿中的陆地，就用 DFS 算法吧这个岛屿「淹掉」。

```go
func numIslands(grid [][]byte) int {
    m := len(grid)
    n := len(grid[0])
    result := 0
  	// 对二维数组进行遍历
    for i := 0;i < m;i++ {
        for j := 0;j < n ;j++ {
          	// 一旦发现一个陆地
            if grid[i][j] == '1' { 
                result++
              	// 就将和该 grid[i][j] 陆地相连接的陆地，全部淹没掉
                dfs(grid,i,j)
            }
        }
    }

    return result
}

// 深度优先算法，
func dfs(grid [][]byte,i,j int) {
    m := len(grid)
    n := len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n { //越界检测
        return
    }
		// 说明当前是水
    if grid[i][j] == '0' {
        return
    }
  	// 执行到这里，说明你是陆地
    grid[i][j] = '0' //淹没掉陆地
    dfs(grid,i-1,j) //上
    dfs(grid,i+1,j) //下 
    dfs(grid,i,j+1) //右
    dfs(grid,i,j-1) //左
}
```



## 121.买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

思路：

买卖股票类的题目有一套**通用的解题方案**：

- `dp`数组定义：

> `dp[i][k][0 or 1]` 
>
> `0 <= i <= n - 1, 1 <= k <= K`      
>
>   n 为天数，大 K 为完成交易数的上限，0 和 1 代表是否持有股票

所以，`dp[i][k][0 or 1]` 的含义就是：在从 `0`到 `i`天，完成了`k`笔交易，不持有`0` or 持有 `1`股票，能获取的最大利润

- `dp`的递推关系定义：

```go

dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
//dp[i][k][0] 表示 从 0 到 第i天，完成k笔交易，不持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][0] 								表示 从 0 到i-1天（也就是前一天），也没有持有股票
// dp[i-1][k][1] + prices[i]  	表示 从 0 到i-1天（也就是前一天），持有了股票，但是今天选择卖出，那么今天不就不持有股票了


dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
// dp[i][k][1]  表示从 0 到第i天，完成k笔交易，持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][1] 							 	表示从 0 到 i-1天（也就是前一天），也持有股票
// dp[i-1][k-1][0] - prices[i] 	表示从 0 到 i-1天（也就是前一天），未持有了股票，但是今天选择买入，那么不就持有股票了。因为是今天买入股票，完成了一笔交易，今天的交易次数是k的前提下，那么前一天的交易次数就是 k-1


最终答案：因为要求最大利润，那只有不持有股票的最大利润 dp[n-1][k][0] （从 0到 n-1，完成了k笔交易后，不持有股票）
```

本题答案：

```go
func maxProfit(prices []int) int {
  	// 1. 构建二维 dp数组
    n := len(prices) //n天
    dp := make([][]int,n)
    for k,_ := range dp {
        // 每天只有两种选择 【0不持有 1持有】
        dp[k] = make([]int,2)
    }

    //状态转移方程
    /*
        dp[i][0 or 1] 表示到第i天时候，选择（持有或不持有股票）能获取到的最大利润；
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i]) // 卖出
        dp[i][1] = max(dp[i-1][1], -price[i]) //买入
    */

    for i := 0;i < n; i++ {
      	//2. 特殊处理
        if i - 1 == -1 {
            dp[i][0] = 0
            dp[i][1] = -prices[i]
        } else {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            // 核心在于：只能有一次买卖行为；在第i天持有股票，那说明之前就一直持有 dp[i-1][1]
            // 或者，之前一直都没有持有，今天第i天是第一次交易行为；
            // 如果带上 dp[i-1][0] 有考虑之前的历史交易行为（题目限定只有一次交易行为）
            dp[i][1] = max(dp[i-1][1], -prices[i]) 
        }
    }
		//因为要求最大利润，那肯定是不持有最大利润最大
    return dp[n-1][0] 
}

func max( a,b int) int {
    if a > b {
        return a
    }
    return b
}
```



## 46.全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```
示例1:
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

思路：

- 可以参考下👆回溯算法解题模板

因为是求排列，每选择一个元素后，下一个 `backtrack`从**所有的元素**中（所以不需要 `start`来圈定选择范围）再选择下一个元素，为了避免同一个元素重复被选中，用`used`记录元素是否已经被选过。

```go

var result [][]int
func permute(nums []int) [][]int {
    result = [][]int{} //清空结果
  	// 记录是否已经使用过
    used := make([]bool,len(nums))
    trace := make([]int,0)
  	//回溯算法
    backtrack(nums,trace,used)
    return result
}

//回溯算法
func backtrack (nums []int,trace []int , used []bool)  {

    if len(trace) == len(nums) { //trace记录路径
        temp := make([]int,len(trace)) //golang 这个要注意，切片需要复制一个出来
        copy(temp,trace)
        result = append(result,temp)
        return
    }
    // 排列，每次都从头开始选择
    for i := 0;i < len(nums);i++ {
        
        if used[i] { //当前值已经选择过了，跳过
            continue
        }

        trace = append(trace,nums[i]) //选择
        used[i] = true

        backtrack(nums,trace,used)

        trace = trace[:len(trace)-1]//撤销选择
        used[i] = false
    } 

}
```



## 88.合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

思路：

- 很像前文中讲过的 [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)，这里让你合并两个有序数组。
- 对于单链表来说，我们直接用双指针从头开始合并即可，但对于数组来说会出问题。因为题目让我直接把结果存到 `nums1` 中，而 `nums1` 的开头有元素，如果我们无脑复制单链表的逻辑，会覆盖掉 `nums1` 的原始元素，导致错误。但 `nums1` 后面是空的呀，所以这道题需要我们稍微变通一下：**将双指针初始化在数组的尾部，然后从后向前进行合并**，这样即便覆盖了 `nums1` 中的元素，这些元素也必然早就被用过了，不会影响答案的正确性。

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //双指针：从数组的尾部，向前合并
    left,right := m-1,n-1 //都指向尾部
    pos := m+n-1
    for left >= 0 && right >= 0 {
        if nums1[left] >= nums2[right] { // 选择大的，放入尾部
            nums1[pos] = nums1[left]
            pos--
            left--
        } else {
            nums1[pos] = nums2[right]
            pos--
            right--
        }
    }
  	// right 还有剩余，直接复制
    for right >=0 {
        nums1[pos] = nums2[right]
        pos--
        right--
    }
    return 
}
```



## 20.有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

思路：

- 栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。

- 假设字符串中只有圆括号 **（）**，如果想让括号字符串有效，那么必须做到：

  **每个右括号 `)` 的左边必须有一个左括号 `(` 和它匹配**。

  比如说字符串 `()))((` 中，中间的两个右括号**左边**就没有左括号匹配，所以这个括号组合是无效的。

- 利用栈，保证完成匹配的括号，不会存在在栈中，最后栈中剩下的就是没有完成匹配的；

```go
func isValid(s string) bool {
  	// 初始
    stack := make([]byte,0)
  	// 遍历字符
    for i := 0;i< len(s);i++ {  
      	// 如果栈不为空，判断栈顶括号 和 当前括号是否匹配
        if len(stack) != 0 && isPair(stack[len(stack)-1],s[i]) {
            stack = stack[:len(stack)-1] // 出栈
        } else {
            stack = append(stack,s[i]) // 否则，当前的括号才能入栈
        }
    }
  	// 栈为空，说明括号都完全匹配
    if len(stack) == 0 {
        return true
    }
  	// 比如 ({)}
    return false
}

func isPair(a,b byte) bool {
    if a == '(' && b == ')' {
        return true
    }

    if a == '[' && b == ']' {
        return true
    }

    if a == '{' && b == '}' {
        return true
    }

    return false
}
```



## 141.环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

![image-20241217184157384](./images/image-20241217184157384.png)

思路：

经典题目了，使用双指针技巧中的快慢指针，每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```go
func hasCycle(head *ListNode) bool {
    //快慢指针
    slow,fast := head,head
  	// 表示 fast 能够跳跃两步。如果 fast == nil(空节点) 或者 fast.Next == nil（只有fast这一个节点，没有后续节点）
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```



## 103.二叉树的锯齿形层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

思路：

- 这题和上面的层序遍历是一样的，只是多了一个元素值存储的方向的控制 `flag`

```go
func zigzagLevelOrder(root *TreeNode) [][]int {

    result := [][]int{}
  	// 空树
    if root == nil {
        return result
    }

    //和层序遍历一样
    nodes := []*TreeNode{}
    nodes = append(nodes,root)

    flag := true //控制结果 放入的方向

    for len(nodes) != 0 {
        count := len(nodes) // 节点数量

        temp := []int{}
        for i := 0;i < count;i++ {  

            if flag { // 保存在尾部（正序）
                temp = append(temp,nodes[i].Val)
            } else {
              	// 保存在头部（倒序）
                temp = append([]int{nodes[i].Val},temp...)
            }

            // left不为空
            if nodes[i].Left != nil {
                nodes = append(nodes,nodes[i].Left)
            }
						// right 不为空
            if nodes[i].Right != nil {
                nodes = append(nodes,nodes[i].Right)
            }
        }
      	// 切换方向
        flag = !flag
        result = append(result,temp)
        nodes = nodes[count:] //count之前的需要舍弃
    }
    return result
}
```



## 235.二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

思路：

- 给出递归函数的定义：给该函数输入三个参数 `root`，`p`，`q`，它会返回一个节点：
- 情况 1，如果 `p` 和 `q` 都在以 `root` 为根的树中，那么 `left` 和 `right` 一定分别是 `p` 和 `q`。
- 情况 2，如果 `p` 和 `q` 都不在以 `root` 为根的树中，直接返回 `null`。
- 情况 3，如果 `p` 和 `q` 只有一个存在于 `root` 为根的树中，函数返回该节点。

![image-20241217191330565](./images/image-20241217191330565.png)

```go
// 给该函数输入三个参数 `root`，`p`，`q`，它会返回一个节点 
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
   	
     if root == p || root == q || root == nil{
         return root
     }

     left := lowestCommonAncestor(root.Left,p,q)
     right := lowestCommonAncestor(root.Right,p,q)
		 // p q 分别位于 root 的 left right 中
     if left != nil && right != nil {
         return root
     }
		 // p q 都位于 left
     if left != nil {
         return left
     }
		 // p q 都位于 right
     if right != nil {
         return right
     }
     // p q 不在 root 树中
     return nil
}
```

## 92.反转链表 II

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

![image-20241218153607707](./images/image-20241218153607707.png)

思路：

- 递归解法：

  迭代解法很简单，用一个 for 循环即可，但这道题经常用来考察递归思维，让你用纯递归的形式来解决。

  要想真正理解递归操作链表的代码思路，关键点还是要明确递归函数的定义，推导出递归翻转前 `N` 个节点的算法，最后改写出递归翻转区间内的节点的解法代码

  

  ```go
  // 翻转left，right之间的链表
  func reverseBetween(head *ListNode, left int, right int) *ListNode {
      //先找到【翻转的第一个起始节点】，才开始真正的翻转
      if left == 1 {
          return reverseN(head,right)
      }
      //说明当前节点，不需要翻转。当前节点的尾部，拼接翻转后链表的头部
      head.Next = reverseBetween(head.Next,left-1,right-1)
      return head
  }
  
  var successor *ListNode = nil
  // 从head开始，翻转n个节点，返回链表的头节点
  func reverseN(head *ListNode,  n int) *ListNode {
      if n == 1 {  //说明当前是最后一个节点
          successor = head.Next // 记录后续节点
          return head
      }
  		
    	// 从head.Next 开始，翻转n-1个节点，返回链表的头节点
      last := reverseN(head.Next,n-1)
    	// 对head节点反转（反转后head节点就变成了最后一个节点）
      head.Next.Next = head 
      head.Next = successor
  
      return last
  }
  
  ```

  ![image-20241218170704572](./images/image-20241218170704572.png)

- 迭代解法：

  > dummy 定义虚拟节点
  >
  > 遍历整个链表，cur指向正在访问的节点，i 记录指向的节点是第几个。如果cur指向的节点不是要反转的节点，不断的追加到p.Next同时p也不断的移动
  >
  > 如果cur指向的节点是要反转的节点，不断的追加到p.Next同时p 不移动
  >
  > leftNode 用来记录第一个反转的节点（因为反转后，第一个节点，变成反转后的最后一个节点），如上中的节点2，变成反转后最后一个节点

![image-20241218164408974](./images/image-20241218164408974.png)

```go
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    // 虚拟节点
    dummy := &ListNode{}
    p := dummy 
    // 表示当前 cur指向的是第几个节点
    i := 1
    cur := head

    var leftNode *ListNode

    // 遍历链表中的每一个节点
    for cur != nil {
        // 将下一个节点记录来下
        temp := cur.Next
        if  left <=i && i <= right { // 进入到反转范围的节点
            // 将节点保存在p后面，但是p不移动
            cur.Next = p.Next
            p.Next = cur

            // 记录第一个反转的节点
            if i == left {
                leftNode = cur
            }
            // 最后让p指向第一个反转的节点（因为已经成为了最后一个节点）
            if i == right {
                p = leftNode
            }
        } else { // 不是要反转的节点
            // 将节点保存在p后面，但是p也跟着移动
            p.Next = cur
            p = p.Next
            p.Next = nil // 让p的后续节点为nil，特例：[3,5] left= 2 right = 2
        }
        // 跳到，下一个节点
        i++
        cur = temp
    }
    return dummy.Next
}
```



## 23.合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

思路：

- 类型于归并排序，将链表数组切分称两个子数组，分别对子数组排序，然后将排序后的两个子数组进行`merge`成一个大的有序数组

```go
func mergeKLists(lists []*ListNode) *ListNode {
  	// 这里lists的长度可能为0
    if len(lists) == 0 {
        return nil
    }
    return sortK(lists,0,len(lists)-1) 
}

//定义：对【left，right】之间的链表排序，返回有序链表头节点
func sortK( lists []*ListNode,left,right int) *ListNode {
    if left == right {
        return lists[left]
    }
  	// 切分成两个子数组，分别排序
    mid := left +(right-left)/2
    l := sortK(lists,left,mid)
    r := sortK(lists,mid+1,right)
  	// 合并两个有序链表
    return merge(l,r)
}
//对两个有序链表合并，返回头节点
func merge(l,r *ListNode) *ListNode {
  	//虚拟头节点
    dummy := &ListNode{Val:0,Next:nil} 

    p := dummy

    for l != nil && r != nil {
        if l.Val < r.Val {
            p.Next = l
            l = l.Next
        } else {
            p.Next = r
            r = r.Next
        }
        p = p.Next
    }
    
    if l != nil {
        p.Next = l
    }

    if r != nil {
        p.Next = r
    }
    return dummy.Next
}
```



## 54.螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

![image-20241218172519569](./images/image-20241218172519569.png)

思路：

本质就是对二维数组的遍历，先横向遍历，再竖向遍历（一直反复进行）。注意的点：范围不要越界。

```go
func spiralOrder(matrix [][]int) []int {
    m := len(matrix)
    n := len(matrix[0])

    top,end := 0, m-1
    left,right := 0,n-1
    var result []int
		// 结束条件 result已经保存了所有的元素
    for len(result) < m * n {

        if top <= end { //上下边界不越界 
            //遍历top，从left 到right
            for i := left; i <= right;i++ {
                result = append(result,matrix[top][i])
            }
            top++ // 顶部下移
        }

        if left <= right {
            //遍历right，从top到end
            for i := top;i <= end;i++ {
                result = append(result, matrix[i][right])
            }
            right-- //右边左移
        }
        
        if top <= end {
            //遍历end，从right到left
            for i := right;i >= left;i-- {
                result = append(result,matrix[end][i])
            }
            end-- //底部上移
        }
        
        if left <= right {
            //遍历left，从end到top
            for i := end;i >= top;i-- {
                result = append(result,matrix[i][left])
            }
            left++  
        }
    }
    return result
}
```



## 300.最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列

思路：

- `dp` 数组的定义：`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度。

  那么 `dp` 数组中最大值，就是最长的递增子序列长度。

- 递推关系： `if nums[i] > nums[i-1]  dp[i] = max(dp[i],dp[i-1] + 1)`

```go
func lengthOfLIS(nums []int) int {
    //定义dp[i] 为以nums[i]为结尾，最大子序列【长度】

    dp := make([]int,len(nums))
    var result int
		// 默认每次元素就是一个子序列
    for k,_ := range dp {
        dp[k] = 1
    }

    for i := 0;i < len(nums);i++ {

        for j := 0;j < i;j++ { //和i之前的所有dp都对比一下[0, i-1]

            if nums[i] > nums[j] { //判断尾部数值大小
                dp[i] = max(dp[i],dp[j]+1)
            }
        }

        // 每个i位置处的最长递增子序列的长度中【最大值】
        result = max(result,dp[i])
    }
    return result
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```



## 415.字符串相加

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。

思路：

- 双指针，分别指向字符串的尾部字符
- `carry`记录进位

```go
func addStrings(num1 string, num2 string) string {

    // 这题和二进制相加一样的解法，只是一个是十进制，一个是二进制

    l1 := len(num1)-1
    l2 := len(num2)-1

    carry  := 0
    result := ""
  	// 注意：条件是【或】的关系
    for l1 >= 0 || l2 >= 0 || carry != 0 {
        sum := carry
        if l1 >= 0 {
            sum += int(num1[l1] - '0')
            l1--
        }
        if l2 >= 0 {
            sum += int(num2[l2] - '0')
            l2--
        }
        result = string(sum % 10 + '0') + result // 余数拼接到result前面
        carry = sum / 10
    }
    return result
}
```



## 160.相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回`null`。

图示两个链表在节点 `c1` 开始相交**：**

![image-20241218174907646](./images/image-20241218174907646.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 

思路：

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`。**

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

![image-20241218180856369](./images/image-20241218180856369.png)

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {

    p1,p2 := headA,headB

    for p1 != p2 {
        if p1 == nil {
            p1 = headB
        } else {
            p1 = p1.Next
        }

        if p2 == nil {
            p2 = headA
        } else {
            p2 = p2.Next
        }
    }
    return p1
}

```

- 这里再提供另外一种方案

思路：

- 将两个链表首尾串联起来（物理上串联，上面的解法是逻辑上串联）
- 利用快慢指针，判断是否存在环
- 如果存在环，`fast`移动的距离是 2倍的 `slow`（因为`fast`一次移动2步，`slow`一次移动1步，如果相遇了，说明`fast`移动的距离是`slow`的2倍）
- 重置 `slow = headA`，同时移动 `slow fast`直到相遇，就是相交点。

![image-20241219153940645](./images/image-20241219153940645.png)

```go
func getIntersectionNode1(headA, headB *ListNode) *ListNode {
    //1.找到A链表最后一个节点
    q := headA

    for q.Next != nil {
        q = q.Next
    }
    //2.此时q指向链表A的最后一个节点，拼接A链表 + B链表
    q.Next = headB

    //3.快慢指针，判断是否有环
    slow,fast := headA,headA

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {//有环
            break
        }
    }

    //4. 执行到这里，并且fast == nil || fast.Next== nil，说明上面的for循环，不是因为有环结束的，是因为无环
    if fast == nil || fast.Next == nil {
     	 q.Next = nil //!!!断开两个链表(题目要求必须保持原来的结构)
        return nil
    }

    //5.有环，找到环的起始点
    slow = headA
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
  	// !!!断开两个链表(题目要求必须保持原来的结构)
    q.Next = nil

    return slow

}
```



## 143.重排链表

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

思路：

- 先利用快慢指针将链表切分称两个子链表 `l1 l2`
- 对 `l2`进行反转
- 最后将 `l1 l2`节点交错的拼接到一起

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reorderList(head *ListNode)  {
    // 无节点 or 单个节点
    if head == nil || head.Next == nil {
        return
    }
    //快慢指针，找到中点
    fast,slow := head,head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    //!!!注意这个细节
    l1 := head // 子链表 l1
    l2 := slow.Next //中点的下一个节点，作为子链表 l2 起始节点
    slow.Next = nil //为了让l1尾部指向 nil 节点
  
    //翻转链表 l2
    l2 = reverseList(l2)
  
    //合并链表
    for l1 != nil && l2 != nil {
        l1Next := l1.Next
        l2Next := l2.Next

        l1.Next = l2
        l1 = l1Next

        l2.Next = l1 // l2指向l1 (此时 l1 = l1Next 已经移位了一步)
        l2 = l2Next
    }
}

// 翻转链表
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
   
    last := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return last 
}
```



## 56.合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start, end]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

思路：

- 一个区间可以表示为 `[start, end]`，先按区间的 `start` 排序：
- **显然，对于几个相交区间合并后的结果区间 `x`，`x.start`的值 一定是这些相交区间中 `start` 最小的，`x.end` 一定是这些相交区间中 `end` 最大的**：

![image-20241219163052347](./images/image-20241219163052347.png)

```go
func merge(intervals [][]int) [][]int {
		// 按照 start 正序排列
    sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

    var result [][]int
    pre := intervals[0] //前一个切片

    for index := 1 ; index < len(intervals); index++ {
        cur := intervals[index] //当前切片
        
      	// 当前切片头部 cur[0] <= 前一个切片尾部pre[1] 【有交集】
        if cur[0] <= pre[1] {
            pre[1] = max(pre[1],cur[1]) //合并两个为一个，用尾部较大的值，作为合并后的区间尾部 pre[1]
        } else { //当前cur 和pre没有交集，将pre保存起来，同时cur作为pre
            result = append(result,pre)
            pre = cur
        }
    }
		// 最后记得，将pre保存到 result一份
    result = append(result,pre)
    return result
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```



## 42.接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

思路：

- 对于任意一个位置 `i`，能够装的水为：

```go
water[i] = 		// 左右两边的最高值的最小值 -  height[i]
							min(
  						// 0到i的最高值
  						max(height[0..i]) , 
  						// i 到 end的最高值
  						max(height[i..end])  )   - height[i]
```

![image-20241219165002229](./images/image-20241219165002229.png)

```go
func trap(height []int) int {
    ///！！！思路：答案理解起来比较容易，第一次做估计很难想到；

    //从左到右遍历[0...i]，求左边每个位置i的最高高度，l_dp[i] = max(height[i],l_dp[i-1]) 
    //从右到左遍历[i...end ]，求右边每个位置i的最高高度，r_dp[i] = max(height[i],r_dp[i+1])

    l_dp := make([]int,len(height)) // 从[0..i],求当前位置i，柱子的最高高度
    l_dp[0] = height[0]
    for i := 1;i < len(height);i++ {
        l_dp[i] = max(height[i],l_dp[i-1]) // l_dp[i-1]前一个柱子的最高高度
    }

    r_dp := make([]int,len(height)) //从 [i...end]，求当前位置i，柱子的最高高度
    r_dp[len(height)-1] = height[len(height)-1]

    for i := len(height)-2;i >= 0;i-- {
        r_dp[i] = max(height[i],r_dp[i+1])
    }

    result := 0
    for i := 0;i < len(height);i++ {
        result += min(l_dp[i],r_dp[i]) - height[i] //左边的最高高度 和 右边的最高高度，取最小值，减去当前的高度，表示当前位置可以保存到水量
    }
    return result
}

func min( a,b int) int{
    if a < b {
        return a
    }
    return b
}

func max( a,b int) int{
    if a > b {
        return a
    }
    return b
}
```



## 142.环形链表

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



![image-20241219165654244](./images/image-20241219165654244.png)

思路：

我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

因为 `fast` 一次跳跃距离为`2` ，`slow` 一次跳跃距离为 `1`

![image-20241219171135336](./images/image-20241219171135336.png)

假设【相遇点】距环【相交点】的距离为 `m`，那么结合下图的 `slow` 指针，环的【相交点】距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从【相遇点】继续前进 `k - m` 步，也恰好到达环【相交点】：

![image-20241219172001832](./images/image-20241219172001832.png)

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
   
    //1.判断是否有环
    fast,slow := head,head
    for fast != nil && fast.Next != nil {
        
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            break
        }
    }
    //2.说明没有环
    if fast == nil || fast.Next == nil {
        return nil
    }

    //3.说明有环，需要找到环的起始位置
    slow = head
    for slow != fast {
        fast = fast.Next
        slow = slow.Next
    }

    return slow

}
```



## 124. 二叉树中的最大路经和

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

思路：

- 【从root为起点的最大路径】

这题在于递归函数的定义：`func oneSideMax(root *TreeNode) int `：从`root`为起点的最大路径和

不管`root.Val`是正还是负，从`root`节点出发（初始值`root.Val`），如果左节点`leftMax`是负值，只会使路经和值更小，也就是`left `不能作为路经 ；如果右节点`rightMax`是正数，可以使从`root`为起点的最大路径和变的更大，因此`right`可以作为路径

换句话说：从`root`出发的路经和，就是在`root.Val`值的基础上，上调或不变，如果`leftMax`为负值，那就是下调。不可能作为从`root`出发的最大路径。

![image-20241219183656494](./images/image-20241219183656494.png)

-   但是题目要求的是：【经过root】的最大路径和，注意和上面的区别，一个是从 root出发，题目要求的是经过 root 。

![image-20241219184958506](./images/image-20241219184958506.png)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var result int = math.MinInt
// 【从root为起点的最大路径】 与  【经过root的最大路径和，是两种不同的含义】需要体会下
func maxPathSum(root *TreeNode) int {

    result = math.MinInt
    if root == nil {
        return 0
    }
    oneSideMax(root)
    return result
}

// oneSideMax 函数定义：从root为起点的最大路径和
func oneSideMax(root *TreeNode) int {
    if root == nil {
        return 0
    }
  
    //这点比较绕
    leftMax := max(0,oneSideMax(root.Left)) //oneSideMax(root.Left)以root.Left为起点的最大路径和，结果可能是【正】或【负】，负数舍弃
    rightMax := max(0,oneSideMax(root.Right))
  
    

  // 经过root的最大路径和（从 left节点出发的最大路经和leftMax + 从 right节点出发的最大路经和 rightMax + 当前的值 root.Val )
    result = max(result,root.Val+leftMax+rightMax) 
		
 		 // 从root出发的最大路径和
    return max(leftMax,rightMax)+root.Val 
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```



## 72. 编辑距离

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

思路：

解决两个字符串的动态规划问题，一般都是用两个指针 `i, j` 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模。

对于每对字符 `s1[i]` 和 `s2[j]`，可以有四种操作：

```
if s1[i] == s2[j]:
    啥都别做（skip）
    i, j 同时向前移动
else:
    三选一：
        插入（insert）
        删除（delete）
        替换（replace）
```

- `dp`数组定义： `i`和`j`表示字符串长度，`dp[i][j]`表示最小操作数

- 递推关系： `i`和`j`表示字符串长度， `i-1` 和 `j-1`才表示最后一个字符的索引

  ```go
  if word1[i-1] == word2[j-1] {
  	dp[i][j] = dp[i-1][j-1] //不需要操作
  } else {
    dp[i-1][j] // i删除 j不变
    dp[i][j-1] // i不变，在i后面新增一个元素和j相同(也可以理解为 i不变，删除j)
    dp[i-1][j-1] // i和j同时replace为同一个元素
    
    dp[i][j] = min( dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1 )
  }
  ```

代码实现：

```go
func minDistance(word1 string, word2 string) int {
    
    m,n := len(word1),len(word2)
  	// 1.定义 dp数组
    dp := make([][]int,m+1)
    for k,_ := range dp {
        dp[k] = make([]int,n+1)
    }
  	// 2. 初始化 base case
    for i := 0;i <= m;i++ { // word2 字符串为空
        dp[i][0] = i // 需要的操作次数，新增i次元素
    }
    for j := 0;j<=n;j++ { // word1 字符串为空
        dp[0][j] = j // 需要的操作次数，新增j次元素
    }
		
  	//3. 一般递推关系
    for i := 1;i<=m;i++ {
        for j := 1;j<=n;j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1)
            }
        }
    }
    return dp[m][n]
}

func min(a,b int)int{
    if a < b {
        return a
    }
    return b
}
```



## 93.复原IP地址

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

思路：

- `for`循环每完成一组`[start,i]`数字的截取，剩下的字符串留给下一个递归函数截取

![image-20241220182843938](./images/image-20241220182843938.png)

```go

var result []string
func restoreIpAddresses(s string) []string {

    trace := []string{} //记录每个分段
  	
    result = []string{}
    backtrack(s,0,trace)
    return result
}

func backtrack(s string , start int ,trace []string) {
  	// 终止条件
		// 整个字符串s需要正好被完整分割
    if start == len(s) && len(trace) == 4 {
        result = append(result,strings.Join(trace,".")) // 分割程4个部分，拼接成 ip地址的格式
        return
    }

    if len(trace) >= 4 { // 到start位置，如果已经拆分超过了4段，[start,...]后面的位置没必要继续拆分了
        return 
    }

    for i := start;i < len(s);i++ {

        if !isVaild(s,start,i) { // 判断 [start,i] 是否是有效的字符串
            continue // 继续扩大i
        }

        // 选择 [start,i]
        trace = append(trace,s[start:i+1])
        backtrack(s,i+1,trace) // 继续下一个片段的截取
				// 撤销选择
        trace = trace[:len(trace)-1]
    }
}

func isVaild(s string, start ,end int) bool {
    //1.长度只能是1-3之间
    length := end - start+1

    if length > 3|| length == 0 {
        return false
    }
    //2.长度大于1的话，如果前缀出现字符0，是不正确
    if length > 1 &&  s[start] == '0' { 
        return false
    }

    //3. 判断是否在 255 范围内
    val ,_ := strconv.Atoi(s[start:end+1])
    if val > 255 {
        return false
    }
    return true
}
```



## 19.删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

![image-20241220190322910](./images/image-20241220190322910.png)

思路：

要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的引用。

- 第一步，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

![image-20241220185846249](./images/image-20241220185846249.png)

- 第二步，用一个指针 `p2` 指向链表头节点 `head`：

![image-20241220190032419](./images/image-20241220190032419.png)

- 第三步，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时走了 `n - k` 步，`p2` 也走了 `n - k` 步，也就是链表的倒数第 `k` 个节点：

![image-20241220190217013](./images/image-20241220190217013.png)

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

解法中在链表头部接一个虚拟节点 `dummy` 是为了避免删除倒数第一个元素时出现空指针异常，在头部加入 `dummy` 节点并不影响尾部倒数第 `k` 个元素是什么。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    //需要额外加一个虚拟节点
    dummy := &ListNode{Val:0}
    dummy.Next = head

    //查找倒数第N个节点（这里是找n+1节点）
    node := findN(dummy,n+1) 
  	// 删除 n 节点
    node.Next = node.Next.Next
    return dummy.Next
}


func findN(head *ListNode,n int) *ListNode {
  	// a b 都指向链表头部
    a,b := head,head
  	// a 先移动
    for i := 0;i<n;i++{
        a = a.Next
    }
	
    for a != nil {
        a = a.Next //a 到达尾部
        b = b.Next //b 指向的就是第n个节点
    }
    return b
}
```

