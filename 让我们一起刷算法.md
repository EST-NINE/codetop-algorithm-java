---
typora-copy-images-to: ./images
---



[TOC]

# 前言

学习新知识的核心就在于 **重复 + 重复 + 重复**

本人也是从一无所知开始尝试刷算法，中间断断续续痛苦/纠结/无能狂怒。第1次的时候，整人是蒙圈的，看着别人的标准答案慢慢的摸索算法的含义，那真是一支笔一杯茶，一道力扣刷一天。当重复到第5次的时候，开始有些感觉了，看到题目的标题，就可以立刻回想到题目的大概的解题方向，但是很多细节还是脑袋一团浆糊，那就继续重复，当到了第8次的时候，突然就觉得就是这样的，很容易记住呀，不过如此呀。

刷题（本质就是背诵）我们的目的就是要去面试，所以题目尽可能的要选择命中率高的题库去刷，而不是力扣的题目从第一题开始，意义不大。当背诵了300道题目以后，去面试的时候，只要考算法题目，我其实很兴奋的（因为背的很熟悉），刷过的题目的命中率还挺高的。

大家不要把算法题想象的过于高大上，既然是题目，那就是有答案和解题套路的。背诵答案 + 总结解题套路，同类型的题目即使你题目都看的懵懵懂懂，都有可能蒙出来。

本文章题目都是来源于 https://codetop.cc/home  里面考察频度高的题目，都是面试后人工标记出来的（面试命中率高）。我写这个文章的目的，就是提供一份参考答案，包括代码每行的含义，以及通用的套路。因为一旦理解了，按照自己的方式去记忆会容易很多。
只需要用这个网站作为题目**是否做过**的标记即可（因为笔记功能要收费），自己的答案直接保存在力扣官方刷题网站上

![](./images/20241212172641.png)

这里还有一份适合小白的算法书  https://www.hello-algo.com/  在Github上还挺火的。我个人觉得也可拿来扫下盲，或者刷题遇到理解上的困难可以拿来看看。

![](./images/20241212172245.png)

# 解题套路

解题套路可以先简单看下，当遇到相关的题目，可以回来再细细品味

## 滑动窗口解题套路

- 定义 `left right := 0,0` 指向起始位置 `0`
- 让 `right`不断的右移，当遇到不符合题意的条件`condition`，停止移动 `right`
- 然后开始让`left`不断右移，直到条件`condition`得到满足，继续重复👆的步骤，右移`right`
- 当 `right`越界，全部结束

动态规划套路伪代码

```go
nums := []int{1,2,3,4,5,6}
func main() {
  
  //1. 定义 `left right := 0,0` 指向起始位置 `0`
  left, right := 0,0
  
  // right 越界结束
  for right < len(nums) {
    
    // 2.不断移动 right
    val := nums[right]
    right++ 
    
    // do something.....
    
    // 3.当 condition 不符合题意的时候，移动 left，直到满足题意，跳出 condition
    for  condition {
      val := nums[left]
      left++
    }
    
    //.......
  }
}
```

滑动窗口解题套路主要流程是包括

- `left right`的定义 
-  `condition`条件的选取（这个要结合题意）
- 以及两个`for`循环

# CodeTop参考答案

## 3.无重复字符的最长字串 （滑动窗口）

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度

```
示例1
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

思路：

- 理解**子串**的含义：**子字符串** **是字符串中连续的** **非空** **字符序列。** 比如：`abc`的字串 `abc ab bc`等，但是 `ac`就不是字串，因为`a`和`c`并不连续，中间间隔了`b`
- 滑动窗口：保证 `left right`之间的字符没有重复出现。用`win`记录字符出现的次数，当`conditon`为 `win`中当某个字符出现次数 `>1`，保持 `right`不变，移动 `left`直至条件重新成立。

```go
func lengthOfLongestSubstring(s string) int {
    //滑动窗口【左右边界】
    left,right := 0,0

    // 记录窗口中字符出现的次数
    win := make(map[byte]int)

    result := 0
		
  	// 匿名函数，求最大值
    max := func (a ,b int) int {
        if a > b {
            return a
        }
        return b
    }
  
  	
    for right < len(s) {
				// 移动右边界+1
        ch := s[right] 
        right++ 
      	// 窗口中字符出现的次数+1
        win[ch]++
      	
	
        for win[ch] > 1 { //当字符出现的次数多于1次，说明滑动窗口中存在重复字符，不符合题意；需要移动左边界，把重复字符删掉，保证滑动窗口的字符数量都是1个，满足题意
            d := s[left]
            left++
            win[d]--
        }

        // 当前窗口中的字符数量
        result = max(result,right-left)
    }
    return result
}

```



## 146. LRU缓存

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

思路：

- LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的[页面置换算法](https://baike.baidu.com/item/页面置换算法/7626091?fromModule=lemma_inlink)，选择最近最久未使用的页面予以淘汰。该算法赋予每个[页面](https://baike.baidu.com/item/页面/5544813?fromModule=lemma_inlink)一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。（也就是当需要淘汰数据的时候，选择最久没有被使用的数据淘汰，刚刚使用的数据不要淘汰）
- 记忆点：两个数据结构 `map +  list `， `map`用于快速的判断`key`是否存在并获取到值，`list`用于记录【刚被访问】和【很久没访问】的数组，当需要淘汰数据的时候，直接从链表尾部淘汰即可。

```go
type LRUCache struct {
  	m map[int]*list.Element // 为了满足，题目要求的 o(1)的平均时间复杂度
    l *list.List // 链表：【刚被访问】数据在链表头部，【很久没访问】数据在链表尾部（当需要淘汰时，尾部的数据直接删除）
    cap int // 容量
}


type Data struct {
    Key int
    Value int
}

// 构造 LRUCache 对象
func Constructor(capacity int) LRUCache {
    cache := LRUCache{}
    cache.m = make(map[int]*list.Element,capacity)
    cache.l = list.New()
    cache.cap = capacity
    return cache
}

// Get 获取
func (this *LRUCache) Get(key int) int {
  	// 存在
    if v,ok := this.m[key];ok { 
      	//移动到头部（因为刚被访问了）
        this.l.MoveToFront(v)
      	//返回当前值
        return v.Value.(Data).Value
    }
  	// 不存在直接返回 -1
    return -1
}


// Put 修改
func (this *LRUCache) Put(key int, value int)  {
  	// 不存在
    if v,ok := this.m[key];!ok {
      	// 容量已经满了～～
        if this.cap == this.l.Len() { 
          	// 删除最久没访问的（也就是链表尾部元素）
            data := this.l.Remove(this.l.Back())
          	// 同时 map 中也要删除
            delete(this.m,data.(Data).Key) 
        }
        //新增（刚被访问过）
        e := this.l.PushFront(Data{key,value})
        this.m[key] = e

    }else { // 存在
      	// 修改数值
        v.Value = Data{key,value} 
      	// 同时移动到头部（刚被访问过）
        this.l.MoveToFront(v)
    }
}
```



## 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![image-20241214163002911](./images/image-20241214163002911.png)

思路：

- **对于递归算法，最重要的就是明确递归函数的定义**。具体来说，我们的 `reverseList` 函数定义是这样的：**输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的【头结点】**。

```go
// 递归算法 reverseList 函数的定义：将「以 head 为起点」的链表反转，并返回反转之后的【头结点】
func reverseList(head *ListNode) *ListNode {
  	// 当没有节点 or 只有一个节点的时候，直接返回head
    if head == nil || head.Next == nil {
        return head
    }
		
  	// 这里表示：将「以 head.Next 为起点」的链表反转，并返回反转之后的【头结点】
    last := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return res
}
```

![image-20241214165538983](./images/image-20241214165538983.png)

- 对于**迭代算法**，我们只需要定义一个前驱节点 `pre`，每次用当前节点`cur`替换 前驱节点`pre`

```go
func reverseList(head *ListNode) *ListNode {
  	// 前驱节点 pre
    var pre *ListNode = nil
    
    for head != nil {

        temp := head.Next // 临时保存后缀节点

        head.Next = pre //将head.Next 指向pre
        pre = head //  head 变成新的前驱节点pre

        head = temp // 继续下一个节点
    }
    return pre
}
```





## 215. 数组中的第K个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第  `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```
示例 1:

输入: [3,2,1,5,6,4], k = 2
输出: 5

```

思路