---
typora-copy-images-to: ./images
---



[TOC]

# 前言

> 多学一分钟，女友都不同，把障碍变成机会，把问题变成可能。

学习新知识的核心就在于 **重复 + 重复 + 重复**

本人也是从一无所知开始尝试刷算法，中间断断续续痛苦/纠结/无能狂怒。第1次的时候，整人是蒙圈的，看着别人的标准答案慢慢的摸索算法的含义，那真是一支笔一杯茶，一道力扣刷一天。当重复到第5次的时候，开始有些感觉了，看到题目的标题，就可以立刻回想到题目的大概的解题方向，但是很多细节还是脑袋一团浆糊，那就继续重复，当到了第8次的时候，突然就觉得就是这样的，很容易记住呀，不过如此呀。

刷题（本质就是背诵）我们的目的就是要去面试，所以题目尽可能的要选择命中率高的题库去刷，而不是力扣的题目从第一题开始，意义不大。当背诵了300道题目以后，去面试的时候，只要考算法题目，我其实很兴奋的（因为背的很熟悉），刷过的题目的命中率还挺高的。

大家不要把算法题想象的过于高大上，既然是题目，那就是有答案和解题套路的。背诵答案 + 总结解题套路，同类型的题目即使你题目都看的懵懵懂懂，都有可能蒙出来。

本文章题目都是来源于 https://codetop.cc/home  里面考察频度高的题目，都是面试后人工标记出来的（面试命中率高）。我写这个文章的目的，就是提供一份参考答案，包括代码每行的含义，以及通用的套路。因为一旦理解了，按照自己的方式去记忆会容易很多。
只需要用这个网站作为题目**是否做过**的标记即可（因为笔记功能要收费），自己的答案直接保存在力扣官方刷题网站上

![](./images/20241212172641.png)

这里还有一份适合小白的算法书  https://www.hello-algo.com/  在Github上还挺火的。我个人觉得也可拿来扫下盲，或者刷题遇到理解上的困难可以拿来看看。

![](./images/20241212172245.png)

# 解题套路

解题套路可以先简单看下，当遇到相关的题目，可以回来再细细品味。建议还是先直接刷题。

## 二分搜索算法

在有序数组`nuns`中搜索 `target` 并返回索引，如果没有搜索到返回`-1`。

![image-20241231181002616](./images/image-20241231181002616.png)

比如我们要搜索 `target = 4`此时`left = 0 right = 5` 计算得到的`mid = 2`

由图可知，`target > nums[2]`位于索引`mid=2`的右侧位置，说明`[1,2,3]`数据没有再搜索的必要（相当于切掉了一半的搜索数据量），只需要继续搜索 `[mid+1:right]`范围内的数据即可。也就是让 `left = mid+1`即 `left= 3 right = 5`，继续进行搜索的过程，直到找到数据或越界。

二分搜索算法的好处，在于每一次`for`循环搜索，可以剔除一半的数据量，让算法更快的趋近于目标值。

一般题目要求算法的时间复杂度`O(log2)`就要想到二分搜索算法

```go
func search(nums []int,target int) int{
  
  left,right := 0,len(nums)-1
  
  for left <= right {
    
    mid := left +(right-left)/2
    if nums[mid] == target{ // 找 target ，返回索引mid
      return mid
    } else if target < nums[mid] { // 说明 target位于 索引mid的左侧，收缩 right
      right = mid -1
    } else { // 说明 target位于 索引mid的右侧，收缩 left
      left = mid + 1
    }
  }
  // 没找到
  return -1
}
```



## 二叉树遍历套路

```go
// 前序遍历套路
func preOrder(root *TreeNode){
  if root == nil {
    return
  }
  
  fmt.Println(root.Val)
  
  preOrder(root.Left)
  preOrder(root.Right)
} 

// 中序遍历套路
func preOrder(root *TreeNode){
  if root == nil {
    return
  }
 
  preOrder(root.Left)
  fmt.Println(root.Val)
  preOrder(root.Right)
}

// 后序遍历套路
func preOrder(root *TreeNode){
  if root == nil {
    return
  }
  
  preOrder(root.Left)
  preOrder(root.Right)
  fmt.Println(root.Val)
  
}
```



## 滑动窗口解题套路

- 定义 `left right := 0,0` 指向起始位置 `0`
- 让 `right`不断的右移，当遇到不符合题意的条件`condition`，停止移动 `right`
- 然后开始让`left`不断右移，直到条件`condition`得到满足，继续重复👆的步骤，右移`right`
- 当 `right`越界，全部结束

动态规划套路伪代码

```go
nums := []int{1,2,3,4,5,6}
func main() {
  
  //1. 定义 `left right := 0,0` 指向起始位置 `0`
  left, right := 0,0
  
  // right 越界结束
  for right < len(nums) {
    
    // 2.不断移动 right
    val := nums[right]
    right++ 
    
    // do something.....
    
    // 3.当 condition 不符合题意的时候，移动 left，直到满足题意，跳出 condition
    for  condition {
      val := nums[left]
      left++
    }
    
    //.......
  }
}
```

滑动窗口解题套路主要流程是包括

- `left right`的定义 
-  `condition`条件的选取（这个要结合题意）
- 以及两个`for`循环



## 动态规划解题套路

动态规划难点就是在于递推关系的发现，这个只能从具体的题目中来感受。如果说理解+ 背诵题目的话，其实动态规划的题目又是最容易记忆和理解的

- 明确`dp`数组的定义
- 明确 `dp[i]`和 `dp[i-1]`之间递推关系的定义(这个是动态规划的难点，其实说白了，就是要根据题意，找`dp[i]`和 `dp[i-1]`的关系 )，形式上看起来和高中学过的函数推到关系是一摸一样的，比如 `f(x) = f(x-1) + f(x-2)`

在实现代码的时候包括三个方面：

- 创建`dp`数组
- 初始化`dp`数组（需要特殊处理的值）
- 遍历 `nums`数组，实现一般性的递推关系

伪代码

```go
func main() {
  nums := []int{1,2,3,4}
  
  //1.定义 dp 数组
  
  dp := make([]int,len(nums))
  
  //2. 初始化 dp 数组（根据题目要求也可能不需要这一步骤）
  
  for k := range dp {
    dp[k] = 1
  }
  
  //3. 遍历 `nums`数组，实现一般性的递推关系
  
  for i := 0;i < len(nums);i++ {
    dp[i] = dp[i-1] + 1 // 比如：这里的递推关系为：前一个的 dp[i-1]的基础上，加1
  }
  
  //......
}
```

有一道动态规划最简单的入门题目 斐波那契数  https://leetcode.cn/problems/fei-bo-na-qi-shu-lie-lcof/ 可以来体会下上面说的套路

LCR 126. 斐波那契数

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 **0** 和 **1** 开始，后面的每一项数字都是前面两项数字的和。也就是：

> F(0) = 0
>
> F(1) = 1
>
> F(n) = F(n - 1) + F(n - 2)，其中 n > 1

给定 `n` ，请计算 `F(n)` 。答案需要取模 1e9+7(1000000007) ，如计算初始结果为：1000000008，请返回 1。

思路：

- `dp`定义： 在 `i`位置的数字和 `dp[i]`
- `dp`递推关系：每一项数字都是前面两项数字的和，所以有 `dp[i] = dp[i-1] + dp[i-2]`

其实，题目已经直接给出了 递推关系 `F(n) = F(n-1)+F(n-2)`，但是大部分的题目是不会给出，需要我们结合题目自己是思考这个递推关系。

```go
func fib(n int) int {
    
  	//1. 定义 dp 数组
    dp := make([]int,n+1)
  	
    for i := 0; i <= n;i++ {
      	// 2. 初始化 （需要特殊处理的值）
        if i == 0 {
            dp[i] = 0
        } else if i == 1 { // 2. 初始化 （需要特殊处理的值）
            dp[i] = 1
        } else{
          	// 3. 递推关系 实现
             dp[i] = (dp[i-1] + dp[i-2]) % 1000000007 // 这个是题目要求【取模】
        }
    }
  	// 4. 返回 F(n) 的结果，即 dp[n]
    return dp[n]    
}
```



## 回溯算法代码套路

- 回溯算法：每一层选择一个元素，剩下的元素留给下一层选择，一层一层的进行选择，直到将所有的情况遍历完成

打个比方：

有 A B  C 三个苹果，有小明和小王 2个同学，各选择一个苹果。

如果小明先选择 A 苹果，那么小王只能选择B 或者 C 苹果；

如果小明选择 B 苹果，那么小王只能选择 A 或者 C 苹果；

如果小明选择 C 苹果，那么小王只能选择 A 或者 B 苹果。

可以看到，小明在选中一个苹果后，小王只能在剩下的苹果中选择一个留给自己（因为另一个已经被小明占用了）

回溯算法，就是在穷尽所有的情况，在 `backtrack`的 `for`循环中选中一个元素，剩下的的元素（通过 `start`来圈定）就留给 下一个 `backtrack`函数进行选择。

`start`不是必须的，有些题目可能需要在全部里面选择（比如，小明先选择 A 苹果，那么小王可以 选择A 或者 B 或者 C 苹果），有些需要在 `start`圈定的范围内选择（小明先选择 A 苹果，那么小王只能选择B 或者 C 苹果）

伪代码

```go
/*
nums  数组
start 遍历数组的起始位置（这个要根据题意，有时不需要）
trace 记录回溯的结果
*/
func backtrack(nums []int , start int, trace []int) {
  
  // 结束条件
  if condition {
    return
  }
  
  for i := start;i < len(nums);i++ {
    
    // 当前选择
    trace = append(trace,nums[i])
    
    // 继续下一轮的回溯
    backtrack(nums,i+1,trace)
    
    // 撤销当前选择
    trace = trace[:len(trace)-1]
  }
}
```

`start`用来限定每次 `backtrace`函数，能选择的元素范围

`trace = append(trace,nums[i])`在当前层选中元素`nums[i]`，剩下的元素留给下层的回溯`backtrack`选择

![image-20241217163642574](./images/image-20241217163642574.png)

这里举例一个题目：

在数组`nums=[1,2]`中找出满足元素之和为`target=3`的【排列】，元素不能重复使用。

直接肉眼看，可知：包括 `[1,2] [2,1]` 两个结果

通用的代码模板如下：

```go
// 判断元素是否重复使用
var used []int = make([]int,len(nums))

func backtrack(nums []int, target int, trace []int){
    
    for i := 0; i < len(nums);i++ {

        // 判断当前nums[i]是否可以选择（因为元素不能重复使用）
        if userd[i] {
            continue
        }        

        // 选择
        trace = append(trace,nums[i])
        used[i] = true

        // 表示当前元素nums[i]选择以后，下一层调用 backtrack时，for循环选择的范围依然是[0:len(nums)-1]
        backtrack(nums,target,trace)


        //撤销
        trace = trace[:len(trace)-1]
        used[i] = false
    }
}
```

在数组`nums=[1,2]`中找出满足元素之和为`target=3`的【组合】，元素不能重复使用。

直接肉眼看，可知：包括 `[1,2]` 一个结果

通用的代码模板如下：

```go

func backtrack(nums []int,start, target int, trace []int){
    
    for i := start; i < len(nums);i++ {

        // 选择
        trace = append(trace,nums[i])
        
        // 表示当前元素nums[i]选择以后，下一层调用 backtrack时，for循环选择的范围变成了[i+1:len(nums)-1]
        backtrack(nums,i+1,target,trace)


        //撤销
        trace = trace[:len(trace)-1]
    }
}
```

体会下带 `start`和不带 `start`的区别；在体会下元素不能重复的时候区别。

# CodeTop参考答案



## 3.无重复字符的最长字串 （滑动窗口）

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长 子串** 的长度

```
示例1
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

思路：

- 理解**子串**的含义：**子字符串** **是字符串中连续的** **非空** **字符序列。** 比如：`abc`的字串 `abc ab bc`等，但是 `ac`就不是字串，因为`a`和`c`并不连续，中间间隔了`b`
- 滑动窗口：保证 `left right`之间的字符没有重复出现。用`win`记录字符出现的次数，当`conditon`为 `win`中当某个字符出现次数 `>1`，保持 `right`不变，移动 `left`直至条件重新成立。

```go
func lengthOfLongestSubstring(s string) int {
    //滑动窗口【左右边界】
    left,right := 0,0

    // 记录窗口中字符出现的次数
    win := make(map[byte]int)

    result := 0
		
  	// 匿名函数，求最大值
    max := func (a ,b int) int {
        if a > b {
            return a
        }
        return b
    }
  
  	
    for right < len(s) {
				// 移动右边界+1
        ch := s[right] 
        right++ 
      	// 窗口中字符出现的次数+1
        win[ch]++
      	
	
        for win[ch] > 1 { //当字符出现的次数多于1次，说明滑动窗口中存在重复字符，不符合题意；需要移动左边界，把重复字符删掉，保证滑动窗口的字符数量都是1个，满足题意
            d := s[left]
            left++
            win[d]--
        }

        // 当前窗口中的字符数量
        result = max(result,right-left)
    }
    return result
}

```



## 146. LRU缓存

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

思路：

- LRU是Least Recently Used的缩写，即最近最少使用，是一种常用的[页面置换算法](https://baike.baidu.com/item/页面置换算法/7626091?fromModule=lemma_inlink)，选择最近最久未使用的页面予以淘汰。该算法赋予每个[页面](https://baike.baidu.com/item/页面/5544813?fromModule=lemma_inlink)一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 t，当须淘汰一个页面时，选择现有页面中其 t 值最大的，即最近最少使用的页面予以淘汰。（也就是当需要淘汰数据的时候，选择最久没有被使用的数据淘汰，刚刚使用的数据不要淘汰）
- 记忆点：两个数据结构 `map +  list `， `map`用于快速的判断`key`是否存在并获取到值，`list`用于记录【刚被访问】和【很久没访问】的数组，当需要淘汰数据的时候，直接从链表尾部淘汰即可。

```go
type LRUCache struct {
  	m map[int]*list.Element // 为了满足，题目要求的 o(1)的平均时间复杂度
    l *list.List // 链表：【刚被访问】数据在链表头部，【很久没访问】数据在链表尾部（当需要淘汰时，尾部的数据直接删除）
    cap int // 容量
}


type Data struct {
    Key int
    Value int
}

// 构造 LRUCache 对象
func Constructor(capacity int) LRUCache {
    cache := LRUCache{}
    cache.m = make(map[int]*list.Element,capacity)
    cache.l = list.New()
    cache.cap = capacity
    return cache
}

// Get 获取
func (this *LRUCache) Get(key int) int {
  	// 存在
    if v,ok := this.m[key];ok { 
      	//移动到头部（因为刚被访问了）
        this.l.MoveToFront(v)
      	//返回当前值
        return v.Value.(Data).Value
    }
  	// 不存在直接返回 -1
    return -1
}


// Put 修改
func (this *LRUCache) Put(key int, value int)  {
  	// 不存在
    if v,ok := this.m[key];!ok {
      	// 容量已经满了～～
        if this.cap == this.l.Len() { 
          	// 删除最久没访问的（也就是链表尾部元素）
            data := this.l.Remove(this.l.Back())
          	// 同时 map 中也要删除
            delete(this.m,data.(Data).Key) 
        }
        //新增（刚被访问过）
        e := this.l.PushFront(Data{key,value})
        this.m[key] = e

    }else { // 存在
      	// 修改数值
        v.Value = Data{key,value} 
      	// 同时移动到头部（刚被访问过）
        this.l.MoveToFront(v)
    }
}
```



## 206. 反转链表

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![image-20241214163002911](./images/image-20241214163002911.png)

思路：

- **对于递归算法，最重要的就是明确递归函数的定义**。具体来说，我们的 `reverseList` 函数定义是这样的：**输入一个节点 `head`，将「以 `head` 为起点」的链表反转，并返回反转之后的【头结点】**。

```go
// 递归算法 reverseList 函数的定义：将「以 head 为起点」的链表反转，并返回反转之后的【头结点】
func reverseList(head *ListNode) *ListNode {
  	// 当没有节点 or 只有一个节点的时候，直接返回head
    if head == nil || head.Next == nil {
        return head
    }
		
  	// 这里表示：将「以 head.Next 为起点」的链表反转，并返回反转之后的【头结点】
    last := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return res
}
```

![image-20241214165538983](./images/image-20241214165538983.png)

- 对于**迭代算法**，我们只需要定义一个前驱节点 `pre`，每次用当前节点`cur`替换 前驱节点`pre`

```go
func reverseList(head *ListNode) *ListNode {
  	// 前驱节点 pre
    var pre *ListNode = nil
    
    for head != nil {

        temp := head.Next // 临时保存后缀节点

        head.Next = pre //将head.Next 指向pre
        pre = head //  head 变成新的前驱节点pre

        head = temp // 继续下一个节点
    }
    return pre
}
```



## 215. 数组中的第K个最大元素

给定整数数组 `nums` 和整数 `k`，请返回数组中第  `k` 个最大的元素。请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

```
示例 1:

输入: [3,2,1,5,6,4], k = 2
输出: 5

```

思路:

- 第一种解法：利用**快速排序**算法，找到第 `k`个最大的元素

```go
func findKthLargest(nums []int, k int) int {

    //求第k大的元素，假如数组按照正序已经排列好了，那么第k大元素的索引位置为：len(nums)-k

    targetIndex := len(nums) - k

    lo,hi := 0,len(nums)-1

    for {
      	// 先确定某一个元素的索引位置
        idx := quickSort(nums,lo,hi) 
      	// 如果索引位置和 预期的targetIndex相同，说明找到了该元素
        if targetIndex == idx {
            return nums[idx]
        } else if targetIndex < idx { // 想找的元素索引位于左边，收缩 hi
            hi = idx-1
        } else { // 想找的元素索引位于右边，收缩 lo
            lo = idx+1
        }
    }

    return 0
}

// quickSort 快速排序，找一个参照元素v，使左边的元素都小于v，右边的元素都大于等于v，从而确定v在数组中的存储索引位置
func quickSort(nums []int ,lo,hi int) int {
    
    v := nums[lo] // 参照元素值

    left := lo+1
    right := hi
  	
  	// 保证 left <= right 的前提下
    for left <= right {
      	
      	// 让left指向的元素都要比v小
        for left <= right && v > nums[left] { 
            left++
        }
				// 让right指向的元素都要比v大or相等
        for left <= right && v <= nums[right] { 
            right--
        }
      	
        if left > right {
            break
        }

        // 执行到这里，说明left和right的元素不满足 nums[left] < v <= nums[right] 即left小right大的规则，交换left和right，重新满足条件
        nums[left],nums[right] = nums[right],nums[left]
    }

    // 最后交换 lo和right 例如 2 13，执行到这里，left指向 3 right指向 1，最后需要交换1和2的位置
    nums[lo],nums[right] = nums[right],nums[lo]
    return right
}
```

![image-20241214180009540](./images/image-20241214180009540.png)

- 第二个种解法：利用**小根堆**，保持堆中元素的数量最多 K 个。当超过 K 个元素，弹出堆顶元素，遍历数组中的所有元素，并经过 小根堆的过滤。当所有元素遍历完成后，堆顶元素就是第K大的元素

```go
// 利用小根堆，堆大小设定为k。遍历数组，将元素直接保存到堆中；保证的堆大小维持在 <=k
// 当所有的元素经过堆以后，最后堆堆顶元素就是结果
type MinHeap struct {
    data []int
}

func (m *MinHeap)Swap(i,j int) {
    m.data[i],m.data[j] = m.data[j],m.data[i]
}

func(m *MinHeap)Len() int {
    return len(m.data)
}

func (m *MinHeap)Less(i,j int) bool {
    return m.data[i] < m.data[j]
}

func (m *MinHeap)Push(x any) {
    m.data = append(m.data,x.(int))
}

func (m *MinHeap)Pop() any {
    x := m.data[len(m.data)-1]
    m.data = m.data[:len(m.data)-1]
    return x
}

func (m *MinHeap)Top() int {
    return m.data[0]
}

func findKthLargest(nums []int, k int) int {
    minH := &MinHeap{}
    heap.Init(minH)
  	// 遍历数组
    for _ , num := range nums {
      	// 保存到小根堆中
        heap.Push(minH,num)
      	// 当元素个数超过 k
        for minH.Len() > k {
            heap.Pop(minH) // 删除堆顶元素
        }
    }
    return minH.Top() // 最终结果，就是小根堆的堆顶元素值
}
```

下图表示演示了， 数组 `2 1 3` 求第 1 大元素的过程

![image-20241214183809449](./images/image-20241214183809449.png)



## 25. K个一组翻转链表

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

思路：

- 按照 长度k截取一段链表，然后将这段链表进行反转。【反转前的链表的头节点，变成了反转后的链表的尾部节点】
- 继续对后续的链表递归调用 `reverseKGroup(head *ListNode, k int) *ListNode`，并且进行拼接

![image-20241215164514723](./images/image-20241215164514723.png)

```go
// reverseKGroup 函数定义： 按照k个一组，反转从 head 开始的链表，并返回反转后的链表的头节点
func reverseKGroup(head *ListNode, k int) *ListNode {
    a,b := head,head
    //截取一个长度为k的链表
    for i :=0;i < k;i++{
      	// 说明不够k个一组，那就不需要反转
        if b == nil { 
            return head
        }
        b = b.Next
    }
  
  	//翻转链表 [a,b) 注意不包括节点b
    last := reverse(a,b)
  	// 对 [a,b) 进行反转以后，此时的节点 a，就是反转后的链表的最后一个尾部节点（因为：一开始a是第一个头节点）
    a.Next = reverseKGroup(b,k)
    return last
}

//翻转指定范围 [a,b)链表,返回头节点
func reverse(a,b *ListNode) *ListNode {
    var pre *ListNode = nil
    for a != b {
        temp := a.Next

        a.Next = pre
        pre = a
        a = temp
    }
    return pre
}
```



## 15. 三数之和

给你一个整数数组 `nums` ，判断是否存在三元组 `[nums[i], nums[j], nums[k]]` 满足 `i != j`、`i != k` 且 `j != k` ，同时还满足 `nums[i] + nums[j] + nums[k] == 0` 。请你返回所有和为 `0` 且不重复的三元组。

**注意：**答案中不可以包含重复的三元组。

思路：

- 先给数组从小到大排序，然后双指针 `left` 和 `right` 分别在数组开头和结尾，这样就可以控制 `nums[left]` 和 `nums[right]` 这两数之和的大小：
- 如果你想让它俩的和大一些，就让 `left++`，如果你想让它俩的和小一些，就让 `right--`
- 基于两数之和可以得到一个万能函数 `nSumTarget`，扩展出 n 数之和的一般解法

![image-20241215171006692](./images/image-20241215171006692.png)

```go
func threeSum(nums []int) [][]int {
  	//1. 对数组进行排序
    sort.Ints(nums)
    return nSumTarget(nums,3,0,0)
}

// nums: 数组
// n： n数之和
// start： 数组遍历的边界
// target：目标和
func nSumTarget(nums []int, n int ,start int, target int) [][]int{
    size := len(nums)
    var result [][]int
    if n < 2 || size < n { // 最低求两数之和 or 数组中数据个数不能小于n
        return result
    } else if n == 2 {//求两数和
      	// left 左边界 right 右边界
        left,right := start,size-1
        for left < right {

            leftValue := nums[left]
            rightValue := nums[right]
          	//左右位置的两数和
            sum := leftValue + rightValue

            if sum < target { // 求的sum值，比目标和偏小，增大left
                for left <right && nums[left] == leftValue {
                    left++
                }
            } else if sum > target { // 求的sum值，比目标和偏大，减小right
                for left < right && nums[right] == rightValue {
                    right--
                }
            } else {
              	// 找到一组 leftValue 和 rightValue
                result = append(result,[]int{leftValue,rightValue})
              	// 题目要求不能重复
                for left <right && nums[left] == leftValue {
                    left++
                }
                for left < right && nums[right] == rightValue {
                    right--
                }
            }
        }
    }else {
        for i := start;i<size;i++{ //固定一个数值，求剩下的两个数值
            sub := nSumTarget(nums,n-1,i+1,target-nums[i])
            //对结果整合
            for _,v := range sub {
                v = append(v,nums[i])//追加当前数值，组成n数之和
                result = append(result,v)
            }
            //判断下一个数值是否和当前值重复（一样）
            for i+1 < size && nums[i] == nums[i+1]{
                i++
            }
        }
    }

    return result
}
```



## 53. 最大子数组和

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**：是数组中的一个连续部分。

思路：

- `dp` 数组的定义：**以 `nums[i]` 为结尾的「最大子数组和」为 `dp[i]`。**

- `dp`数组递推关系为： `dp[i] = max(0,dp[i-1]) + num[i]`

  `dp[i]` 有两种「选择」，要么与前面的相邻子数组`dp[i-1]`连接，形成一个和更大的子数组；要么不与前面的子数组连接，自己单独一个元素，作为一个子数组。

```go
func maxSubArray(nums []int) int {
	
  // 1. 构建dp数组
	dp := make([]int, len(nums))
  // 2.初始化：根据定义，第一个元素的最大子数组和，就是第一个元素值
	dp[0] = nums[0]
  
  // result 记录最大子数组和
  result := nums[0] 

	// 3.应用递推关系：针对每个元素i作为结尾，求以元素i结尾的最大子数组和
	for i := 1; i < len(nums); i++ {
    // 如果dp[i-1]为负数，当前元素本身就是最大和（也就是不需要和前面其他元素进行连接）；
    dp[i] = max(dp[i-1],0) + nums[i] 
		result = max( result , dp[i] )
	}
	return result
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```



## 912. 排序数组

给你一个整数数组 `nums`，请你将该数组升序排列。你必须在 **不使用任何内置函数** 的情况下解决问题，时间复杂度为 `O(nlog(n))`，并且空间复杂度尽可能小。

思路：

这里提供必考的**3种排序算法**

> 快速排序

**快速排序是先将一个元素排好序，然后再将剩下的元素排好序**。

```go
func sortArray(nums []int) []int {
    //快速排序
    quickSort(nums,0,len(nums)-1)
    return nums
}

func quickSort(nums []int, lo ,hi int) {
    if lo >= hi { //相当于只有一个数，或者越界，就不用比较了
        return
    }

    //1.选择一个数，作为参考元素
    val := nums[lo]

    //2.左右起始索引
    left := lo + 1
    right := hi

    //3.使左边nums[left]比val小   右边nums[right]比val大
    for left <= right {
        for left <= right && nums[left] < val { //ums[left]记录比val小的数据索引
            left++
        }

        for left <= right && nums[right] >= val {//nums[right]记录比val大的数据索引
            right--
        }
        if left > right {
            break
        }
        // 执行到这里，说明 nums[left]比 val 大， nums[right] 比val 小（也就是不满足上面的条件）
        // 交换 left 和 right，让 left right 指向的元素继续满足条件
        nums[left],nums[right] = nums[right],nums[left]
    }
    //交换 lo 和right，这样nums[lo]这个元素已经排序完成，保存在了 right 索引位置
    nums[lo],nums[right] = nums[right],nums[lo]

  	// 递归调用 quickSort，让[lo,right-1] [right+1,hi] 两个子数组也都有序。
    //左边数组
    quickSort(nums,lo,right-1)
    //右边数组
    quickSort(nums,right+1,hi)
    return 
}
```

![image-20241216102101741](./images/image-20241216102101741.png)

> 归并排序

![image-20241216124441311](./images/image-20241216124441311.png)

```go
var temp []int = nil
func sortArray(nums []int) []int {

    //归并排序
    temp = make([]int,len(nums)) //临时数组，用来临时存储merge后的有序结果
    sort(nums,0,len(nums)-1)
    return nums
}

// sort 函数定义：对数组nums范围[lo,hi]排序，并使之有序
func sort(nums []int ,lo int,hi int) {
    if lo == hi { //单个元素就不用排序了
        return
    }
    mid := lo + (hi-lo)/2//将数组一分为二
    sort(nums,lo,mid)//对左边排序
    sort(nums,mid+1,hi)//对右边排序
    merge(nums,lo,mid,hi) //合并左右 有序数组
}

//合并有序数组
func merge(nums []int,lo int ,mid int,hi int) {

    left := lo //左边有序数组起始点
    right := mid+1//右边有序数组起始点

    for i := lo;i <= hi;i++ { //总共[lo,hi]个元素
        if left == mid+1 { //左边全部遍历完
            temp[i] = nums[right]
            right++
        } else if right == hi+1 { //右边全部遍历完
            temp[i] = nums[left]
            left++
        } else if nums[left] > nums[right]{ // 优先合并小的元素
            temp[i] = nums[right]
            right++
        } else {
            temp[i] = nums[left]
            left++
        }
    }
    //将临时数组中的数组temp，复制到 nums中
    for i:= lo;i<=hi;i++{
        nums[i] = temp[i]
    }
}
```







> 堆排序



利用的下沉操作sink，将数组最大元素移动到数组首部，然后和尾部元素交换（尾部元素就不用再管了，因为已经有序了）此时尾部就是最大的值；然后对剩下的数组元素进行下沉操作；保证次大的元素，成为新的首部元素；继续和尾部交换（注意这里的尾部不是最后一个，是倒数第二个了）

![image-20241216112926897](./images/image-20241216112926897.png)

```go
func sortArray(nums []int) []int {
   
    length := len(nums)
  	// 1.一开始需要针对数组，进行初始化操作,从第一个非叶子节点开始
    for i := length/2-1;i >= 0;i-- {  // 倒着遍历
        sink(nums,i,length) 
    }
  	// 2.上面初始化完成后，保证了数组中的最大值，已经成为数组的第一个元素

    for i := length-1;i >= 0;i-- {
        // 交换首部和尾部元素
        nums[0],nums[i] = nums[i],nums[0]
        length-- // 上面交换以后，尾部元素就是最大的有序元素了；只需要对前面剩余的length-1长度的元素进行排序，需要排序的长度变短了，这也就是为什么倒序遍历的原因（因为最后一个元素已经处理好了）
        // 对首部元素进行下沉操作（因为首部元素经过上面的交互，已经变成了一个新元素，不一定是次大的元素）
        sink(nums,0,length)
    }

    return nums
}


// 下沉操作，就是比较节点的和左右节点的大小关系；找出三个节点中的最大的索引值
func sink(nums []int ,idx ,len int) {
    for leftIdx(idx) < len { // 目的：如果左边的索引都越界了，右边的索引肯定也越界了
        maxIdx := idx

        // 注意：这里的用的是 nums[maxIdx]
        if leftIdx(idx) < len && nums[maxIdx] < nums[leftIdx(idx)] { // 左边的元素比较大
            maxIdx = leftIdx(idx)
        }   

        if rightIdx(idx) < len && nums[maxIdx] < nums[rightIdx(idx)] {
            maxIdx = rightIdx(idx)
        }

        // maxIdx的目的：为了记录最大的索引是哪个
        if maxIdx == idx { // 说明自己就是最大的那个，不需要下沉了(maxIdx在这里有种指针的感觉)
            break
        }

        // 交换数值
        nums[maxIdx],nums[idx] = nums[idx],nums[maxIdx]
      	// 继续进行下沉操作
        idx = maxIdx 
    }
}

func leftIdx(idx int) int {
    return idx *2 +1
}

func rightIdx(idx int) int {
    return idx*2+2
}
```

![image-20241216111613587](./images/image-20241216111613587.png)



## 21.合并两个有序链表

将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 

![image-20241216125835417](./images/image-20241216125835417.png)

思路：

这个算法的逻辑类似于「拉拉链」，`list1, list1` 类似于拉链两侧的锯齿，指针 `cur` 就好像拉链的拉索，将两个有序链表合并。

**代码中还用到一个链表的算法题中是很常见的「虚拟头节点」技巧，也就是 `dummy` 节点**，它相当于是个占位符，可以避免处理空指针的情况，降低代码的复杂性。

```go
func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode {
  	// 1.定义虚拟头结点
    var dummy *ListNode = &ListNode{Val : 0,Next:nil}
    cur := dummy
		
  	//2. 将两个链表中，值小的一个节点拼接到 cur 后面
    for list1 != nil && list2 != nil {
        if list1.Val <= list2.Val {
            cur.Next = list1
            list1 = list1.Next
        } else {
            cur.Next = list2
            list2 = list2.Next
        }
         cur = cur.Next
    }
		//3. 假如两个链表一个长 or 一个短，会导致其中一个链表还有剩余节点，直接拼接到cur后面即可
    if list1 != nil {
        cur.Next = list1
    }

    if list2 != nil {
        cur.Next = list2
    }
		//4. 返回dummy节点的下一个节点，才是要求的结果
    return dummy.Next
}
```



## 5. 最长回文子串

给你一个字符串 `s`，找到 `s` 中最长的 回文 子串。

思路：

**寻找回文串的问题核心思想是：从中间开始向两边扩散来判断回文串**

```go
for 0 <= i < len(s):
    找到以 s[i] 为中心的回文串
    更新答案
```

找回文串的关键技巧是传入两个指针 `l` 和 `r` 向两边扩散，因为这样实现可以同时处理回文串长度为奇数和偶数的情况。

```go
for 0 <= i < len(s):
    // 找到以 s[i] 为中心的回文串
    palindrome(s, i, i)
    // 找到以 s[i] 和 s[i+1] 为中心的回文串
    palindrome(s, i, i + 1)
    更新答案
```

比如 `abba`的最长回文子串是 `abba` 如果只是以一个字符`s[i]`作为中心查找，该字符串是查不到回文串的。

```go
func longestPalindrome(s string) string {

	var result string

	for i := 0; i < len(s); i++ {

		s1 := isPalidrome(s, i, i)
		if len(s1) > len(result) {
			result = s1
		}

		s2 := isPalidrome(s, i, i+1)
		if len(s2) > len(result) {
			result = s2
		}
	}

	return result
}

func isPalidrome(s string, left, right int) string {

	for left >= 0 && right <= len(s)-1  && s[left] == s[right] {
			left--
			right++
	}
	return string(s[left+1 : right])
}
```



## 102. 二叉树的层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。

![image-20241216131328055](./images/image-20241216131328055.png)

思路：

这题就是固定的解法套路，没有技巧，全靠记忆

```go
func levelOrder(root *TreeNode) [][]int {
    
    result := [][]int{}
  	//1. 判断是否为空树
    if root == nil {
        return result
    }
  	//2. 定义数组，保存根节点
    saveKey := []*TreeNode{}
    saveKey = append(saveKey,root) 
		//3. 判断是否为空
    for len(saveKey) != 0 { 
      	//4. 确定本次的边界
        count := len(saveKey) 
        temp := []int{}
        for i := 0;i< count;i++ { 
          	//5.把边界内的数值取出，并保存下来。
            temp = append(temp,saveKey[i].Val)
          	//6.注意这里，不为nil才保存到 saveKey中
            if saveKey[i].Left != nil {
                saveKey = append(saveKey,saveKey[i].Left)
            }
            if saveKey[i].Right != nil {
                saveKey = append(saveKey,saveKey[i].Right)
            }
        }
        result = append(result,temp)
      	//7.从 count截断 saveKey，剩下的就是下层的节点
        saveKey = saveKey[count:]
    }
    return result
}
```



## 1.两数之和

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。你可以假设每种输入只会对应一个答案，并且你不能使用两次相同的元素。你可以按任意顺序返回答案。

思路：

- 简单说，数组其实可以理解为一个「索引 -> 值」的哈希表映射，而我们又建立一个「值 -> 索引」的映射即可完成此题。

```go
func twoSum(nums []int, target int) []int {
    //利用map实现
    m := make(map[int]int) //key表示数值 value表示索引值
    
    for k,v := range nums {
      	// target-v查找哈希表，判断是否已经存在该值
        if index ,ok := m[target-v];ok {
            return []int{k,index}
        }
      	// 保存 值->索引
        m[v] = k
    }
    return nil
}
```



## 33.搜索旋转排序数组

整数数组 `nums` 按升序排列，数组中的值 **互不相同** 。

在传递给函数之前，`nums` 在预先未知的某个下标 `k`（`0 <= k < nums.length`）上进行了 **旋转**，使数组变为 `[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]`（下标 **从 0 开始** 计数）。例如， `[0,1,2,4,5,6,7]` 在下标 `3` 处经旋转后可能变为 `[4,5,6,7,0,1,2]` 。

给你 **旋转后** 的数组 `nums` 和一个整数 `target` ，如果 `nums` 中存在这个目标值 `target` ，则返回它的下标，否则返回 `-1` 。

你必须设计一个时间复杂度为 `O(log n)` 的算法解决此问题。

思路：

- 题目要求时间复杂度`O(log n)` 那就要想到二分法

![image-20241216151627555](./images/image-20241216151627555.png)

```go
func search(nums []int, target int) int {
    //！！！ 二分法查找；需要画图理解
    left , right := 0,len(nums)-1
    for left <= right {
        mid := left + (right-left)/2

        if nums[mid] == target { // 找到 target
            return mid
        } else if nums[left] <= nums[mid] { // 说明 [left,mid] 是有序递增的子数组
            if nums[left] <= target && target < nums[mid]  {//2. target 位于 [left,mid]有序递增数组中
                right = mid-1 // 收缩右边界（其实就是丢弃右边的子数组）
            }else {
                left = mid+1
            }
        }else { //说明 [mid,right] 是有序递增的子数组
            if nums[mid] < target && target <= nums[right] { // target位于 [mid,right]有序递增数组中
                left = mid+1  // 收缩左边界（其实就是丢弃左边的子数组）
            }else {
                right = mid-1
            }
        }
    }
    return -1
}
```



## 200.岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。此外，你可以假设该网格的四条边均被水包围。

思路：

- 用 DFS 算法解决岛屿题目是最常见的，每次遇到一个岛屿中的陆地，就用 DFS 算法吧这个岛屿「淹掉」。

```go
func numIslands(grid [][]byte) int {
    m := len(grid)
    n := len(grid[0])
    result := 0
  	// 对二维数组进行遍历
    for i := 0;i < m;i++ {
        for j := 0;j < n ;j++ {
          	// 一旦发现一个陆地
            if grid[i][j] == '1' { 
                result++
              	// 就将和该 grid[i][j] 陆地相连接的陆地，全部淹没掉
                dfs(grid,i,j)
            }
        }
    }

    return result
}

// 深度优先算法，
func dfs(grid [][]byte,i,j int) {
    m := len(grid)
    n := len(grid[0])
    if i < 0 || j < 0 || i >= m || j >= n { //越界检测
        return
    }
		// 说明当前是水
    if grid[i][j] == '0' {
        return
    }
  	// 执行到这里，说明你是陆地
    grid[i][j] = '0' //淹没掉陆地
    dfs(grid,i-1,j) //上
    dfs(grid,i+1,j) //下 
    dfs(grid,i,j+1) //右
    dfs(grid,i,j-1) //左
}
```



## 121.买卖股票的最佳时机

给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。

思路：

买卖股票类的题目有一套**通用的解题方案**：

- `dp`数组定义：

> `dp[i][k][0 or 1]` 
>
> `0 <= i <= n - 1, 1 <= k <= K`      
>
>   n 为天数，大 K 为完成交易数的上限，0 和 1 代表是否持有股票

所以，`dp[i][k][0 or 1]` 的含义就是：在从 `0`到 `i`天，完成了`k`笔交易，不持有`0` or 持有 `1`股票，能获取的最大利润

- `dp`的递推关系定义：

```go

dp[i][k][0] = max(dp[i-1][k][0], dp[i-1][k][1] + prices[i])
//dp[i][k][0] 表示 从 0 到 第i天，完成k笔交易，不持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][0] 								表示 从 0 到i-1天（也就是前一天），也没有持有股票
// dp[i-1][k][1] + prices[i]  	表示 从 0 到i-1天（也就是前一天），持有了股票，但是今天选择卖出，那么今天不就不持有股票了


dp[i][k][1] = max(dp[i-1][k][1], dp[i-1][k-1][0] - prices[i])
// dp[i][k][1]  表示从 0 到第i天，完成k笔交易，持有股票，能获取的最大利润
分成两种情况：
// dp[i-1][k][1] 							 	表示从 0 到 i-1天（也就是前一天），也持有股票
// dp[i-1][k-1][0] - prices[i] 	表示从 0 到 i-1天（也就是前一天），未持有了股票，但是今天选择买入，那么不就持有股票了。因为是今天买入股票，完成了一笔交易，今天的交易次数是k的前提下，那么前一天的交易次数就是 k-1


最终答案：因为要求最大利润，那只有不持有股票的最大利润 dp[n-1][k][0] （从 0到 n-1，完成了k笔交易后，不持有股票）
```

本题答案：

```go
func maxProfit(prices []int) int {
  	// 1. 构建二维 dp数组
    n := len(prices) //n天
    dp := make([][]int,n)
    for k,_ := range dp {
        // 每天只有两种选择 【0不持有 1持有】
        dp[k] = make([]int,2)
    }

    //状态转移方程
    /*
        dp[i][0 or 1] 表示到第i天时候，选择（持有或不持有股票）能获取到的最大利润；
        dp[i][0] = max(dp[i-1][0], dp[i-1][1] + price[i]) // 卖出
        dp[i][1] = max(dp[i-1][1], -price[i]) //买入
    */

    for i := 0;i < n; i++ {
      	//2. 特殊处理
        if i - 1 == -1 {
            dp[i][0] = 0
            dp[i][1] = -prices[i]
        } else {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
            // 核心在于：只能有一次买卖行为；在第i天持有股票，那说明之前就一直持有 dp[i-1][1]
            // 或者，之前一直都没有持有，今天第i天是第一次交易行为；
            // 如果带上 dp[i-1][0] 有考虑之前的历史交易行为（题目限定只有一次交易行为）
            dp[i][1] = max(dp[i-1][1], -prices[i]) 
        }
    }
		//因为要求最大利润，那肯定是不持有最大利润最大
    return dp[n-1][0] 
}

func max( a,b int) int {
    if a > b {
        return a
    }
    return b
}
```



## 46.全排列

给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。

```
示例1:
输入：nums = [1,2,3]
输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
```

思路：

- 可以参考下👆回溯算法解题模板

因为是求排列，每选择一个元素后，下一个 `backtrack`从**所有的元素**中（所以不需要 `start`来圈定选择范围）再选择下一个元素，为了避免同一个元素重复被选中，用`used`记录元素是否已经被选过。

```go

var result [][]int
func permute(nums []int) [][]int {
    result = [][]int{} //清空结果
  	// 记录是否已经使用过
    used := make([]bool,len(nums))
    trace := make([]int,0)
  	//回溯算法
    backtrack(nums,trace,used)
    return result
}

//回溯算法
func backtrack (nums []int,trace []int , used []bool)  {

    if len(trace) == len(nums) { //trace记录路径
        temp := make([]int,len(trace)) //golang 这个要注意，切片需要复制一个出来
        copy(temp,trace)
        result = append(result,temp)
        return
    }
    // 排列，每次都从头开始选择
    for i := 0;i < len(nums);i++ {
        
        if used[i] { //当前值已经选择过了，跳过
            continue
        }

        trace = append(trace,nums[i]) //选择
        used[i] = true

        backtrack(nums,trace,used)

        trace = trace[:len(trace)-1]//撤销选择
        used[i] = false
    } 

}
```



## 88.合并两个有序数组

给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。

**注意：**最终，合并后数组不应由函数返回，而是存储在数组 `nums1` 中。为了应对这种情况，`nums1` 的初始长度为 `m + n`，其中前 `m` 个元素表示应合并的元素，后 `n` 个元素为 `0` ，应忽略。`nums2` 的长度为 `n` 。

思路：

- 很像前文中讲过的 [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)，这里让你合并两个有序数组。
- 对于单链表来说，我们直接用双指针从头开始合并即可，但对于数组来说会出问题。因为题目让我直接把结果存到 `nums1` 中，而 `nums1` 的开头有元素，如果我们无脑复制单链表的逻辑，会覆盖掉 `nums1` 的原始元素，导致错误。但 `nums1` 后面是空的呀，所以这道题需要我们稍微变通一下：**将双指针初始化在数组的尾部，然后从后向前进行合并**，这样即便覆盖了 `nums1` 中的元素，这些元素也必然早就被用过了，不会影响答案的正确性。

```go
func merge(nums1 []int, m int, nums2 []int, n int)  {
    //双指针：从数组的尾部，向前合并
    left,right := m-1,n-1 //都指向尾部
    pos := m+n-1
    for left >= 0 && right >= 0 {
        if nums1[left] >= nums2[right] { // 选择大的，放入尾部
            nums1[pos] = nums1[left]
            pos--
            left--
        } else {
            nums1[pos] = nums2[right]
            pos--
            right--
        }
    }
  	// right 还有剩余，直接复制
    for right >=0 {
        nums1[pos] = nums2[right]
        pos--
        right--
    }
    return 
}
```



## 20.有效的括号

给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。
3. 每个右括号都有一个对应的相同类型的左括号。

思路：

- 栈是一种先进后出的数据结构，处理括号问题的时候尤其有用。

- 假设字符串中只有圆括号 **（）**，如果想让括号字符串有效，那么必须做到：

  **每个右括号 `)` 的左边必须有一个左括号 `(` 和它匹配**。

  比如说字符串 `()))((` 中，中间的两个右括号**左边**就没有左括号匹配，所以这个括号组合是无效的。

- 利用栈，保证完成匹配的括号，不会存在在栈中，最后栈中剩下的就是没有完成匹配的；

```go
func isValid(s string) bool {
  	// 初始
    stack := make([]byte,0)
  	// 遍历字符
    for i := 0;i< len(s);i++ {  
      	// 如果栈不为空，判断栈顶括号 和 当前括号是否匹配
        if len(stack) != 0 && isPair(stack[len(stack)-1],s[i]) {
            stack = stack[:len(stack)-1] // 出栈
        } else {
            stack = append(stack,s[i]) // 否则，当前的括号才能入栈
        }
    }
  	// 栈为空，说明括号都完全匹配
    if len(stack) == 0 {
        return true
    }
  	// 比如 ({)}
    return false
}

func isPair(a,b byte) bool {
    if a == '(' && b == ')' {
        return true
    }

    if a == '[' && b == ']' {
        return true
    }

    if a == '{' && b == '}' {
        return true
    }

    return false
}
```



## 141.环形链表

给你一个链表的头节点 `head` ，判断链表中是否有环。

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。**注意：`pos` 不作为参数进行传递** 。仅仅是为了标识链表的实际情况。

*如果链表中存在环* ，则返回 `true` 。 否则，返回 `false` 。

![image-20241217184157384](./images/image-20241217184157384.png)

思路：

经典题目了，使用双指针技巧中的快慢指针，每当慢指针 `slow` 前进一步，快指针 `fast` 就前进两步。如果 `fast` 最终遇到空指针，说明链表中没有环；如果 `fast` 最终和 `slow` 相遇，那肯定是 `fast` 超过了 `slow` 一圈，说明链表中含有环。

```go
func hasCycle(head *ListNode) bool {
    //快慢指针
    slow,fast := head,head
  	// 表示 fast 能够跳跃两步。如果 fast == nil(空节点) 或者 fast.Next == nil（只有fast这一个节点，没有后续节点）
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
        if slow == fast {
            return true
        }
    }
    return false
}
```



## 103.二叉树的锯齿形层序遍历

给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。

思路：

- 这题和上面的层序遍历是一样的，只是多了一个元素值存储的方向的控制 `flag`

```go
func zigzagLevelOrder(root *TreeNode) [][]int {

    result := [][]int{}
  	// 空树
    if root == nil {
        return result
    }

    //和层序遍历一样
    nodes := []*TreeNode{}
    nodes = append(nodes,root)

    flag := true //控制结果 放入的方向

    for len(nodes) != 0 {
        count := len(nodes) // 节点数量

        temp := []int{}
        for i := 0;i < count;i++ {  

            if flag { // 保存在尾部（正序）
                temp = append(temp,nodes[i].Val)
            } else {
              	// 保存在头部（倒序）
                temp = append([]int{nodes[i].Val},temp...)
            }

            // left不为空
            if nodes[i].Left != nil {
                nodes = append(nodes,nodes[i].Left)
            }
						// right 不为空
            if nodes[i].Right != nil {
                nodes = append(nodes,nodes[i].Right)
            }
        }
      	// 切换方向
        flag = !flag
        result = append(result,temp)
        nodes = nodes[count:] //count之前的需要舍弃
    }
    return result
}
```



## 235.二叉树的最近公共祖先

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

[百度百科](https://baike.baidu.com/item/最近公共祖先/8918834?fr=aladdin)中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（**一个节点也可以是它自己的祖先**）。

思路：

- 给出递归函数的定义：给该函数输入三个参数 `root`，`p`，`q`，它会返回一个节点：
- 情况 1，如果 `p` 和 `q` 都在以 `root` 为根的树中，那么 `left` 和 `right` 一定分别是 `p` 和 `q`。
- 情况 2，如果 `p` 和 `q` 都不在以 `root` 为根的树中，直接返回 `null`。
- 情况 3，如果 `p` 和 `q` 只有一个存在于 `root` 为根的树中，函数返回该节点。

![image-20241217191330565](./images/image-20241217191330565.png)

```go
// 给该函数输入三个参数 `root`，`p`，`q`，它会返回一个节点 
func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode {
   	
     if root == p || root == q || root == nil{
         return root
     }

     left := lowestCommonAncestor(root.Left,p,q)
     right := lowestCommonAncestor(root.Right,p,q)
		 // p q 分别位于 root 的 left right 中
     if left != nil && right != nil {
         return root
     }
		 // p q 都位于 left
     if left != nil {
         return left
     }
		 // p q 都位于 right
     if right != nil {
         return right
     }
     // p q 不在 root 树中
     return nil
}
```

## 92.反转链表 II

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

![image-20241218153607707](./images/image-20241218153607707.png)

思路：

- 递归解法：

  迭代解法很简单，用一个 for 循环即可，但这道题经常用来考察递归思维，让你用纯递归的形式来解决。

  要想真正理解递归操作链表的代码思路，关键点还是要明确递归函数的定义，推导出递归翻转前 `N` 个节点的算法，最后改写出递归翻转区间内的节点的解法代码

  

  ```go
  // 翻转left，right之间的链表
  func reverseBetween(head *ListNode, left int, right int) *ListNode {
      //先找到【翻转的第一个起始节点】，才开始真正的翻转
      if left == 1 {
          return reverseN(head,right)
      }
      //说明当前节点，不需要翻转。当前节点的尾部，拼接翻转后链表的头部
      head.Next = reverseBetween(head.Next,left-1,right-1)
      return head
  }
  
  var successor *ListNode = nil
  // 从head开始，翻转n个节点，返回链表的头节点
  func reverseN(head *ListNode,  n int) *ListNode {
      if n == 1 {  //说明当前是最后一个节点
          successor = head.Next // 记录后续节点
          return head
      }
  		
    	// 从head.Next 开始，翻转n-1个节点，返回链表的头节点
      last := reverseN(head.Next,n-1)
    	// 对head节点反转（反转后head节点就变成了最后一个节点）
      head.Next.Next = head 
      head.Next = successor
  
      return last
  }
  
  ```

  ![image-20241218170704572](./images/image-20241218170704572.png)

- 迭代解法：

  > dummy 定义虚拟节点
  >
  > 遍历整个链表，cur指向正在访问的节点，i 记录指向的节点是第几个。如果cur指向的节点不是要反转的节点，不断的追加到p.Next同时p也不断的移动
  >
  > 如果cur指向的节点是要反转的节点，不断的追加到p.Next同时p 不移动
  >
  > leftNode 用来记录第一个反转的节点（因为反转后，第一个节点，变成反转后的最后一个节点），如上中的节点2，变成反转后最后一个节点

![image-20241218164408974](./images/image-20241218164408974.png)

```go
func reverseBetween(head *ListNode, left int, right int) *ListNode {
    // 虚拟节点
    dummy := &ListNode{}
    p := dummy 
    // 表示当前 cur指向的是第几个节点
    i := 1
    cur := head

    var leftNode *ListNode

    // 遍历链表中的每一个节点
    for cur != nil {
        // 将下一个节点记录来下
        temp := cur.Next
        if  left <=i && i <= right { // 进入到反转范围的节点
            // 将节点保存在p后面，但是p不移动
            cur.Next = p.Next
            p.Next = cur

            // 记录第一个反转的节点
            if i == left {
                leftNode = cur
            }
            // 最后让p指向第一个反转的节点（因为已经成为了最后一个节点）
            if i == right {
                p = leftNode
            }
        } else { // 不是要反转的节点
            // 将节点保存在p后面，但是p也跟着移动
            p.Next = cur
            p = p.Next
            p.Next = nil // 让p的后续节点为nil，特例：[3,5] left= 2 right = 2
        }
        // 跳到，下一个节点
        i++
        cur = temp
    }
    return dummy.Next
}
```



## 23.合并K个升序链表

给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。

思路：

- 类型于归并排序，将链表数组切分称两个子数组，分别对子数组排序，然后将排序后的两个子数组进行`merge`成一个大的有序数组

```go
func mergeKLists(lists []*ListNode) *ListNode {
  	// 这里lists的长度可能为0
    if len(lists) == 0 {
        return nil
    }
    return sortK(lists,0,len(lists)-1) 
}

//定义：对【left，right】之间的链表排序，返回有序链表头节点
func sortK( lists []*ListNode,left,right int) *ListNode {
    if left == right {
        return lists[left]
    }
  	// 切分成两个子数组，分别排序
    mid := left +(right-left)/2
    l := sortK(lists,left,mid)
    r := sortK(lists,mid+1,right)
  	// 合并两个有序链表
    return merge(l,r)
}
//对两个有序链表合并，返回头节点
func merge(l,r *ListNode) *ListNode {
  	//虚拟头节点
    dummy := &ListNode{Val:0,Next:nil} 

    p := dummy

    for l != nil && r != nil {
        if l.Val < r.Val {
            p.Next = l
            l = l.Next
        } else {
            p.Next = r
            r = r.Next
        }
        p = p.Next
    }
    
    if l != nil {
        p.Next = l
    }

    if r != nil {
        p.Next = r
    }
    return dummy.Next
}
```



## 54.螺旋矩阵

给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。

![image-20241218172519569](./images/image-20241218172519569.png)

思路：

本质就是对二维数组的遍历，先横向遍历，再竖向遍历（一直反复进行）。注意的点：范围不要越界。

```go
func spiralOrder(matrix [][]int) []int {
    m := len(matrix)
    n := len(matrix[0])

    top,end := 0, m-1
    left,right := 0,n-1
    var result []int
		// 结束条件 result已经保存了所有的元素
    for len(result) < m * n {

        if top <= end { //上下边界不越界 
            //遍历top，从left 到right
            for i := left; i <= right;i++ {
                result = append(result,matrix[top][i])
            }
            top++ // 顶部下移
        }

        if left <= right {
            //遍历right，从top到end
            for i := top;i <= end;i++ {
                result = append(result, matrix[i][right])
            }
            right-- //右边左移
        }
        
        if top <= end {
            //遍历end，从right到left
            for i := right;i >= left;i-- {
                result = append(result,matrix[end][i])
            }
            end-- //底部上移
        }
        
        if left <= right {
            //遍历left，从end到top
            for i := end;i >= top;i-- {
                result = append(result,matrix[i][left])
            }
            left++  
        }
    }
    return result
}
```



## 300.最长递增子序列

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列

思路：

- `dp` 数组的定义：`dp[i]` 表示以 `nums[i]` 这个数结尾的最长递增子序列的长度。

  那么 `dp` 数组中最大值，就是最长的递增子序列长度。

- 递推关系： `if nums[i] > nums[i-1]  dp[i] = max(dp[i],dp[i-1] + 1)`

```go
func lengthOfLIS(nums []int) int {
    //定义dp[i] 为以nums[i]为结尾，最大子序列【长度】

    dp := make([]int,len(nums))
    var result int
		// 默认每次元素就是一个子序列
    for k,_ := range dp {
        dp[k] = 1
    }

    for i := 0;i < len(nums);i++ {

        for j := 0;j < i;j++ { //和i之前的所有dp都对比一下[0, i-1]

            if nums[i] > nums[j] { //判断尾部数值大小
                dp[i] = max(dp[i],dp[j]+1)
            }
        }

        // 每个i位置处的最长递增子序列的长度中【最大值】
        result = max(result,dp[i])
    }
    return result
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```



## 415.字符串相加

给定两个字符串形式的非负整数 `num1` 和`num2` ，计算它们的和并同样以字符串形式返回。

你不能使用任何內建的用于处理大整数的库（比如 `BigInteger`）， 也不能直接将输入的字符串转换为整数形式。

思路：

- 双指针，分别指向字符串的尾部字符
- `carry`记录进位

```go
func addStrings(num1 string, num2 string) string {

    // 这题和二进制相加一样的解法，只是一个是十进制，一个是二进制

    l1 := len(num1)-1
    l2 := len(num2)-1

    carry  := 0
    result := ""
  	// 注意：条件是【或】的关系
    for l1 >= 0 || l2 >= 0 || carry != 0 {
        sum := carry
        if l1 >= 0 {
            sum += int(num1[l1] - '0')
            l1--
        }
        if l2 >= 0 {
            sum += int(num2[l2] - '0')
            l2--
        }
        result = string(sum % 10 + '0') + result // 余数拼接到result前面
        carry = sum / 10
    }
    return result
}
```



## 160.相交链表

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表不存在相交节点，返回`null`。

图示两个链表在节点 `c1` 开始相交**：**

![image-20241218174907646](./images/image-20241218174907646.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 

思路：

**解决这个问题的关键是，通过某些方式，让 `p1` 和 `p2` 能够同时到达相交节点 `c1`。**

如果用两个指针 `p1` 和 `p2` 分别在两条链表上前进，我们可以让 `p1` 遍历完链表 `A` 之后开始遍历链表 `B`，让 `p2` 遍历完链表 `B` 之后开始遍历链表 `A`，这样相当于「逻辑上」两条链表接在了一起。

如果这样进行拼接，就可以让 `p1` 和 `p2` 同时进入公共部分，也就是同时到达相交节点 `c1`：

![image-20241218180856369](./images/image-20241218180856369.png)

```go
func getIntersectionNode(headA, headB *ListNode) *ListNode {

    p1,p2 := headA,headB

    for p1 != p2 {
        if p1 == nil {
            p1 = headB
        } else {
            p1 = p1.Next
        }

        if p2 == nil {
            p2 = headA
        } else {
            p2 = p2.Next
        }
    }
    return p1
}

```

- 这里再提供另外一种方案

思路：

- 将两个链表首尾串联起来（物理上串联，上面的解法是逻辑上串联）
- 利用快慢指针，判断是否存在环
- 如果存在环，`fast`移动的距离是 2倍的 `slow`（因为`fast`一次移动2步，`slow`一次移动1步，如果相遇了，说明`fast`移动的距离是`slow`的2倍）
- 重置 `slow = headA`，同时移动 `slow fast`直到相遇，就是相交点。

![image-20241219153940645](./images/image-20241219153940645.png)

```go
func getIntersectionNode1(headA, headB *ListNode) *ListNode {
    //1.找到A链表最后一个节点
    q := headA

    for q.Next != nil {
        q = q.Next
    }
    //2.此时q指向链表A的最后一个节点，拼接A链表 + B链表
    q.Next = headB

    //3.快慢指针，判断是否有环
    slow,fast := headA,headA

    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next

        if slow == fast {//有环
            break
        }
    }

    //4. 执行到这里，并且fast == nil || fast.Next== nil，说明上面的for循环，不是因为有环结束的，是因为无环
    if fast == nil || fast.Next == nil {
     	 q.Next = nil //!!!断开两个链表(题目要求必须保持原来的结构)
        return nil
    }

    //5.有环，找到环的起始点
    slow = headA
    for slow != fast {
        slow = slow.Next
        fast = fast.Next
    }
  	// !!!断开两个链表(题目要求必须保持原来的结构)
    q.Next = nil

    return slow

}
```



## 143.重排链表

给定一个单链表 `L` 的头节点 `head` ，单链表 `L` 表示为：

```
L0 → L1 → … → Ln - 1 → Ln
```

请将其重新排列后变为：

```
L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
```

不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

思路：

- 先利用快慢指针将链表切分称两个子链表 `l1 l2`
- 对 `l2`进行反转
- 最后将 `l1 l2`节点交错的拼接到一起

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reorderList(head *ListNode)  {
    // 无节点 or 单个节点
    if head == nil || head.Next == nil {
        return
    }
    //快慢指针，找到中点
    fast,slow := head,head
    for fast != nil && fast.Next != nil {
        slow = slow.Next
        fast = fast.Next.Next
    }

    //!!!注意这个细节
    l1 := head // 子链表 l1
    l2 := slow.Next //中点的下一个节点，作为子链表 l2 起始节点
    slow.Next = nil //为了让l1尾部指向 nil 节点
  
    //翻转链表 l2
    l2 = reverseList(l2)
  
    //合并链表
    for l1 != nil && l2 != nil {
        l1Next := l1.Next
        l2Next := l2.Next

        l1.Next = l2
        l1 = l1Next

        l2.Next = l1 // l2指向l1 (此时 l1 = l1Next 已经移位了一步)
        l2 = l2Next
    }
}

// 翻转链表
func reverseList(head *ListNode) *ListNode {
    if head == nil || head.Next == nil {
        return head
    }
   
    last := reverseList(head.Next)
    head.Next.Next = head
    head.Next = nil
    return last 
}
```



## 56.合并区间

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [start, end]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

思路：

- 一个区间可以表示为 `[start, end]`，先按区间的 `start` 排序：
- **显然，对于几个相交区间合并后的结果区间 `x`，`x.start`的值 一定是这些相交区间中 `start` 最小的，`x.end` 一定是这些相交区间中 `end` 最大的**：

![image-20241219163052347](./images/image-20241219163052347.png)

```go
func merge(intervals [][]int) [][]int {
		// 按照 start 正序排列
    sort.Slice(intervals, func(i, j int) bool {
		return intervals[i][0] < intervals[j][0]
	})

    var result [][]int
    pre := intervals[0] //前一个切片

    for index := 1 ; index < len(intervals); index++ {
        cur := intervals[index] //当前切片
        
      	// 当前切片头部 cur[0] <= 前一个切片尾部pre[1] 【有交集】
        if cur[0] <= pre[1] {
            pre[1] = max(pre[1],cur[1]) //合并两个为一个，用尾部较大的值，作为合并后的区间尾部 pre[1]
        } else { //当前cur 和pre没有交集，将pre保存起来，同时cur作为pre
            result = append(result,pre)
            pre = cur
        }
    }
		// 最后记得，将pre保存到 result一份
    result = append(result,pre)
    return result
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```



## 42.接雨水

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

思路：

- 对于任意一个位置 `i`，能够装的水为：

```go
water[i] = 		// 左右两边的最高值的最小值 -  height[i]
							min(
  						// 0到i的最高值
  						max(height[0..i]) , 
  						// i 到 end的最高值
  						max(height[i..end])  )   - height[i]
```

![image-20241219165002229](./images/image-20241219165002229.png)

```go
func trap(height []int) int {
    ///！！！思路：答案理解起来比较容易，第一次做估计很难想到；

    //从左到右遍历[0...i]，求左边每个位置i的最高高度，l_dp[i] = max(height[i],l_dp[i-1]) 
    //从右到左遍历[i...end ]，求右边每个位置i的最高高度，r_dp[i] = max(height[i],r_dp[i+1])

    l_dp := make([]int,len(height)) // 从[0..i],求当前位置i，柱子的最高高度
    l_dp[0] = height[0]
    for i := 1;i < len(height);i++ {
        l_dp[i] = max(height[i],l_dp[i-1]) // l_dp[i-1]前一个柱子的最高高度
    }

    r_dp := make([]int,len(height)) //从 [i...end]，求当前位置i，柱子的最高高度
    r_dp[len(height)-1] = height[len(height)-1]

    for i := len(height)-2;i >= 0;i-- {
        r_dp[i] = max(height[i],r_dp[i+1])
    }

    result := 0
    for i := 0;i < len(height);i++ {
        result += min(l_dp[i],r_dp[i]) - height[i] //左边的最高高度 和 右边的最高高度，取最小值，减去当前的高度，表示当前位置可以保存到水量
    }
    return result
}

func min( a,b int) int{
    if a < b {
        return a
    }
    return b
}

func max( a,b int) int{
    if a > b {
        return a
    }
    return b
}
```



## 142.环形链表

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。



![image-20241219165654244](./images/image-20241219165654244.png)

思路：

我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步：

因为 `fast` 一次跳跃距离为`2` ，`slow` 一次跳跃距离为 `1`

![image-20241219171135336](./images/image-20241219171135336.png)

假设【相遇点】距环【相交点】的距离为 `m`，那么结合下图的 `slow` 指针，环的【相交点】距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。

巧的是，如果从【相遇点】继续前进 `k - m` 步，也恰好到达环【相交点】：

![image-20241219172001832](./images/image-20241219172001832.png)

所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func detectCycle(head *ListNode) *ListNode {
   
    //1.判断是否有环
    fast,slow := head,head
    for fast != nil && fast.Next != nil {
        
        fast = fast.Next.Next
        slow = slow.Next
        if fast == slow {
            break
        }
    }
    //2.说明没有环
    if fast == nil || fast.Next == nil {
        return nil
    }

    //3.说明有环，需要找到环的起始位置
    slow = head
    for slow != fast {
        fast = fast.Next
        slow = slow.Next
    }

    return slow

}
```



## 124. 二叉树中的最大路经和

二叉树中的 **路径** 被定义为一条节点序列，序列中每对相邻节点之间都存在一条边。同一个节点在一条路径序列中 **至多出现一次** 。该路径 **至少包含一个** 节点，且不一定经过根节点。

**路径和** 是路径中各节点值的总和。给你一个二叉树的根节点 `root` ，返回其 **最大路径和** 。

思路：

- 【从root为起点的最大路径】

这题在于递归函数的定义：`func oneSideMax(root *TreeNode) int `：从`root`为起点的最大路径和

不管`root.Val`是正还是负，从`root`节点出发（初始值`root.Val`），如果左节点`leftMax`是负值，只会使路经和值更小，也就是`left `不能作为路经 ；如果右节点`rightMax`是正数，可以使从`root`为起点的最大路径和变的更大，因此`right`可以作为路径

换句话说：从`root`出发的路经和，就是在`root.Val`值的基础上，上调或不变，如果`leftMax`为负值，那就是下调。不可能作为从`root`出发的最大路径。

![image-20241219183656494](./images/image-20241219183656494.png)

-   但是题目要求的是：【经过root】的最大路径和，注意和上面的区别，一个是从 root出发，题目要求的是经过 root 。

![image-20241219184958506](./images/image-20241219184958506.png)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var result int = math.MinInt
// 【从root为起点的最大路径】 与  【经过root的最大路径和，是两种不同的含义】需要体会下
func maxPathSum(root *TreeNode) int {

    result = math.MinInt
    if root == nil {
        return 0
    }
    oneSideMax(root)
    return result
}

// oneSideMax 函数定义：从root为起点的最大路径和
func oneSideMax(root *TreeNode) int {
    if root == nil {
        return 0
    }
  
    //这点比较绕
    leftMax := max(0,oneSideMax(root.Left)) //oneSideMax(root.Left)以root.Left为起点的最大路径和，结果可能是【正】或【负】，负数舍弃
    rightMax := max(0,oneSideMax(root.Right))
  
    

  // 经过root的最大路径和（从 left节点出发的最大路经和leftMax + 从 right节点出发的最大路经和 rightMax + 当前的值 root.Val )
    result = max(result,root.Val+leftMax+rightMax) 
		
 		 // 从root出发的最大路径和
    return max(leftMax,rightMax)+root.Val 
}

func max(a,b int)int{
    if a > b {
        return a
    }
    return b
}
```



## 72. 编辑距离

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

思路：

解决两个字符串的动态规划问题，一般都是用两个指针 `i, j` 分别指向两个字符串的最后，然后一步步往前走，缩小问题的规模。

对于每对字符 `s1[i]` 和 `s2[j]`，可以有四种操作：

```
if s1[i] == s2[j]:
    啥都别做（skip）
    i, j 同时向前移动
else:
    三选一：
        插入（insert）
        删除（delete）
        替换（replace）
```

- `dp`数组定义： `i`和`j`表示字符串长度，`dp[i][j]`表示最小操作数

- 递推关系： `i`和`j`表示字符串长度， `i-1` 和 `j-1`才表示最后一个字符的索引

  ```go
  if word1[i-1] == word2[j-1] {
  	dp[i][j] = dp[i-1][j-1] //不需要操作
  } else {
    dp[i-1][j] // i删除 j不变
    dp[i][j-1] // i不变，在i后面新增一个元素和j相同(也可以理解为 i不变，删除j)
    dp[i-1][j-1] // i和j同时replace为同一个元素
    
    dp[i][j] = min( dp[i-1][j]+1, dp[i][j-1]+1, dp[i-1][j-1]+1 )
  }
  ```

代码实现：

```go
func minDistance(word1 string, word2 string) int {
    
    m,n := len(word1),len(word2)
  	// 1.定义 dp数组
    dp := make([][]int,m+1)
    for k,_ := range dp {
        dp[k] = make([]int,n+1)
    }
  	// 2. 初始化 base case
    for i := 0;i <= m;i++ { // word2 字符串为空
        dp[i][0] = i // 需要的操作次数，新增i次元素
    }
    for j := 0;j<=n;j++ { // word1 字符串为空
        dp[0][j] = j // 需要的操作次数，新增j次元素
    }
		
  	//3. 一般递推关系
    for i := 1;i<=m;i++ {
        for j := 1;j<=n;j++ {
            if word1[i-1] == word2[j-1] {
                dp[i][j] = dp[i-1][j-1]
            } else {
                dp[i][j] = min(min(dp[i-1][j]+1,dp[i][j-1]+1),dp[i-1][j-1]+1)
            }
        }
    }
    return dp[m][n]
}

func min(a,b int)int{
    if a < b {
        return a
    }
    return b
}
```



## 93.复原IP地址

**有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。

- 例如：`"0.1.2.201"` 和` "192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。

给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。

思路：

- `for`循环每完成一组`[start,i]`数字的截取，剩下的字符串留给下一个递归函数截取

![image-20241220182843938](./images/image-20241220182843938.png)

```go

var result []string
func restoreIpAddresses(s string) []string {

    trace := []string{} //记录每个分段
  	
    result = []string{}
    backtrack(s,0,trace)
    return result
}

func backtrack(s string , start int ,trace []string) {
  	// 终止条件
		// 整个字符串s需要正好被完整分割
    if start == len(s) && len(trace) == 4 {
        result = append(result,strings.Join(trace,".")) // 分割程4个部分，拼接成 ip地址的格式
        return
    }

    if len(trace) >= 4 { // 到start位置，如果已经拆分超过了4段，[start,...]后面的位置没必要继续拆分了
        return 
    }

    for i := start;i < len(s);i++ {

        if !isVaild(s,start,i) { // 判断 [start,i] 是否是有效的字符串
            continue // 继续扩大i
        }

        // 选择 [start,i]
        trace = append(trace,s[start:i+1])
        backtrack(s,i+1,trace) // 继续下一个片段的截取
				// 撤销选择
        trace = trace[:len(trace)-1]
    }
}

func isVaild(s string, start ,end int) bool {
    //1.长度只能是1-3之间
    length := end - start+1

    if length > 3|| length == 0 {
        return false
    }
    //2.长度大于1的话，如果前缀出现字符0，是不正确
    if length > 1 &&  s[start] == '0' { 
        return false
    }

    //3. 判断是否在 255 范围内
    val ,_ := strconv.Atoi(s[start:end+1])
    if val > 255 {
        return false
    }
    return true
}
```



## 19.删除链表的倒数第N个结点

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

![image-20241220190322910](./images/image-20241220190322910.png)

思路：

要删除倒数第 `n` 个节点，就得获得倒数第 `n + 1` 个节点的引用。

- 第一步，我们先让一个指针 `p1` 指向链表的头节点 `head`，然后走 `k` 步：

![image-20241220185846249](./images/image-20241220185846249.png)

- 第二步，用一个指针 `p2` 指向链表头节点 `head`：

![image-20241220190032419](./images/image-20241220190032419.png)

- 第三步，让 `p1` 和 `p2` 同时向前走，`p1` 走到链表末尾的空指针时走了 `n - k` 步，`p2` 也走了 `n - k` 步，也就是链表的倒数第 `k` 个节点：

![image-20241220190217013](./images/image-20241220190217013.png)

这样，只遍历了一次链表，就获得了倒数第 `k` 个节点 `p2`。

解法中在链表头部接一个虚拟节点 `dummy` 是为了避免删除倒数第一个元素时出现空指针异常，在头部加入 `dummy` 节点并不影响尾部倒数第 `k` 个元素是什么。

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func removeNthFromEnd(head *ListNode, n int) *ListNode {
    //需要额外加一个虚拟节点
    dummy := &ListNode{Val:0}
    dummy.Next = head

    //查找倒数第N个节点（这里是找n+1节点）
    node := findN(dummy,n+1) 
  	// 删除 n 节点
    node.Next = node.Next.Next
    return dummy.Next
}


func findN(head *ListNode,n int) *ListNode {
  	// a b 都指向链表头部
    a,b := head,head
  	// a 先移动
    for i := 0;i<n;i++{
        a = a.Next
    }
	
    for a != nil {
        a = a.Next //a 到达尾部
        b = b.Next //b 指向的就是第n个节点
    }
    return b
}
```



## 1143.最长公共子序列

给定两个字符串 `text1` 和 `text2`，返回这两个字符串的最长 **公共子序列** 的长度。如果不存在 **公共子序列** ，返回 `0` 。

一个字符串的 **子序列** 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

- 例如，`"ace"` 是 `"abcde"` 的子序列，但 `"aec"` 不是 `"abcde"` 的子序列。

两个字符串的 **公共子序列** 是这两个字符串所共同拥有的子序列。

思路：

- 动态规划：和 [72. 编辑距离](https://leetcode.cn/problems/edit-distance) 同为经典的双字符串动态规划问题。

- `dp[i][j]`定义：表示`text1`中`[0,i-1]`长度为`i`字符串 和`text2`中`[0,j-1`]长度为`j`字符串，公共子序列的最长长度

- 递推关系：

  ![image-20241221003833062](./images/image-20241221003833062.png)

  ![image-20241221004032052](./images/image-20241221004032052.png)

```go
func longestCommonSubsequence(text1 string, text2 string) int {
   
    m := len(text1)
    n := len(text2)
		
  	//base case dp[0][...] = dp[...][0] = 0
    dp := make([][]int,m+1)
    for i := 0;i < m+1 ;i++ {
        dp[i] = make([]int,n+1)
    }
		// //i和j表示字符串长度
    for i := 1;i <= m;i++ { 
        for j := 1;j <=n ;j++ {
            if text1[i-1] == text2[j-1] { //说明尾部的字符相同，算作一个公共字符
                dp[i][j] = 1 + dp[i-1][j-1]
            } else {
                dp[i][j] = max(dp[i-1][j],dp[i][j-1]) //可能[i-1][j]尾部字符相同 或者 [i][j-1]尾部字符相同
            }
        }
    }
    return dp[m][n]
}

func max( a,b int)int{
    if a > b {
        return a
    }
    return b
}
```



## 82.删除排序链表中的重复元素II

给定一个已排序的链表的头 `head` ， *删除原始链表中所有重复数字的节点，只留下不同的数字* 。返回 *已排序的链表* 。

思路：

- 定义虚拟节点 `dummy`，保存不重复的节点
- 找到节点值相同的左右节点指针，`[left,right]`之间就是重复的数字节点（丢弃）

![image-20241221015122537](./images/image-20241221015122537.png)

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func deleteDuplicates(head *ListNode) *ListNode {
    // 说明 没有节点 or 只有一个节点
    if head == nil || head.Next == nil {
        return head
    }
    // 用来保存结果
    dummy := &ListNode{0,nil}
    node := dummy


    for head != nil {

        // 固定左边
        left := head
        // 看是否有下一个节点数值和left相同
        for head.Next != nil && left.Val == head.Next.Val {
            head = head.Next
        }

        //
        // 如果left 和 head 相同，说明没有移动过。否则， 是[left,head]之间的就是重复的元素（舍弃）
        if left == head { // 说明本节点不重复，保存到结果中
            node.Next = left
            node = node.Next
        }
        // head移动一位，从下一个节点，开始继续比较
        head = head.Next
    }
  
    // 【注意】：断开最后一个节点
    node.Next = nil
    return dummy.Next
}
```



## 94. 二叉树的中序遍历

给定一个二叉树的根节点 `root` ，返回 *它的 **中序** 遍历* 。

思路：

中序遍历结果的特点是 `root.val` 在中间，左右子树在两侧：

提供递归 + 迭代两种遍历方法：

- 递归方法：

```go
var result []int
func inorderTraversal1(root *TreeNode) []int {
    result = []int{}
    inorder(root)
    return result
}

func inorder(root *TreeNode) {
    if root == nil {
        return
    }
    inorder(root.Left) // 遍历 root.Left 树
    result = append(result,root.Val) // 当前 root.Val值
    inorder(root.Right) // 遍历 root.Right 树
}
```

![image-20241221145705065](./images/image-20241221145705065.png)

- 迭代方法

利用栈，先将左子树入栈，出栈的时候，记录出栈数值（效果相当于先遍历左子树，得到左树的中序遍历结果）；当左子树为空的时候，再将右子树入栈（等价于遍历右子树，得到右树的中序遍历结果）

```go

func inorderTraversal(root *TreeNode) []int {
    result := make([]int,0)
  	// 栈
    sk := []*TreeNode{}
  
    for len(sk) != 0 || root != nil {
      	
        for root != nil {
            sk = append(sk,root) //入栈： 将左节点不断的追加到 sk 中
            root = root.Left
        }
        // 出栈
        root = sk[len(sk)-1]
        sk = sk[:len(sk)-1]
        result = append(result,root.Val) // 中序遍历值
      	// 右节点继续入栈
        root = root.Right
    }
    return result
}
```

![image-20241221154238207](./images/image-20241221154238207.png)

![image-20241221154817905](./images/image-20241221154817905.png)

## 199.二叉树的右视图

给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

思路：

上面出现了多次的层序遍历的题目，这个题目只是要得到每层的最右边的节点值

![image-20241221171950059](./images/image-20241221171950059.png)

```GO
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func rightSideView(root *TreeNode) []int {
    //层序遍历
    result := []int{}
    if root == nil {
        return result
    }
  	// 初始节点
    nodes := []*TreeNode{}
    nodes = append(nodes,root)

    for len(nodes) != 0 {
      	// 每层的节点数
        count := len(nodes)

        for i := 0;i<count;i++ {
          
            if i == count-1 { // 每层最后一个节点
                result = append(result,nodes[i].Val)
            }

            if nodes[i].Left != nil {
                nodes = append(nodes,nodes[i].Left)
            }
            if nodes[i].Right != nil {
                nodes = append(nodes,nodes[i].Right)
            }
        }
        //!!!弹出nodes中的被遍历过的节点
        nodes = nodes[count:]
    }
    return result
}
```



## 74.二分查找

给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target` ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。

思路：

二分搜索算法最基础的题目： 定义`left right`指向数组的两端，通过`target`和 `nums[mid]`值比较，缩小搜索范围，直到找到目标值

```go
func search(nums []int, target int) int {
  	// 定义 left right 
    left,right := 0,len(nums)-1
  
    for left <= right {
      	// 中间索引
        mid := left+(right-left)/2
      	
        if nums[mid] == target { // 找到目标值
            return mid
        } else if nums[mid] > target { // 说明目标值在 [left,mid-1]之间
            right = mid-1
        } else { // 说明目标值在[mid+1,right] 之间
            left = mid+1
        }
    }
    return -1
}
```



## 232.用栈实现队列

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`



![image-20241221173538453](./images/image-20241221173538453.png)

```go
//核心思想：
//入栈：对stack1入栈
//出栈：判断stack2是否为空；不为空：出栈stack2。。。如果为空，需要将stack1中的放入到stack2中

type MyQueue struct {
    sk1 []int
    sk2 []int
}


func Constructor() MyQueue {
    mq := MyQueue{}
    mq.sk1 = make([]int,0)
    mq.sk2 = make([]int,0)
    return mq
}

// 入栈
func (this *MyQueue) Push(x int)  {
    this.sk1 = append(this.sk1,x)
}

// 出栈
func (this *MyQueue) Pop() int {
  	// sk2 不为空，直接出栈
    if len(this.sk2) != 0 {
        val := this.sk2[len(this.sk2)-1]
        this.sk2 = this.sk2[:len(this.sk2)-1]
        return val
    } else if len(this.sk1) != 0 { // sk2为空，但是sk1不为空

        for j := len(this.sk1)-1;j>= 0;j-- { //把sk1中的元素，倒着放入到sk2中
            this.sk2 = append(this.sk2,this.sk1[j])
        }
        //!!!清空
        this.sk1 = []int{}
      	// 出栈 sk2
        val := this.sk2[len(this.sk2)-1]
        this.sk2 = this.sk2[:len(this.sk2)-1]
        return val
    }

    return 0
}

// 预览
func (this *MyQueue) Peek() int {
    if len(this.sk2) != 0 {
        val := this.sk2[len(this.sk2)-1]
        //this.sk2 = this.sk2[:len(this.sk2-1)]
        return val
    } else if len(this.sk1) != 0 {
       for j := len(this.sk1)-1;j>= 0;j-- { //把sk1中的元素，倒着放入到sk2中
            this.sk2 = append(this.sk2,this.sk1[j])
        }
        //!!!清空
        this.sk1 = []int{}
        val := this.sk2[len(this.sk2)-1]
        //this.sk2 = this.sk2[:len(this.sk2)-1]
        return val
    }

    return 0
}

func (this *MyQueue) Empty() bool {
    if len(this.sk2) == 0 && len(this.sk1) == 0 {
        return true
    }
    return false
}
```



## 148. 排序链表

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

思路：

- 利用外慢指针技巧，先找到链表的中间节点
- 利用中间节点，将链表分成两个子链表，分别对子链表进行排序
- 最后再将两个有序子链表，合并成一个最终的结果

![image-20241221180631903](./images/image-20241221180631903.png)

```go

func sortList(head *ListNode) *ListNode {
    
    if head == nil || head.Next == nil { //【空链表】 或者 【只有一个节点的链表】
        return head
    }

    // 快慢指针找到中间节点，并且切开成两个部分
    fast,slow := head,head
    pre := head 
    for fast != nil && fast.Next != nil { 
        fast = fast.Next.Next
        pre = slow  // ！！！这个很重要，存储中点的【前置节点】
        slow = slow.Next
    }
    pre.Next = nil //！！！目的：找到中间节点的前一个节点，使【左右链表断开】
    
    l1 := sortList(head) //左链表
    l2 := sortList(slow) //右链表
    return merge(l1,l2)
}

func merge(l1,l2 *ListNode) *ListNode {
  	//1.创建一个虚拟节点dummy
    dummy := &ListNode{0,nil}
    cur := dummy
		
  	//2.合并两个升序链表，拼接到cur后面
    for l1 != nil && l2 != nil {
        if l1.Val < l2.Val {
            cur.Next = l1
            l1 = l1.Next
        } else {
            cur.Next = l2
            l2 = l2.Next
        }
        cur = cur.Next
    }

    if l1 != nil {
        cur.Next = l1
    }

    if l2 != nil {
        cur.Next = l2
    }

    return dummy.Next
}

```



## 31.下一个排列

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

思路：

以 `1,2,3,4,5,6` 为例，其排列依次为：

```go
123456
123465
123546
...
654321
```

可以看到有这样的关系：`123456 < 123465 < 123546 < ... < 654321`。

- 我们希望下一个数 比当前数大，这样才满足 “下一个排列” 的定义。因此只需要 将后面的「大数」与前面的「小数」交换，就能得到一个更大的数。比如 123456，将 5 和 6 交换就能得到一个更大的数 123465

- 我们还希望下一个数 增加的幅度尽可能的小，这样才满足“下一个排列与当前排列紧邻“的要求。为了满足这个要求，我们需要：

  - 在尽可能**靠右的低位**进行交换，需要**从后向前**查找

  - 将一个 尽可能小的「大数」 与前面的「小数」交换。比如 123465，下一个排列应该把 5 和 4 交换而不是把 6 和 4 交换
  - 将「大数」换到前面后，需要将「大数」后面的所有数 重置为升序，升序排列就是最小的排列。以 123465 为例：首先按照上一步，交换 5 和 4，得到 1235 64；然后需要将 5 之后的数重置为升序，得到 1235 46。显然 1235 46 比 1235 64 更小，123546 就是 123465 的下一个排列

这个就是推到下一个排列的基本规则
1. 尽可能的在右边交换
2. 尽可能让尽可能小的【大数】和前面的【小数】交互
3. 交换完成后，对后续的数进行升序排列

```go
func nextPermutation(nums []int)  {
  	///！！！这题的思路一般很难想出来（更多的是找规律）

 	 i := len(nums)-2 // 从倒数第二数字开始（目的：我们要找后面的数【大】 前面的数【小】，比如: 123456中的 5和6）
    for i >= 0 && nums[i] >= nums[i+1] { // 说明从【后向前】是升序排列（比如 654321 也就是说：后面的数【小】，而不是【大】）
        i--
    }
   
		
    if i >= 0 { //说明找到了【后面的数大】前面的数【小】的索引位置,比如 1234 65，中的数值4的位置
        end := len(nums)-1
        for end >= 0 &&  nums[i] >= nums[end] { // 从后向前，找到第一个比i稍微大的数，比如 1234 65，中的数值 5
            end--
        }
        //交换
        nums[i],nums[end] = nums[end],nums[i]
    }

    //对i+1后的数字升序排序[i+1,len(nums)-1] ，比如 1235 64，排序后变成 1235 46
    l,r := i+1,len(nums)-1
    for l < r {
        nums[l],nums[r] = nums[r],nums[l]
        l++
        r--
    }
}
```

## 22.括号生成

数字 `n` 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 **有效的** 括号组合。

思路：

- 利用回溯算法，在每个位置选择【左括号】或者【右括号】，组成括号组合
- 为了减少不必要的穷举，我们要知道合法括号串有以下性质

  - **一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解**。
  - **对于一个「合法」的括号字符串组合 `p`，必然对于任何 `0 <= i < len(p)` 都有：子串 `p[0..i]` 中左括号的数量都大于或等于右括号的数量**。

因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。

`backtrack`函数中，`left`表示剩余可选的左括号数量 `right`表示剩余可选的右括号数量

```go

var result []string
func generateParenthesis(n int) []string {
    result = []string{}
    
    track := []byte{}
  	// 1. 默认左右剩余括号都是n个
    backtrack(track,n,n)
    return result
}

//left剩余左括号数量 right剩余右括号数量
func backtrack(track []byte,left,right int) { 
  	// 括号恰好都使用完成
    if left == 0 && right == 0 {
        result = append(result,string(track))
        return
    }
  	// 剩余right < 剩余left，说明right选择多了，不符合题意
    if left < 0 || right < 0  || right < left { 
        return
    }

    track = append(track,'(') // 选择左括号
    backtrack(track,left-1,right)
    track = track[:len(track)-1] // 撤销选择

    track = append(track,')') // 选择右括号
    backtrack(track,left,right-1)
    track = track[:len(track)-1] //撤销选择
}

```



## 8. 字符串转换整数

请你来实现一个 `myAtoi(string s)` 函数，使其能将字符串转换成一个 32 位有符号整数。

函数 `myAtoi(string s)` 的算法如下：

1. **空格：**读入字符串并丢弃无用的前导空格（`" "`）
2. **符号：**检查下一个字符（假设还未到字符末尾）为 `'-'` 还是 `'+'`。如果两者都不存在，则假定结果为正。
3. **转换：**通过跳过前置零来读取该整数，直到遇到非数字字符或到达字符串的结尾。如果没有读取数字，则结果为0。
4. **舍入：**如果整数数超过 32 位有符号整数范围 `[−231, 231 − 1]` ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 `−231` 的整数应该被舍入为 `−231` ，大于 `231 − 1` 的整数应该被舍入为 `231 − 1` 。

返回整数作为最终结果。

思路：

整个字符串的格式是固定 **【空格】+【符号】+ 【数字/字母等等符号】**

这题只需要根据上面的4个条件实现即可

```go
func myAtoi(s string) int {
    count := len(s)
    sign := 1
    result := 0
    index := 0
   
    //1.先去掉前缀 空格
    for index < count && s[index] == ' ' {
        index++
    }

    //2.查看符号位
    if index < count {
        if s[index] == '+' {
            sign = 1
            index++
        } else if s[index] == '-' {
            sign = -1
            index++
        }
    } 

    //3. 把数字全部拿出来（遇到非数字，结束for循环）
    for index < count && s[index] >= '0' && s[index] <= '9' {
        result = result * 10 + int(s[index]-'0')
      	// 4. 舍入（截断）
        if sign * result >= math.MaxInt32 {
            return math.MaxInt32
        } else if sign * result <= math.MinInt32 {
            return math.MinInt32
        } 
        index++
    }
    return sign * result
}
```



## 69. x的平方根

给你一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

思路：

- 这里其实是一道数学题。比如 求数字 `4` 的平方根，转换成求两个数的乘积，就是 `2*2=4`。

- 利用二分法，找一个数字 `mid`，让 `mid*mid`的值不断的趋近于 `x`，那么`mid`就是平方根

```go
// x 是整数，求平方根
func mySqrt(x int) int {
    
    left, right := 0,x
    for left <= right {
        mid := left + (right-left)/2
        
        if x == mid * mid {
            return mid
        } else if x  < mid * mid {
            right = mid - 1 // mid 偏大
        } else {
            left = mid + 1 // mid 偏小
        }
    }
    // 执行到这里，left > right ，结果是一个浮点数,比如 2.3434,位于 [right,left]之间，因为只保留整数部分，所以取 right的值
    return right
}


// 有次面试，实际遇到的是这个题目（上面的变形题）
// x是浮点数求平方根，保留3位小数
func mySqrt1(x float64) float64 {
	l, r := 0.0, x
	for l <= r {
		mid := (l + r) /2 
		if x < mid*mid {
			r = mid - 1e-3
		} else {
			l = mid + 1e-3
		}
	}
	return r
}
```



## 2. 两数相加

给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。

请你将两个数相加，并以相同形式返回一个表示和的链表。你可以假设除了数字 0 之外，这两个数都不会以 0 开头。

![image-20241224163034165](./images/image-20241224163034165.png)

思路：

- 逆序存储很友好了，直接遍历链表就是从【个位】开始的，符合我们计算加法的习惯顺序。如果是正序存储，那倒要费点脑筋了，可能需要翻转链表或者使用栈来辅助。

- 这道题主要考察 链表双指针技巧和加法运算过程中对进位的处理。注意这个 `carry` 变量的处理，在我们手动模拟加法过程的时候会经常用到。

- **代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
  	// dummy 虚拟节点
    dummy := &ListNode{Val:0,Next:nil}
    p := dummy
  
  	// 记录进位
    carry := 0
 
  	// l1 l2 分别指向两个链表的头部，只有有一个不为nil 或者 进位不为0
    for l1 != nil || l2 != nil || carry > 0 { 
        val := carry //进位数

        if l1 != nil {
            val += l1.Val //l1数值
            l1 = l1.Next
        }

        if l2 != nil {
            val += l2.Val//l2数值
            l2 = l2.Next
        }

        carry = val / 10 //下一次的进位
        val = val % 10   //当前结果
        p.Next = &ListNode{Val:val,Next:nil} //拼接到p的Next
        p = p.Next
    }
		// 返回最终的头节点
    return dummy.Next
}
```



## 70. 爬楼梯

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

思路：

-  动态规划题型
- `dp[i]`含义：到达 `i`阶，可以有 `dp[i]`种不同的方法
- 递推关系：到达 `i-1`阶，有 `dp[i-1]`种方法，到达 `i-2`阶，有 `dp[i-2]`种方法，到达 `i`阶【可以从 `i-1`阶，爬 `1`个台阶直接到达】 或者 【可以从 `i-2`阶，爬 `2`个台阶直接到达】，有 `dp[i] = dp[i-1] + dp[i-2]`种方法

```go
func climbStairs(n int) int {
	// 定义 dp 数组，长度为 n+1
	dp := make([]int, n+1)
	
	for i := 0; i <= n; i++ {
    		// base case
        if i == 0 {
            dp[i] = 1 
        } else if i == 1 { // base case
            dp[i] = 1
        } else {
            dp[i] = dp[i-1] + dp[i-2] //到达dp[i],有两种方法：一种直接从dp[i-1],一种直接从dp[i-2]
        }
	}

    return dp[n]
}
```



## 165. 比较版本号

给你两个 **版本号字符串** `version1` 和 `version2` ，请你比较它们。版本号由被点 `'.'` 分开的修订号组成。**修订号的值** 是它 **转换为整数** 并忽略前导零。

比较版本号时，请按 **从左到右的顺序** 依次比较它们的修订号。如果其中一个版本字符串的修订号较少，则将缺失的修订号视为 `0`。

返回规则如下：

- 如果 `version1 < version2` 返回 `-1`，
- 如果 `version1 > version2` 返回 `1`，
- 除此之外返回 `0`。

思路：

这是一个比较实用的题目，工作中也可能出现

![image-20241224170806035](./images/image-20241224170806035.png)

- 将版本号字符串，按照 `.`分割为子字符串
- 利用双指针技巧，定义两个指针分别指向两个 版本号的子字符串，依次比较对应位的整数值（字符串转成整数），缺失的值视为`0`

```go
func compareVersion(version1 string, version2 string) int {
    //1.先按照"." 拆分字符串
    slicev1 := strings.Split(version1,".")
    slicev2 := strings.Split(version2,".")

    //2.对应位置一一对比
    i,j := 0,0 
    for ; i < len(slicev1) && j < len(slicev2);i,j = i+1,j+1 {
        val1 ,_ := strconv.Atoi(slicev1[i])
        val2,_ := strconv.Atoi(slicev2[j])
        if val1 > val2 {
            return 1
        } else if val1 < val2 {
            return -1
        }
    }
		
  	// 说明 version2 字符串比较短
    for i < len(slicev1) {
        val1 ,_ := strconv.Atoi(slicev1[i])
        i++
        if val1 > 0 { // version2 缺失的视为 0
            return 1
        }else if val1 < 0 {
            return -1
        }
    }
		
  	// 说明 version1 字符串比较短
    for j < len(slicev2) {
        val2,_ := strconv.Atoi(slicev2[j])
        j++
        if val2 > 0 { // version1 缺失的视为 0
            return -1
        }else if val2 < 0 {
            return 1
        }
    }

    return 0
}
```



## 239. 滑动窗口最大值

给你一个整数数组 `nums`，有一个大小为 `k` 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 `k` 个数字。滑动窗口每次只向右移动一位。

返回 *滑动窗口中的最大值* 。

思路：

使用【队列】充当不断滑动的窗口，每次滑动记录【队列】的最大值：

![image-20241224181832923](./images/image-20241224181832923.png)

如何在 `O(1)` 时间计算最大值，只需要一个特殊的数据结构「单调队列」，`push` 方法依然在队尾添加元素，但是要把前面比自己小的元素都删掉，直到遇到更大的元素才停止删除。

![image-20241224182245137](./images/image-20241224182245137.png)

使用单调队列数据结构就能完成本题，队列头部元素就是最大值。

```go
func maxSlidingWindow(nums []int, k int) []int {
    // 利用单调队列，记录窗口内最大值
    var result []int
    
    var q Queue
		
  	// 1. 先加入k个元素
    for i := 0;i<k;i++ {
        q.Push(nums[i])
    }
    result = append(result,q.MaxVal())//记录最大值

    for i := k;i<len(nums);i++ {
        q.Pop(nums[i-k])//队列容量为k，在加入新元素之前，先删除左边 nums[i-k]
        q.Push(nums[i])// 再追加新元素 nums[i]
        result = append(result,q.MaxVal()) //记录最大值
    }
    return result
}


// 单调队列
type Queue struct {
    q []int
}

// Push 队列
func (t *Queue)Push(val int){
    for len(t.q) != 0 && t.q[len(t.q)-1] < val { //队列中比val小的数值，全部删除
        //弹出尾部
        t.q = t.q[:len(t.q)-1]
    }
    t.q = append(t.q,val)//加入队列尾部
}

// 队列中的最大值
func (t *Queue)MaxVal() int {
    return t.q[0]
}

// 如果和队列头部最大元素相同，删除队列头部元素
func (t *Queue)Pop(val int) {
    if val == t.q[0] {
        t.q = t.q[1:] //删除头部
    }
}
```

## 41. 缺失的第一个正数

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

思路：

这题如果第一次做，会感觉很绕。其实本质目的就是让数值：比如 `1`放到索引 `0`， `2` 放到索引`1`，数值`3`放到索引`2` 。 这样就形成了，随着索引`i`的递增，元素值也是顺序递增的（并且之间是 `+1` 的关系）

题目要求【缺失的最小正整数】：将数组中的元素，按照 1，2，3，4，5，6.... 这个顺序排列。（同时观察到1,2,3,4,5和数组索引的关系 0,1,2,3,4，是相差`1`的关系）

- 数组的长度为`n`，如果数组中的元素都是按照1，2，3，4，5，6.... 这个顺序排列，也就是【`1～n`】，那么最小的正整数就是`n+1`

- 如果数组中的元素出现跳空（也就是缺失某一个）那么索引位置 `i`对应的元素值 `nums[i]`，之间不满足 `i+1 == nums[i]`

![image-20241225010731408](./images/image-20241225010731408.png)

```go
func firstMissingPositive(nums []int) int {
   
    for i := 0;i < len(nums);i++ {
        // 元素值要在[1~n]之间 && nums[i]-1索引处的元素值不是 nums[i]
        for nums[i] >= 1 && nums[i] <= len(nums) && nums[i] != nums[nums[i]-1] {
            // 交换 
            nums[nums[i]-1],nums[i] = nums[i],nums[nums[i]-1]
        }
    }

    // 找到第一个，索引 i 和数值 不是 +1 的关系；
    for i := 0; i < len(nums);i++ {
        if nums[i] != i+1 {
            return i+1
        }
    }
    // 如果上面全部都执行完成，还没有找到，那么这个数值就是数组长度+1
    return len(nums)+1
}
```



## 322. 零钱兑换

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

思路：

- 动态规划题型

- 定义`dp`数组：`dp[i]`表示凑成金额`i` 所需要的**最少的硬币个数**为 `dp[i]`

- 递推关系：

  为了凑成金额 `i`，可以供我们选择的硬币有`coins[0....]`不同面额的硬币；

  如果选择某个硬币 `coins[j]`，那么剩余金额变为`i - coins[j]` ；

  继续选择某个硬币 `coins[x]`，那么剩余的金额变为 `i -coins[j] - coins[x]`

  ![image-20241225155105399](./images/image-20241225155105399.png)

  最终的递推关系为：`dp[i] = min(dp[i], dp[i-coins[0...] + 1])`

  `dp[i-coins[0...] + 1 ` 含义： `coins[0...]` 每次选择，所有的硬币可供选择，如果选择某个硬币`coins[j]`后，凑成剩余金额`i-coins[j]`需要 `dp[i-coins[j]]`最少硬币个数  +1 表示选中了硬币`coins[j]`

  `min`表示，金额 `i`可以选的硬币有很多种`coins[0...]`，我们只需 硬币最小的结果

  *还有个前提，选中的硬币的面额，不能大于要凑的金额`i`*

```go
func coinChange(coins []int, amount int) int {

   
    dp := make([]int,amount+1)
  	// base case
    for k,_ := range dp {
        dp[k] = amount+1 // 因为要求最小值，假设都是1元来凑，最多需要amount个硬币，这里设置大一位，就可以表示很大的数值了
    }
  
    dp[0] = 0 // 没有金额，也就不需要硬币

    for i := 1;i <= amount;i++ { // 金额从1开始
      	// 可供选择的硬币 [0,len(coins)-1]
        for j := 0;j < len(coins);j++ {
            if i - coins[j] >= 0 { //当前选择的硬币金额coins[j]，不能超过金额i（才能选择）
                dp[i] = min(dp[i],dp[i-coins[j]]+1 )
            }
        }
    }

    if dp[amount] == amount+1 {
        // 说明凑不成改金额
        return -1
    }
    return dp[amount]
}

func min(a,b int)int{
    if a < b {
        return a
    }
    return b
}
```



## 32. 最长有效括号

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号子串的长度。

思路：

- 最值问题：就要想到 动态规划

  `dp[i]`表示以` s[i]` 结尾的字符串的长度

  如果 `s[i] == '(' `，不是一个有效字符串，`dp[i]`长度为`0`

  如果 `s[i] == ')'`，如果能找到 左括号，说明当前的右括号作为字符串的结尾，能找到左括号和自己一起组成一个有效的字符串，否则，右括号，作为结尾，不是一个有效的字符串

- 涉及到括号的问题：就需要想到 **栈**

  当遇到左括号，直接入栈 左括号的索引值

  如果遇到右括号，看下栈中是否为空，不为空，说明可以找到左括号和右括号一起组成有效字符串，否则，不能组成有效字符串（右括号需要入栈）

```go
func longestValidParentheses(s string) int {
  
	stackIndex := []int{} // 因为是括号问题，所以用到栈（栈中存储的是索引值）
	dp := make([]int, len(s))

	maxLen := 0
	// 遍历字符，尝试以每个字符作为【结尾字符】
	for i := 0; i < len(s); i++ {
		if s[i] == '(' {
			stackIndex = append(stackIndex, i) //【左括号】【索引】入栈

			dp[i] = 0 //以左括号结尾的子串，是无效的，所以长度=0
		} else { // 说明是右括号
			if len(stackIndex) != 0 { //说明栈里面有左括号
				leftIndex := stackIndex[len(stackIndex)-1]
				stackIndex = stackIndex[:len(stackIndex)-1] //出栈
				// 当前 右括号索引 i  - 左括号的索引 leftIndex + 1 可以计算出字符串的长度
				len := i + 1 - leftIndex //有效子串长度
       
				if leftIndex-1 >= 0 {  // 如果左括号索引的前一个索引 leftIndex-1，存在
					dp[i] = len + dp[leftIndex-1] // 当前的长度len,还可以和前面的以leftIndex-1为结尾的字符串 拼接成一个更长的有效字符串
				} else {
					dp[i] = len
				}

			} else { // 说明当前的右括号，在栈中找不到左括号，就是一个无效字符串的结尾
				dp[i] = 0
			}
		}
		// 求最值
		maxLen = max(maxLen, dp[i])
	}

	return maxLen
}

func max(a, b int) int {
	if a > b {
		return a
	}
	return b
}
```



## LCR 140. 训练计划 II

给定一个头节点为 `head` 的链表用于记录一系列核心肌群训练项目编号，请查找并返回倒数第 `cnt` 个训练项目编号。

思路：

这题和前面的删除链表中倒数第 n 个节点一样的套路：

`p1`指向链表头部，并且移动 `k`步

![image-20241220185846249](./images/image-20241220185846249.png)

`p2`指向链表头部，`p1`继续移动 剩余的 `n-k`步

![image-20241220190032419](./images/image-20241220190032419.png)

当 `p1 == nil`的时候，`p2`移动到了倒数的第 `k`个节点

![image-20241220190217013](./images/image-20241220190217013.png)

```go

/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func trainingPlan(head *ListNode, cnt int) *ListNode {

    // base case 
	if head == nil {
		return head
	}

	p1 := head // p1 先跳跃 cnt 个节点
	for i := 0; i < cnt; i++ {
		p1 = p1.Next
	}

	p2 := head
	for p1 != nil { //p1 从当前位置到达尾部
		p1 = p1.Next
		p2 = p2.Next //p2 正好移动到距离尾部cnt个节点的位置（倒数）
	}

	return p2
}
```



## 76. 最小覆盖子串

给你一个字符串 `s` 、一个字符串 `t` 。返回 `s` 中涵盖 `t` 所有字符的最小子串。如果 `s` 中不存在涵盖 `t` 所有字符的子串，则返回空字符串 `""` 。

**注意：**

- 对于 `t` 中重复字符，我们寻找的子字符串中该字符数量必须不少于 `t` 中该字符数量。
- 如果 `s` 中存在这样的子串，我们保证它是唯一的答案。

思路：

这题就是典型的滑动窗口类题目，一般来说难度略高，解法框架如下：

```java
nums := []int{1,2,3,4,5,6}
func main() {
  
  //1. 定义 `left right := 0,0` 指向起始位置 `0`
  left, right := 0,0
  
  // right 越界结束
  for right < len(nums) {
    
    // 2.不断移动 right
    val := nums[right]
    right++ 
    
    // do something.....
    
    // 3.当 condition 不符合题意的时候，移动 left，直到满足题意，跳出 condition
    for  condition {
      val := nums[left]
      left++
    }
    
    //.......
  }
}
```

题目要求 返回 `s` 中涵盖 `t` 所有字符的最小子串。

- 需要知道 `t`中有哪些字符

- 在 `s`中找到包含`t`中所有字符的字符串（注意是包含，不是相等），

  比如  `s = abc t = ac`，字符串 `s`是包含 `t`的所有字符的；

  比如 `s = abc   t = aa`，字符串 `s`是不包含 `t`中的所有字符的，因为`t`中有两个 `a`, `s`中只有一个 `a`

```go
func minWindow(s string, t string) string {
    
    // window 记录窗口内【注意：不是窗口内的所有字符，而是t中存在的】字符 + 频率
    // need 记录t中出现的 字符+频率
    need,window := make(map[byte]int),make(map[byte]int)

    for i := 0;i<len(t);i++ {
        need[t[i]]++ //记录t中字符 + 频率
    }

    //记录窗口中 当某个字符数量 已经达到了 t 中 相应字符数量的预期，vaild++ 说明窗口中包含了 t 中的一个有效字符
    vaild := 0
    left,right := 0,0

    start := 0
    length := math.MaxInt

    for right < len(s) {
        val := s[right] //  val 将要进入窗口的字符
        right++

        // 判断该字符是否在need中出现（再强调一遍：window中记录的是在 need中存在的字符数量，不是窗口中的所有字符）
        if _,ok := need[val]; ok {
            window[val]++  // 窗口中字符数量 +1
            if window[val] == need[val] {//说明window中该字符的数量，达到了need中字符的数量
                vaild++ // 窗口中，有一个字符数量达到目标预期
            }
        }

        for vaild == len(need) { //表示window中字符频率和need中的字符频率全部都一样了（也就是包含了t中的所有的字符）
            //找最小的子串，收缩 right
            if right - left < length { 
                start = left
                length = right-left
            }

            //val 将要从窗口删除的字符
            val := s[left]
            left++
            if _,ok := need[val];ok {
              	// 窗口中的字符数量 = need中字符数量一样，一旦字符从窗口中移除，那么窗口中的字符串就不再完全包含 t 中的所有字符了
                if window[val] == need[val] {
                    vaild--
                } 
                window[val]--
            }
        }

    }
  	// 说明不存在完全包含 t 中所有字符的字符串
    if length == math.MaxInt {
        return ""
    }
    return string(s[start:start+length])
}
```



## 105. 从前序与中序遍历序列构造二叉树

给定两个整数数组 `preorder` 和 `inorder` ，其中 `preorder` 是二叉树的**先序遍历**， `inorder` 是同一棵树的**中序遍历**，请构造二叉树并返回其根节点。

思路：

**构造二叉树，第一件事一定是找根节点，然后想办法构造左右子树**。

二叉树的前序和中序遍历结果的特点如下：

![image-20241225182611962](./images/image-20241225182611962.png)

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */
func buildTree(preorder []int, inorder []int) *TreeNode {
  	// 数组为空，返回nil
    if len(preorder) == 0 || len(inorder) == 0 {
        return nil
    }
  	// leftLen 表示左节点的个数
    leftLen := 0
    // 前序的首元素为根节点
    va := preorder[0]
    //在中序遍历中找到对应的位置
    for k,v := range inorder {
        if v == va {
            leftLen = k
            break 
        }
    }
		
  	// 结合下图理解
    root := &TreeNode{Val:preorder[0],Left:buildTree(preorder[1:1+leftLen],inorder[:leftLen]),Right:buildTree(preorder[1+leftLen:],inorder[leftLen+1:])}
    return root
}
```

![image-20241225183428074](./images/image-20241225183428074.png)



## 78. 子集

给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。

思路：

回溯算法：类似于遍历这棵树

![image-20241225185323251](./images/image-20241225185323251.png)

```go

var result [][]int
func subsets(nums []int) [][]int {
  	// 结果
    result = [][]int{}
  	// 遍历路径
    trace := []int{}
    backtrack(nums,trace,0)
    return result
}

func backtrack(nums []int,trace []int,start int) {
		
  	// 将 trace 保存到result中
    temp := make([]int,len(trace))
    copy(temp,trace)
    result = append(result,temp)
	
  	// 选择范围: [start:len(nums)-1]
    for i := start;i < len(nums);i++ {
        //选择
        trace = append(trace,nums[i])
			
      	// 下一层的选择
        backtrack(nums,trace,i+1)
        //撤销
        trace = trace[:len(trace)-1]
    }
}
```

## 43. 字符串相乘

给定两个以字符串形式表示的非负整数 `num1` 和 `num2`，返回 `num1` 和 `num2` 的乘积，它们的乘积也表示为字符串形式。

**注意：**不能使用任何内置的 BigInteger 库或直接将输入转换为整数。

思路：

- 定义两个指针`i j`，分别指向 `num1` 和 `num2`的尾部，从个位开始计算乘积
- 计算的结果累加，保存到 `res`的索引 `i+j+1`位置处

![image-20241226174016960](./images/image-20241226174016960.png)

- 最后，将`res`中的结果，从尾部到首部（也就是从个位）依次进位，得到最终的结果

![image-20241226174438216](./images/image-20241226174438216.png)

```go
func multiply(num1 string, num2 string) string {
    
  	// 定义result 切片，长度为 m+n
    m,n := len(num1),len(num2)
    result := make([]int,m+n)

    // 1.从后往前【相乘】，（从个位开始进行相乘）
    for i := m-1;i >= 0;i-- {
        for j := n-1;j >= 0;j-- {
            result[i+j+1] += int(num1[i] - '0') * int(num2[j]-'0') // 乘积的结果，累加保存到 result[i+j+1]
        }
    }

    // 2.从后往前【进位】
    for i := len(result)-1;i >= 0;i-- {
        if result[i] >= 10 { // 超过数值10
            result[i-1] += result[i] / 10 // 进位
            result[i] %= 10 //当前取余
        }
    }
	
    
    // 如果题目中两个字符串为 1234 和 0，那么result中全部都是前导 0，都是无意义的 0
    res := ""
  
    zero := true // 从第一个非0的数字，开始记录结果
    for _,v := range result { //遍历数值
        if v == 0 && zero { // 忽略掉，前导 0
            continue
        }
        zero = false // 这个表示，遇到第一个非0的元素，后续的0才认为有效
        res +=  string('0' + rune(v))
    }
    // 没结果，默认是0
    if res == "" { 
        res = "0"
    }
    return  res
}
```



## 151. 反转字符串中的单词

给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。返回 **单词** 顺序颠倒且 **单词** 之间用单个空格连接的结果字符串。

**注意：**输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

思路：

这题如果做过了，很容易理解+记忆，全是技巧，没有感情。面试华为`OD`岗位有这道原始题目。

- 先去掉多余的空格
- 对整个字符串进行反转
- 然后移动对每个单词进行反转

```go
func reverseWords(s string) string {
    //1.先清理空格
    result := []byte{}
    for i := 0;i<len(s);i++ { //一个字符一个字符的过滤
        if s[i] != ' ' { // 不是空格，保存
            result = append(result,s[i])
        } else {// 是空格，要求必须存在有效字符，并且不是空格
            if len(result) != 0 && result[len(result)-1] != ' ' {
                result = append(result,' ')
            }
        }
    }
    //2.如果存在（去除最后一个空格）
    if result[len(result)-1] == ' ' {
        result = result[:len(result)-1]
    }
    //3.翻转整个字符串
    reverse(result,0,len(result)-1)

    //4.翻转每个单词
    for i := 0;i < len(result); {
        for j := i;j < len(result);j++ {// 找到一个单词
            if j + 1 == len(result) || result[j+1] == ' ' { //找到空格，或者 结尾
                reverse(result,i,j)
                //开始下一个单词（跳过结尾和空格）
                i = j + 2
                break
            }

        }
    }
		// 最终结果
    return string(result)
}

func reverse(word []byte,i,j int){
    for i < j {
        word[i],word[j] = word[j],word[i]
        i++
        j--
    }
}
```



## 155. 最小栈

设计一个支持 `push` ，`pop` ，`top` 操作，并能在常数时间内检索到最小元素的栈。

实现 `MinStack` 类:

- `MinStack()` 初始化堆栈对象。
- `void push(int val)` 将元素val推入堆栈。
- `void pop()` 删除堆栈顶部的元素。
- `int top()` 获取堆栈顶部的元素。
- `int getMin()` 获取堆栈中的最小元素。

思路：

我们知道栈是一种操作受限的数据结构，只能从栈顶插入或弹出元素，所以对于标准的栈来说，如果想实现本题的 `getMin` 方法，只能老老实实把所有元素弹出来然后找最小值。**想提高时间效率，那肯定要通过空间换时间的思路**。

所以这道题的关键就是，**每个元素入栈时，还要记下来当前栈中的最小值**。比方说，可以用一个额外的栈 `minstack` 来记录栈中每个元素入栈时的**栈中的最小元素**是多少，这样每次获取元素时就能快速得到剩余栈中的最小元素了。

```go
type MinStack struct {
    stack []int // 存储所有元素
    minstack []int // 存储最小元素（也就是比栈顶元素还要小的元素，才能保存到 minstack中）
}


func Constructor() MinStack {
    return MinStack {
        stack:make([]int,0),
        minstack:make([]int,0),
    }
}


func (this *MinStack) Push(val int)  {
  	// 入栈
    this.stack = append(this.stack,val)

    if len(this.minstack) == 0 {
        this.minstack = append(this.minstack,val)
    } else {
      	// val 比 minstack 栈顶元素更小，才能保存（记录栈中每个元素入栈时的栈中的最小元素）
        if this.minstack[len(this.minstack)-1] >= val {
            this.minstack = append(this.minstack,val)
        }
    }
}


func (this *MinStack) Pop()  {
		// 如果弹出的元素和最小栈的栈顶元素一样，最小栈也需要弹出
    if this.Top() == this.minstack[len(this.minstack)-1] {
         this.minstack = this.minstack[:len(this.minstack)-1]
    }
		// 弹出栈顶元素
    this.stack = this.stack[:len(this.stack)-1]
}

// 栈顶元素
func (this *MinStack) Top() int {
    return this.stack[len(this.stack)-1]
}

// 最小元素
func (this *MinStack) GetMin() int {
    return this.minstack[len(this.minstack)-1]
}

```



## 129. 求根节点到叶子节点数字之和

给你一个二叉树的根节点 `root` ，树中每个节点都存放有一个 `0` 到 `9` 之间的数字。

每条从根节点到叶节点的路径都代表一个数字：

- 例如，从根节点到叶节点的路径 `1 -> 2 -> 3` 表示数字 `123` 。

计算从根节点到叶节点生成的 **所有数字之和** 。

**叶节点** 是指没有子节点的节点。

![image-20241227162052025](./images/image-20241227162052025.png)

思路：

这题就是标准的二叉树遍历题型，遍历的同时需要累积每个节点的值

```go

func sumNumbers(root *TreeNode) int {
    return traverse(root,0)
}

// root 从根节点到叶节点生成的 所有路径数字之和 
// cur 累积到root 节点，对应的数字
func traverse(root *TreeNode,cur int) int {
    
    if root == nil {
        return 0
    }
    // 遍历到当前节点，对应的路径数字
    cur = 10 * cur + root.Val
   
    if root.Left == nil && root.Right == nil { // 说明当前是叶子节点
        return cur // 返回路径数字
    }
  	// 从 root.Left到叶子节点 路径数字之和 + 从 root.Right 到叶子节点 路径数字之和
    return traverse(root.Left,cur) + traverse(root.Right,cur)
}
```



## 101. 对称二叉树

给你一个二叉树的根节点 `root` ， 检查它是否轴对称。

![image-20241227165730354](./images/image-20241227165730354.png)

思路：

- 观察下上面的示例，【对称】就是左右两颗树是镜像。对称的检查过程，就是二叉树的遍历过程。
- 先检查左右两个根节点`root.Left root.Right`是否相同；
- 如果相同，再检查【左节点的左树 和 右节点的右树】 以及【左节点的右树 和 右节点的左树】是否对称

```go
func isSymmetric(root *TreeNode) bool {
  	// 空树，一定对称
   if root == nil {
       return true
   }
	 // 检查左右树是否对称
   return check(root.Left,root.Right)
}

// check 校验左右树对称
func check(left,right *TreeNode) bool {
    // 都是nil
    if left == nil && right == nil {
        return true
    }
    // 有一个是nil
    if left == nil || right == nil {
        return false
    }
  	// 左右节点不相同
    if left.Val != right.Val {
        return false
    }
    // 在【左右树根节点】相同的情况下，继续检查下层的树结构，是否对称
    return check(left.Left,right.Right) && check(left.Right,right.Left)
}
```



## 144. 二叉树的前序遍历

给你二叉树的根节点 `root` ，返回它节点值的 **前序** 遍历。

```go
// 迭代方式前序遍历二叉树 （ 这个解法和上面的【中序遍历】对比看下，可以看到完全一样的写法，只是 【记录数值】的位置不同而已
func preorderTraversal1(root *TreeNode) []int {

    result := []int{}
    if root == nil {
        return result
    }

    sk := []*TreeNode{}
    for len(sk) != 0 || root != nil {
      	// 先处理左节点
        for root != nil {
            result = append(result,root.Val) // 记录数值
            sk = append(sk,root) // 入栈
            root = root.Left
        }
        // 再处理右节点
        root = sk[len(sk)-1]
        sk = sk[:len(sk)-1] // 出栈
        root = root.Right
    }
    return result
}


// 最简单的递归方式遍历二叉树
var res []int
func preorderTraversal(root *TreeNode) []int {

    res = []int{}
    preorder(root)

    return res
}

func preorder(root *TreeNode){
    if root == nil {
        return
    }

    res = append(res,root.Val)
    preorder(root.Left)
    preorder(root.Right)
}
```



## 104. 二叉树的最大深度

给定一个二叉树 `root` ，返回其最大深度。二叉树的 **最大深度** 是指从根节点到最远叶子节点的最长路径上的节点数。

思路：

注意`maxDepth`函数的定义：以 `root`为根节点的二叉树的最大深度

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

// 以 `root`为根节点的二叉树的最大深度
func maxDepth(root *TreeNode) int {
  	// 如果节点为nil,深度为0
    if root == nil {
        return 0
    }
  	// 以 root.Left 为根节点的二叉树的最大深度 
  	// 以 root.Right 为根节点的二叉树的最大深度 
    // 取最大值 + 1 作为 以 `root`为根节点的二叉树的最大深度（ +1 表示当前的root这个节点的计数）
    return max(maxDepth(root.Left),maxDepth(root.Right)) + 1
}

func max( a,b int) int{
    if a > b {
        return a
    }
    return b
}
```



## 39. 组合总和

给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。

`candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。 

对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。

思路：

利用回溯算法解题：

- 需要指定 `start`限定可选元素的范围（因为是求组合问题），如果是求排列，不用指定形参 `start`（可以看下上面的回溯算法解题套路模板）
- 元素可以重复使用多次

这道题的关键在于 `candidates` 中的**元素可以复用多次**，体现在代码中是下面这段：

```go
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
  
  for i := start; i < len(candidates); i++ {
		// 选择
    
    // 下一层的选择【注意这里：i】
		backtrace(candidates, i , trace, target, sum)
    
    // 撤销
	}
}
```

如果题目要求 `candidates`中的元素【不能】重复多次，体现在代码中是下面这段：

```go
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
  
  for i := start; i < len(candidates); i++ {
		// 选择
    
    // 下一层的选择【注意这里：i+1】
		backtrace(candidates, i+1 , trace, target, sum)
    
    // 撤销
	}
}
```

注意体会先这两种区别。

实际代码如下：

```go
var result [][]int

func combinationSum(candidates []int, target int) [][]int {
	//回溯算法

	result = [][]int{}
	trace := []int{}
	backtrace(candidates, 0, trace, target, 0)

	return result
}

// 因为求组合问题，需要 start来限定元素的选择范围，如果是求排列，就不需要 start参数
func backtrace(candidates []int, start int, trace []int, target int, sum int) {
	
  // 终止条件
	if sum >= target {  // 因为都是正整数（剪枝）
		if sum == target { // 找到一个结果
			temp := make([]int, len(trace))
			copy(temp, trace)
			result = append(result, temp)
		}
		return
	}

	// 执行到这里，说明 sum < target，继续找下一个元素加入到 trace 中
	for i := start; i < len(candidates); i++ {
    // 选择
		trace = append(trace, candidates[i])
		sum += candidates[i]

    // 下一层（元素可以重复选择）的选择范围为 [i:len(nums)-1]
    // 如果不能重复选择，这里应该填写 i+1
		backtrace(candidates, i , trace, target, sum)

    // 撤销
		trace = trace[:len(trace)-1]
		sum -= candidates[i]
	}
}
```



## 101. 平衡二叉树

给定一个二叉树，判断它是否是 平衡二叉树 

思路：

**平衡二叉树** 是指该树所有节点的左右子树的高度相差不超过 1

其实这题是**求树的最大深度**的一个扩展，多了一步求左右子树的高度差

```go
/**
 * Definition for a binary tree node.
 * type TreeNode struct {
 *     Val int
 *     Left *TreeNode
 *     Right *TreeNode
 * }
 */

var isbalance bool = true
func isBalanced(root *TreeNode) bool {
    isbalance = true
    if root == nil {
        return true
    }
    maxDepth(root)
    return isbalance
}

// 求树的最大深度
func maxDepth(root *TreeNode) int {
    if root == nil {
        return 0
    }
		// 左右树的最大深度
    leftVal := maxDepth(root.Left)
    rightVal := maxDepth(root.Right)
  	// 如果高度差，绝对值相差 1，说明不平衡
  if abs(leftVal,rightVal) > 1 {
        isbalance = false
    }
    return 1 + max(leftVal,rightVal)
}

func abs(a,b int) int {
    if a > b {
        return a-b
    }
    return b-a
}
func max(a,b int)int{
    if a>b {
        return a
    }
    return b
}
```

## 48. 旋转图像

给定一个 *n* × *n* 的二维矩阵 `matrix` 表示一个图像。请你将图像顺时针旋转 90 度。你必须在**[ 原地](https://baike.baidu.com/item/原地算法)** 旋转图像，这意味着你需要直接修改输入的二维矩阵。**请不要** 使用另一个矩阵来旋转图像。

![image-20241228174153448](./images/image-20241228174153448.png)

思路：

这题其实就是**瞪眼法**找到数字之间的交换规则。

先把二维矩阵沿对角线反转，然后反转矩阵的每一行，结果就是顺时针反转整个矩阵。

```go
func rotate(matrix [][]int)  {
    ///！！！巧思题：顺时针旋转,从左上角到右下角--对角线交换；如果是逆时针旋转，按照右上角到左下角-对角线交换
    ///1.顺时针旋转,按照从左上角到右下角--对角线交换，结果为
    /*
        1 4 7
        2 5 8
        3 6 9
    */
    n := len(matrix)
    for i := 0;i < n;i++ {
        for j := i+1;j < n;j++ {
            //对角线翻转
            matrix[i][j],matrix[j][i] = matrix[j][i],matrix[i][j]
        }
    }
    
    ///2.再观察，每一行首尾交换，即为结果
    for i := 0;i < n;i++ {
        left ,right := 0,n-1
        for left < right {
            matrix[i][left],matrix[i][right] = matrix[i][right],matrix[i][left]
            left++
            right--
        }
    }
}

```



## 543. 二叉树的直径

给你一棵二叉树的根节点，返回该树的 **直径** 。二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

思路：

所谓二叉树的直径，就是左右子树的最大深度之和，那么直接的想法是对每个节点计算左右子树的最大高度，得出每个节点的直径，从而得出最大的那个直径。

```go

var result int = 0
func diameterOfBinaryTree(root *TreeNode) int {
   
    result = 0
    maxDepth(root)
    return result
}

// 树的最大高度
func maxDepth(root *TreeNode) int{

    if root == nil {
        return 0
    }
    // root左子树最大高度
    leftDepth := maxDepth(root.Left)
    // root右子树最大高度
    rightDepth := maxDepth(root.Right)
    //经过root节点的最大直径（注意：这里不需要对leftDepth + rightDepth 再+1），计算的是边的数目
    result = max(result,leftDepth+rightDepth) 
  
  	// 左右子树高度的最大值 + 1
    return 1 + max(leftDepth,rightDepth) 
}

func max(a,b int) int {
    if a > b {
        return a
    }
    return b
}
```



## 470. 用 Rand7()实现Rand10()



给定方法 `rand7` 可生成 `[1,7]` 范围内的均匀随机整数，试写一个方法 `rand10` 生成 `[1,10]` 范围内的均匀随机整数。

你只能调用 `rand7()` 且不能调用其他方法。请不要使用系统的 `Math.random()` 方法。

每个测试用例将有一个内部参数 `n`，即你实现的函数 `rand10()` 在测试时将被调用的次数。请注意，这不是传递给 `rand10()` 的参数。

思路：

- `(rand7()-1)*7`  等价于 `(【1...7】- 1) * 7 ` 等价于 ` [0...6]*7 ` 也等价于 `【0，7，14，21，28，35，42】`  每个数字只出现的概率为`1/7`
- `(rand7()-1)*7 + rand7() ` 等价于`【0，7，14，21，28，35，42】+ rand7()` 等价于每个数值`(0 , 7 ,14...)`分别 `+ rand7()` 即为`[1...7][8...14][15...21].....[43..49] 每种值出现的概率都是相同的；1/49`
- 转化一下为：`[1...10] [11...20] [21..30] [31....40] [41...49]` 这里少了`50`这个数值，对`10`求余数，少了出现一次`0`的机会
- 比如求【余数1 】分别为 `1 11 21 31 41` 对10求余，可以得到`5`次`1`
- 求【余数0】分别为`10 20 30 40`对10求余，只能得到`4`次`1`

```go
func rand10() int {
   
    for {
        num := (rand7()-1)*7 + rand7() 
        if num <= 40 { // 这里要舍弃[41...49]这些数值
            return num % 10 + 1 // 因为求 [1..10]，所以需要 num%10 + 1
        }
    }
    return 0    
}
```



## 98. 验证二叉搜索树

给你一个二叉树的根节点 `root` ，判断其是否是一个有效的二叉搜索树。

**有效** 二叉搜索树定义如下：

- 节点的左子树只包含小于 当前节点的数。
- 节点的右子树只包含 **大于** 当前节点的数。
- 所有左子树和右子树自身必须也是二叉搜索树。

思路：

初学者做这题很容易有误区：`BST`（二叉搜索树） 不是左小右大么，那我只要检查 `root.val > root.left.val` 且 `root.val < root.right.val` 不就行了？

这样是不对的，因为 `BST` 左小右大的特性是指 `root.val` 要比【左子树的**所有节点**都更大】，要比【右子树的**所有节点**都小】，你只检查左右两个子节点当然是不够的。

正确解法是通过使用辅助函数，增加函数参数列表，在参数中携带额外信息，将这种约束传递给子树的所有节点，这也是二叉搜索树算法的一个小技巧吧。

```go
func isValidBST(root *TreeNode) bool {
    return isValid(root,nil,nil) // 刚开始的root不是任何节点的左子树和右子树，所以不存在min和max节点
}

// 验证 root 树 与 最大节点值和最小节点值
//  min <   root树的节点值  < max
func isValid(root *TreeNode, min *TreeNode,max *TreeNode) bool {
		// 验证节点值
    if root == nil {
        return true
    }
		
  	// min最小值不为空，root的值，如果比最小值还小，说明root节点不满足 BST性质
    if min != nil && root.Val <= min.Val{
        return false
    }
		// max 最小值不为空，root的值，如果比最大值还大，说明root节点不满足 BST性质
    if max != nil && root.Val >= max.Val {
        return false
    }
    // 左子树的最大值就是root节点
  	// 右子树的最小值就是root节点
    return isValid(root.Left,min,root) && isValid(root.Right,root,max)
}
```



## 221. 最大正方形

在一个由 `'0'` 和 `'1'` 组成的二维矩阵内，找到只包含 `'1'` 的最大正方形，并返回其面积。

思路：

动态规划：

- `dp[i][j] `表示 `matrix[i][j]`为正方形右下角的**边长**，上边，左边，左上的边长 `>1`，才能组成一个更大完整的正方形；

- 递推关系：

  如果`matrx[i][j] == 0`，说明无法组成只包含 `'1'` 的正方形，`dp[i][j] = 0`即边长为`0`

  如果 `matrx[i][j] == 1`，看下上边，左边，左上 边长 `> 1`，才能组成一个更大的正方形，所以 `dp[i][j] = min(dp[i-1][j],dp[i][j-1],dp[i-1][j-1]) + 1`

![image-20241230185928924](./images/image-20241230185928924.png)

```go
func maximalSquare(matrix [][]byte) int {
	m, n := len(matrix), len(matrix[0])
  // 定义 边长 dp 数组
	dp := make([][]int, m)
	for k, _ := range dp {
		dp[k] = make([]int, n)
	}
	// 最大边长
	length := 0

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			// base case
			if i == 0 || j == 0 { // 第一行 or 第一列
				dp[i][j] = int(matrix[i][j] - '0')
			} else {

				if matrix[i][j] == '1' { // 当等于1的时候，才能作为正方形的右下角，求取长度
					dp[i][j] = min(dp[i-1][j], min(dp[i][j-1], dp[i-1][j-1])) + 1
				}
			}
			// 题目要求最大正方形，这里记录最大边长 length
			if dp[i][j] > length {
				length = dp[i][j]
			}
		}
	}
	// 边长*边长 = 正方形面积
	return length * length
}

func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
```



## 34. 在排序数组中查找元素的第一个和最后一个位置

给你一个按照非递减顺序排列的整数数组 `nums`，和一个目标值 `target`。请你找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 `target`，返回 `[-1, -1]`。你必须设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

思路：

二分搜索的难点就在于如何搜索左侧边界和右侧边界，代码的边界的控制非常考验你的微操，这也是很多人知道二分搜索原理但是很难写对代码的原因。写对二分搜索的关键在于搞清楚搜索边界，到底应该往左侧收敛还是应该往右侧收敛？

![image-20241231174802185](./images/image-20241231174802185.png)

![image-20241231174831359](./images/image-20241231174831359.png)

```go
func searchRange(nums []int, target int) []int {

    return []int{left_bound(nums,target),right_bound(nums,target)}
}

// 求左边界
func left_bound(nums []int ,target int) int {

    left,right := 0,len(nums)-1
		// 闭区间[left,right]
    for left <= right {
				// 中间值
        mid := left + (right-left)/2

        if nums[mid] == target { // 相等的时候，收缩right；【因为我们要求的是左边界】
            right = mid -1
        } else if nums[mid] > target { // 说明 target值位于nums[mid]的左侧，收缩right
            right = mid -1
        } else if nums[mid] < target { // 说明 target 位于 nums[mid]的右侧，收缩left
            left = mid + 1
        }
    }
    
    // 当所有的值都比target小的时候，left会越界
    // 当所有的值都比target大的时候，left此时是不会移动，所以要看下left指向的值是否是target
    if left >= len(nums) || nums[left] != target { // 做边界检测
        return -1
    }
    return left
}

// 求右边界
func right_bound(nums []int ,target int) int {

    left,right := 0,len(nums)-1

    for left <= right {
				// 中间值
        mid := left + (right-left)/2

        if nums[mid] == target { // 求右边界，当相等的时候，收缩左边界
            left = mid + 1
        } else if nums[mid] > target { // 说明 target值位于nums[mid]的左侧，收缩right
            right = mid - 1
        } else if nums[mid] < target { // 说明 target 位于 nums[mid]的右侧，收缩left
            left = mid + 1
        }
    }
    
    // 当所有的数都大于target的时候，right就会一直-1，最后会越界
    // 当所有的数都小于target的时候，right保持不动；所以要看下right指向的值是否是target
    if right < 0 || nums[right] != target { // 做边界检测
        return -1
    }
    return right
}
```



## 394. 字符串解码

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 `encoded_string` 正好重复 `k` 次。注意 `k` 保证为正整数。你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 `k` ，例如不会出现像 `3a` 或 `2[4]` 的输入。

思路：

首先要理解题目的意思：比如`3[a]`解码的结果为`aaa`。 `3`表示 `a`重复的次数。这题如果第一次做，还是挺难，一般遇到字符串带括号的问题，就要想到**栈**。利用栈记录上次的解码结果

这里以 `a6[c]`为例子演示一下：

![image-20241231185903633](./images/image-20241231185903633.png)

- 从左到右遍历字符串， `curStr`和`curNum` 记录当前的字符串和数值
- 遇到`[ `入栈当前的`curStr`和`curNum`（目的是为了存储上次的结果）同时清空当前`curStr`和`curNum`（目的是为了复用`curStr`和`curNum`用于 `[待处理字符串]` 之间的编码字符串）
- 遇到`] `出栈 ，出栈的字符串（前一个字符串） + 出栈的`num`（表示重复的次数）值和当前的`curStr`组合 = 形成新的字符串，保存到 `curStr`中

```go
func decodeString(s string) string {
   
    curStr,strStack := "",[]string{} // curStr 当前字符串
    curNum,numStack := 0,[]int{} // curNum 当前的数值

    for _,v := range s {
        if v >= '0' && v <= '9' { // 当前的curNum
            curNum = curNum * 10 + int(v-'0')
        } else if v == '[' { // 入栈，记录下当前的curNum和curStr
            strStack = append(strStack,curStr)
            numStack = append(numStack,curNum)
						// 清空
            curStr = ""
            curNum = 0

        } else if v == ']' { //出栈，上次记录下来的curNum和curStr,目的是为了展开[]之间的字符串


            preStr := strStack[len(strStack)-1]
            preNum := numStack[len(numStack)-1] 

            // 例如：a2[c] , preStr = a   preNum = 2   curStr = c，结果为 a+cc = acc
            curStr = preStr + strings.Repeat(curStr,preNum) // 这里对curStr进行重复preNum次
						// 出栈
            strStack = strStack[:len(strStack)-1]
            numStack = numStack[:len(numStack)-1]

        }else { // 当前的curStr
            curStr += string(v)
        }
    }
		// curStr中记录这最终的解码结果
    return curStr
}
```



## 240. 搜索二维矩阵II

编写一个高效的算法来搜索 `m x n` 矩阵 `matrix` 中的一个目标值 `target` 。该矩阵具有以下特性：

- 每行的元素从左到右升序排列。
- 每列的元素从上到下升序排列。

![image-20241231191629942](./images/image-20241231191629942.png)

思路：

这道题说 `matrix` 从上到下递增，从左到右递增，显然左上角是最小元素，右下角是最大元素。**我们如果想高效在 `matrix` 中搜索一个元素，肯定需要从某个角开始**，比如说从左上角开始，然后每次只能向右或向下移动，不要走回头路。

如果真从左上角开始的话，就会发现无论向右还是向下走，元素大小都会增加，那么到底向右还是向下？不确定

但实际上不用这么麻烦，我们不要从左上角开始，而是从右上角开始，规定只能向左或向下移动。

你注意，如果向左移动，元素在减小，如果向下移动，元素在增大，这样的话我们就可以根据当前位置的元素和 `target` 的相对大小来判断应该往哪移动，不断接近从而找到 `target` 的位置。

当然，如果你想从左下角开始，规定只能向右或向上移动也可以

```go
func searchMatrix(matrix [][]int, target int) bool {
    // 正常思路：遍历二维矩阵；但是每一行和每一列的元素都是有序的；
    //那么如果从【左上角】开始比较，当target大于左上角的数值的时候，有两个选择，【向右】或【向下】,不确定
    //那么如果从【右上角】开始比较，当15 > target的时候，说明target比较小，那么只能向左查找，因为如果向下，元素值更大。不符合题意，也就是此时只会有一种选择

    m := len(matrix)
    n := len(matrix[0])
		// 右上角
    i := 0
    j := n-1

    for i < m && j >= 0 {
        if matrix[i][j] == target {
            return true
        } else if matrix[i][j] > target { // 向左移动,找更小值
            j--
        } else if matrix[i][j] < target { // 向下移动，找更大值
            i++
        }
    }

    return false
}
```

